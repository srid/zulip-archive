<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="I&#39;m messing with megaparsec, trying to create a simple language. Right now I&#39;m trying to lex
x = 1
y = 2



into
[ Name &quot;x&quot;, Equals, Lit 1, NewLine, Name &quot;y&quot;, Equals, Lit 2, NewLine]


for later parsing.
The problem that I&#39;m running into, is that I&#39;m confused about how to use L.space. I&#39;ll need to g" name="description"><link href="https://funprog.srid.ca/haskell/megaparsec-basics.html" rel="canonical"><meta property="og:title" content="Megaparsec basics - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2020-09-26T14:09:21Z"><meta property="og:article:published_time" content="2020-09-26T11:15:05Z"><meta property="og:image" content="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"><title>Megaparsec basics - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">Megaparsec basics - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">Megaparsec basics</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211355326" name="211355326"><div>2020-09-26 11:15:05</div></a></div><div class="text"><p>I'm messing with megaparsec, trying to create a simple language. Right now I'm trying to lex</p>
<div class="codehilite"><pre><span></span><code>x = 1
y = 2
</code></pre></div>


<p>into</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="p">[</span> <span class="kt">Name</span> <span class="s">"x"</span><span class="p">,</span> <span class="kt">Equals</span><span class="p">,</span> <span class="kt">Lit</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">NewLine</span><span class="p">,</span> <span class="kt">Name</span> <span class="s">"y"</span><span class="p">,</span> <span class="kt">Equals</span><span class="p">,</span> <span class="kt">Lit</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">NewLine</span><span class="p">]</span>
</code></pre></div>

<p>for later parsing.</p>
<p>The problem that I'm running into, is that I'm confused about how to use <a href="https://hackage.haskell.org/package/megaparsec-9.0.0/docs/Text-Megaparsec-Char-Lexer.html#v:space">L.space</a>. I'll need to give L.space a parser which does not skip newlines, so that I can emit <code>NewLine</code> tokens. The docs recommend a setup where you define a lexeme that automatically skips trailing whitespace. I currently have</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">type</span> <span class="kt">Lexer</span> <span class="ow">=</span> <span class="kt">Parsec</span> <span class="kt">Void</span> <span class="kt">Text</span>

<span class="c1">-- SNIP</span>

<span class="nf">sc</span> <span class="ow">::</span> <span class="kt">Lexer</span> <span class="nb">()</span>
<span class="nf">sc</span> <span class="ow">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">space</span> <span class="n">space1</span>
                   <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="n">skipLineComment</span> <span class="s">"--"</span><span class="p">)</span>
                   <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="n">skipBlockComment</span> <span class="s">"{-"</span> <span class="s">"-}"</span><span class="p">)</span>

<span class="nf">lexeme</span> <span class="ow">::</span> <span class="kt">Lexer</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Lexer</span> <span class="n">a</span>
<span class="nf">lexeme</span> <span class="ow">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">lexeme</span> <span class="n">sc</span>

<span class="nf">symbol</span> <span class="ow">::</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">Lexer</span> <span class="kt">Text</span>
<span class="nf">symbol</span> <span class="ow">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">symbol</span> <span class="n">sc</span>
</code></pre></div>

<p>So, I think I'll need to modify sc to not eat newlines by passing something other than space1 as the first argument to L.space. </p>
<p>The thing I can't figure out is how to deal with the fact that often, you will expect to find a newline immediately after a preceding lexeme, with no intervening whitespace. Since the argument to L.space can't accept empty input, sc can't accept empty input. How do I deal with this? Do I have to throw out the whole model of always consuming whitespace after a lexeme? Is making newline a lexeme the wrong approach? If so how do I handle parsing the separate bindings later without newline information?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4?d=identicon&amp;version=1"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#211358237" name="211358237"><div>2020-09-26 12:38:39</div></a></div><div class="text"><p>As you have noted, your problem here is that <code>space1</code> (and hence <code>sc</code>) also consumes newlines, as they are considered just another form of whitespace. Luckily, that’s easy enough to fix: you just need to change <code>space1</code> to <code>hspace1</code> (another predefined parser which doesn’t accept newlines). To parse a newline, you can just add <code>Newline &lt;$ eol</code> at the appropriate place in your lexer.</p>
<p>(And also, by the way, the usual approach with megaparsec is to combine lexing and parsing into one step. megaparsec still has support for two stages of lexing+parsing, but it’s usually easier to use one step instead.)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211358854" name="211358854"><div>2020-09-26 12:56:31</div></a></div><div class="text"><p>That's actually kind of what I had. Couple of things:</p>
<p>I was trying to use <code>hspace1</code>, but I'm getting variable not found, even though I'm on megaparsec 8.0.0, and importing Text.Megaparsec.Char unqualified:</p>
<div class="codehilite"><pre><span></span><code>&gt; stack ls dependencies|grep mega                                                                                                                1s 511ms
megaparsec 8.0.0
</code></pre></div>


<p>Not sure what's going on there...?</p>
<p>As a workaround, I tried defining</p>
<div class="codehilite"><pre><span></span><code>isHSpace :: Char -&gt; Bool
isHSpace x = isSpace x &amp;&amp; x /= &#39;\n&#39; &amp;&amp; x /= &#39;\r&#39;

hspace1 = void $ some (satisfy isHSpace)
</code></pre></div>


<p>But I was getting "unexpected newline".</p>
<p>Let me change it back, and replicate the error...</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211359034" name="211359034"><div>2020-09-26 13:00:15</div></a></div><div class="text"><p>Oh wait, it works this time. Not sure what I did differently. Thanks!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211359040" name="211359040"><div>2020-09-26 13:00:49</div></a></div><div class="text"><p>Still very confused that I can't access the predefined hspace1 from megaparsec</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950?d=identicon&amp;version=1"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#211359126" name="211359126"><div>2020-09-26 13:02:33</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="251123">James Sully</span> <a href="#narrow/stream/201385-Haskell/topic/Megaparsec.20basics/near/211359040">said</a>:</p>
<blockquote>
<p>Still very confused that I can't access the predefined hspace1 from megaparsec</p>
</blockquote>
<p><code>hspace1</code> is defined in 9.0.0, I can't find it in 8.0.0 in hackage - <a href="https://hackage.haskell.org/package/megaparsec-8.0.0">https://hackage.haskell.org/package/megaparsec-8.0.0</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211359201" name="211359201"><div>2020-09-26 13:04:38</div></a></div><div class="text"><p>Ah, I didn't realize I was looking at the 9.0.0 docs. I think there's a typo, the 9.0.0 docs <a href="https://hackage.haskell.org/package/megaparsec-9.0.0/docs/Text-Megaparsec-Char.html#v:hspace1">say it existed since 8.0.0</a>:</p>
<div class="codehilite"><pre><span></span><code>hspace1 :: (MonadParsec e s m, Token s ~ Char) =&gt; m ()Source#

Like space1, but does not accept newlines and carriage returns.

Since: 8.0.0
</code></pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211359202" name="211359202"><div>2020-09-26 13:04:44</div></a></div><div class="text"><p>Thanks!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211359383" name="211359383"><div>2020-09-26 13:09:42</div></a></div><div class="text"><p><span class="user-mention" data-user-id="269918">@bradrn</span> thanks for the advice re parsing and lexing simultaneously, I'll play around with that</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4?d=identicon&amp;version=1"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#211359766" name="211359766"><div>2020-09-26 13:20:14</div></a></div><div class="text"><p>You’re welcome for the advice! (And sorry for recommending a function from 9.0.0; I hadn’t realised <code>hspace1</code> was new).</p>
<p>For parsing and lexing simultaneously, the basic idea is to define your parsers directly in terms of your lexers, rather than indirectly in terms of your lexeme data type. For instance, instead of defining <code>parseEquality = Equality &lt;$&gt; satisfy isName &lt;* single Equals &lt;*&gt; satisfy isLiteral</code>, say, you might instead define <code>parseEquality = Equality &lt;$&gt; parseName &lt;* symbol "=" &lt;*&gt; parseLiteral</code>, with <code>parseName :: Parser String</code> rather than <code>parseName :: Parser Lexeme</code>. (Admittedly I’m not completely sure how that would work with significant newlines — I’d say that manually adding <code>(eol &lt;|&gt; eof)</code> parsers at the appropriate places might work, so something like <code>parseEquality = Equality &lt;$&gt; satisfy isName &lt;* single Equals &lt;*&gt; satisfy isLiteral &lt;* (eol &lt;|&gt; eof)</code>, but maybe just try it and see what works.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211361580" name="211361580"><div>2020-09-26 14:04:07</div></a></div><div class="text"><p>Here's what I have at the moment, seems to be working ok:</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4?d=identicon&amp;version=1"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#211361604" name="211361604"><div>2020-09-26 14:04:43</div></a></div><div class="text"><p>I can’t see the code…</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211361607" name="211361607"><div>2020-09-26 14:05:02</div></a></div><div class="text"><div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">module</span> <span class="nn">Lib</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Text</span> <span class="k">as</span> <span class="n">T</span>
<span class="kr">import</span>           <span class="nn">Data.Text</span> <span class="p">(</span><span class="kt">Text</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">M</span>
<span class="kr">import</span>           <span class="nn">Data.Map</span> <span class="p">(</span><span class="kt">Map</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Text.Megaparsec</span>
<span class="kr">import</span>           <span class="nn">Text.Megaparsec.Char</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Text.Megaparsec.Char.Lexer</span> <span class="k">as</span> <span class="n">L</span>
<span class="kr">import</span> <span class="nn">Data.Void</span>
<span class="kr">import</span>           <span class="nn">Data.Char</span> <span class="p">(</span><span class="nf">isSpace</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">void</span><span class="p">)</span>


<span class="kr">type</span> <span class="kt">Parser</span> <span class="ow">=</span> <span class="kt">Parsec</span> <span class="kt">Void</span> <span class="kt">Text</span>

<span class="kr">type</span> <span class="kt">Args</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Text</span><span class="p">]</span>

<span class="kr">type</span> <span class="kt">Ctx</span> <span class="ow">=</span> <span class="kt">Map</span> <span class="kt">Text</span> <span class="kt">Expr</span>

<span class="kr">data</span> <span class="kt">Expr</span> <span class="ow">=</span> <span class="kt">Lit</span> <span class="kt">Int</span>
          <span class="c1">-- | Lam Args Expr</span>
          <span class="o">|</span> <span class="kt">Var</span> <span class="kt">Text</span>
          <span class="o">|</span> <span class="kt">Plus</span> <span class="kt">Expr</span> <span class="kt">Expr</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Binding</span> <span class="ow">=</span> <span class="kt">Binding</span> <span class="kt">Text</span> <span class="kt">Expr</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">RuntimeErr</span> <span class="ow">=</span> <span class="kt">NameNotDefined</span> <span class="kt">Text</span>
                <span class="o">|</span> <span class="kt">MainNotFound</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="nf">eval</span> <span class="ow">::</span> <span class="kt">Ctx</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">RuntimeErr</span> <span class="kt">Int</span>
<span class="nf">eval</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="nf">\</span><span class="kr">case</span>
  <span class="kt">Lit</span> <span class="n">i</span>  <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="n">i</span>
  <span class="kt">Var</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="n">n</span> <span class="n">ctx</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="n">expr</span> <span class="ow">-&gt;</span> <span class="n">eval'</span> <span class="n">expr</span>
    <span class="kt">Nothing</span>   <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="o">$</span> <span class="kt">NameNotDefined</span> <span class="n">n</span>
  <span class="kt">Plus</span> <span class="n">e1</span> <span class="n">e2</span>  <span class="ow">-&gt;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">eval'</span> <span class="n">e1</span> <span class="o">&lt;*&gt;</span> <span class="n">eval'</span> <span class="n">e2</span>
  <span class="kr">where</span>
    <span class="n">eval'</span> <span class="ow">=</span> <span class="n">eval</span> <span class="n">ctx</span>

<span class="nf">executeProg</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Binding</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">RuntimeErr</span> <span class="kt">Int</span>
<span class="nf">executeProg</span> <span class="n">bs</span> <span class="ow">=</span> <span class="kr">case</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="s">"main"</span> <span class="n">ctx</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="n">mainExpr</span> <span class="ow">-&gt;</span> <span class="n">eval</span> <span class="n">ctx</span> <span class="n">mainExpr</span>
    <span class="kt">Nothing</span>       <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="kt">MainNotFound</span>
  <span class="kr">where</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="kt">M</span><span class="o">.</span><span class="n">fromList</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kt">Binding</span> <span class="n">name</span> <span class="n">expr</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="p">))</span> <span class="n">bs</span>

<span class="nf">expr</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">choice</span>
    <span class="p">[</span> <span class="kt">Lit</span> <span class="o">&lt;$&gt;</span> <span class="n">integer</span>
    <span class="p">,</span> <span class="kt">Var</span> <span class="o">&lt;$&gt;</span> <span class="n">name</span>
    <span class="p">,</span> <span class="kt">Plus</span> <span class="o">&lt;$&gt;</span> <span class="n">expr</span> <span class="o">&lt;*&gt;</span> <span class="n">expr</span>
    <span class="p">]</span>

<span class="kr">data</span> <span class="kt">LangToken</span> <span class="ow">=</span> <span class="kt">Name</span> <span class="kt">Text</span>
               <span class="o">|</span> <span class="kt">TokLit</span> <span class="kt">Int</span>
               <span class="o">|</span> <span class="kt">Equals</span>
               <span class="o">|</span> <span class="kt">RightArrow</span>
               <span class="o">|</span> <span class="kt">NewLine</span>

               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="nf">isHSpace</span> <span class="ow">::</span> <span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isHSpace</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">isSpace</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">/=</span> <span class="kt">'\</span><span class="n">n'</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">/=</span> <span class="kt">'\</span><span class="n">r'</span>

<span class="nf">hspace1</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">some</span> <span class="p">(</span><span class="n">satisfy</span> <span class="n">isHSpace</span><span class="p">)</span>


<span class="c1">-- space consumer</span>
<span class="nf">sc</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="nb">()</span>
<span class="nf">sc</span> <span class="ow">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">space</span> <span class="n">hspace1</span>
             <span class="n">empty</span>
             <span class="n">empty</span>


<span class="c1">-- vertical space consumer</span>
<span class="nf">vsc</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="nb">()</span>
<span class="nf">vsc</span> <span class="ow">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">space</span> <span class="n">space1</span>
              <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="n">skipLineComment</span> <span class="s">"--"</span><span class="p">)</span>
              <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="n">skipBlockComment</span> <span class="s">"{-"</span> <span class="s">"-}"</span><span class="p">)</span>


<span class="nf">lexeme</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>
<span class="nf">lexeme</span> <span class="ow">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">lexeme</span> <span class="n">sc</span>

<span class="nf">symbol</span> <span class="ow">::</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">Parser</span> <span class="kt">Text</span>
<span class="nf">symbol</span> <span class="ow">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">symbol</span> <span class="n">sc</span>

<span class="nf">rightArrow</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LangToken</span>
<span class="nf">rightArrow</span> <span class="ow">=</span> <span class="kt">RightArrow</span> <span class="o">&lt;$</span> <span class="n">symbol</span> <span class="s">"-&gt;"</span>

<span class="nf">integer</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">Int</span>
<span class="nf">integer</span> <span class="ow">=</span> <span class="n">lexeme</span> <span class="o">$</span> <span class="kt">L</span><span class="o">.</span><span class="n">decimal</span>

<span class="nf">equals</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LangToken</span>
<span class="nf">equals</span> <span class="ow">=</span> <span class="kt">Equals</span> <span class="o">&lt;$</span> <span class="n">symbol</span> <span class="s">"="</span>

<span class="nf">name</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">Text</span>
<span class="nf">name</span> <span class="ow">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">&lt;$&gt;</span> <span class="n">lexeme</span>
  <span class="p">((</span><span class="kt">:</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">letterChar</span> <span class="o">&lt;*&gt;</span> <span class="n">many</span> <span class="n">alphaNumChar</span> <span class="o">&lt;?&gt;</span> <span class="s">"name"</span><span class="p">)</span>

<span class="nf">binding</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">Binding</span>
<span class="nf">binding</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">n</span> <span class="ow">&lt;-</span> <span class="n">name</span>
  <span class="n">equals</span>
  <span class="n">i</span> <span class="ow">&lt;-</span> <span class="n">integer</span> <span class="c1">--todo</span>
  <span class="n">eol</span>
  <span class="n">sc</span>
  <span class="n">pure</span> <span class="o">$</span> <span class="kt">Binding</span> <span class="n">n</span> <span class="p">(</span><span class="kt">Lit</span> <span class="n">i</span><span class="p">)</span>

<span class="nf">nl</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LangToken</span>
<span class="nf">nl</span> <span class="ow">=</span> <span class="kt">NewLine</span> <span class="o">&lt;$</span> <span class="n">eol</span>

<span class="c1">-- langToken :: Parser LangToken</span>
<span class="c1">-- langToken = choice</span>
<span class="c1">--   [ name</span>
<span class="c1">--   , integer</span>
<span class="c1">--   , equals</span>
<span class="c1">--   , rightArrow</span>
<span class="c1">--   , nl</span>
<span class="c1">--   ]</span>

<span class="nf">program</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="p">[</span><span class="kt">Binding</span><span class="p">]</span>
<span class="nf">program</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">bindings</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="o">$</span> <span class="n">vsc</span> <span class="o">&gt;&gt;</span> <span class="n">binding</span>
  <span class="n">eof</span>
  <span class="n">pure</span> <span class="n">bindings</span>
</code></pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211361624" name="211361624"><div>2020-09-26 14:05:31</div></a></div><div class="text"><p>very much a wip, but it's passing my very simple tests</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211361632" name="211361632"><div>2020-09-26 14:06:00</div></a></div><div class="text"><p>Next thing is to suss out lambdas I think</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211361674" name="211361674"><div>2020-09-26 14:06:09</div></a></div><div class="text"><p>But for now I need to go to bed</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211361686" name="211361686"><div>2020-09-26 14:06:58</div></a></div><div class="text"><p>Lotta vestiges in there still, sorry</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4?d=identicon&amp;version=1"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#211361756" name="211361756"><div>2020-09-26 14:08:42</div></a></div><div class="text"><p>Yep, that looks good to me as well. (Though I’m not sure what <code>LangToken</code> is for… I assume that’s one of the ‘vestiges’.)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211361762" name="211361762"><div>2020-09-26 14:09:03</div></a></div><div class="text"><p>yeah, yep.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2?d=identicon&amp;version=1"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#211361772" name="211361772"><div>2020-09-26 14:09:21</div></a></div><div class="text"><p>I just implemented <code>expr</code> after seeing your advice</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>