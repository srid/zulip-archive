<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="@TheMatten Ah, I just noticed Inst isn&#39;t actually parametrized by the type variables of the class" name="description"><link href="https://funprog.srid.ca/haskell/first-class-instances.html" rel="canonical"><meta property="og:title" content="First class instances - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2020-11-14T18:44:23Z"><meta property="og:article:published_time" content="2020-02-05T23:29:05Z"><title>First class instances - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">First class instances - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">First class instances</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#187506201" name="187506201"><div>2020-02-05 23:29:05</div></a></div><div class="text"><p><span class="user-mention" data-user-id="225127">@TheMatten</span> Ah, I just noticed <code>Inst</code> isn't actually parametrized by the type variables of the class</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#187507133" name="187507133"><div>2020-02-05 23:43:07</div></a></div><div class="text"><p>Dope:</p>
<div class="codehilite"><pre><span></span>type f ~&gt; g = forall x. f x -&gt; g x

data f ~⋅~&gt; g = MMorph
  { convert :: Inst (Monad f) -&gt; Inst (Monad g)
  , nat :: f ~&gt; g
  }

mapTeletype :: (f ~⋅~&gt; g) -&gt; Inst (Teletype f) -&gt; Inst (Teletype g)
mapTeletype (MMorph { convert, nat }) (Teletype m r w) = Teletype (convert m) (nat r) (nat . w)
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#187510567" name="187510567"><div>2020-02-06 00:41:39</div></a></div><div class="text"><p>lol</p>
<div class="codehilite"><pre><span></span>ezmonad :: forall m. (forall a b. m a -&gt; (a -&gt; m b) -&gt; m b) -&gt; (forall a. a -&gt; m a) -&gt; Inst (Monad m)
ezmonad (&gt;&gt;=) pure = Monad applicative (&gt;&gt;=) (*&gt;) pure error
  where
  (&lt;$&gt;) :: (a -&gt; b) -&gt; m a -&gt; m b
  (&lt;$&gt;) f ma = ma &gt;&gt;= (pure . f)

  ($&gt;) :: b -&gt; m a -&gt; m b
  ($&gt;) = (&lt;$&gt;) . const

  functor :: Inst (Functor m)
  functor = Functor (&lt;$&gt;) ($&gt;)

  (&lt;*&gt;) :: m (a -&gt; b) -&gt; m a -&gt; m b
  (&lt;*&gt;) mab ma = mab &gt;&gt;= \ab -&gt; ma &gt;&gt;= \a -&gt; pure $ ab a

  liftA2 :: (a -&gt; b -&gt; c) -&gt; m a -&gt; m b -&gt; m c
  liftA2 abc fa fb = abc &lt;$&gt; fa &lt;*&gt; fb

  (*&gt;) :: m a -&gt; m b -&gt; m b
  (*&gt;) ma mb = (flip const) &lt;$&gt; ma &lt;*&gt; mb

  (&lt;*) :: m a -&gt; m b -&gt; m a
  (&lt;*) ma mb = const &lt;$&gt; ma &lt;*&gt; mb

  applicative :: Inst (Applicative m)
  applicative = Applicative functor pure (&lt;*&gt;) liftA2 (*&gt;) (&lt;*)
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#187512425" name="187512425"><div>2020-02-06 01:20:53</div></a></div><div class="text"><div class="codehilite"><pre><span></span>type f ~&gt; g = forall x. f x -&gt; g x

data f ~⋅~&gt; g = MMorph
  { convert :: Inst (Monad f) -&gt; Inst (Monad g)
  , nat :: Monad f =&gt; f ~&gt; g
  }

class Monad m =&gt; Teletype m where
  read  :: m String
  write :: String -&gt; m ()

mkInst &#39;&#39;Teletype

mapTeletype :: (f ~⋅~&gt; g) -&gt; Inst (Teletype f) -&gt; Inst (Teletype g)
mapTeletype (MMorph { convert, nat }) t@(Teletype m r w) = t ==&gt; Teletype (convert m) (nat r) (nat . w)

newtype ReaderT r m a = ReaderT { runReaderT :: r -&gt; m a }

monadReaderT :: forall r m. Inst (Monad m) -&gt; Inst (Monad (ReaderT r m))
monadReaderT m = m ==&gt; ezmonad (&gt;&gt;=′) pure&#39;
  where
  (&gt;&gt;=′) :: Monad m =&gt; (::&gt;&gt;=) (ReaderT r m)
  (ReaderT ma) &gt;&gt;=′ ((runReaderT .) -&gt; amb) = ReaderT $ \r -&gt; ma r &gt;&gt;= ($ r) . amb

  pure&#39; :: Monad m =&gt; Pure (ReaderT r m)
  pure&#39; = ReaderT . pure . pure

liftReaderT :: m ~⋅~&gt; ReaderT r m
liftReaderT = MMorph monadReaderT (ReaderT . pure)

newtype StateT s m a = StateT { runStateT :: s -&gt; m (a, s) }

monadStateT :: forall s m. Inst (Monad m) -&gt; Inst (Monad (StateT s m))
monadStateT m = m ==&gt; ezmonad (&gt;&gt;=′) pure&#39;
  where
  (&gt;&gt;=′) :: Monad m =&gt; (::&gt;&gt;=) (StateT s m)
  (StateT ma) &gt;&gt;=′ ((runStateT .) -&gt; amb) = StateT $ \s -&gt; ma s &gt;&gt;= \(a, s&#39;) -&gt; amb a s&#39;

  pure&#39; :: Monad m =&gt; Pure (StateT s m)
  pure&#39; a = StateT $ \s -&gt; pure (a, s)

liftStateT :: m ~⋅~&gt; StateT s m
liftStateT = MMorph monadStateT (\ma -&gt; StateT $ \s -&gt; (, s) &lt;$&gt; ma)

test :: Inst (Teletype f) -&gt; Inst (Teletype (ReaderT r (StateT s f)))
test = mapTeletype liftReaderT . mapTeletype liftStateT
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#187512429" name="187512429"><div>2020-02-06 01:20:56</div></a></div><div class="text"><p>typeclasses rekt forever</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#216468075" name="216468075"><div>2020-11-12 13:36:48</div></a></div><div class="text"><p>Thinking about this library, way typeclasses work in Haskell and experiences like <a href="https://stackoverflow.com/a/25880674">https://stackoverflow.com/a/25880674</a>, maybe the solution that would allow for best of both worlds would be something along the lines of:</p>
<ul>
<li>keeping instance creation to the compiler - that is, no (endorsed/safe) way of reifying instances at random places</li>
<li>unifying <code>Constraint</code> and <code>Type</code> - not only we would allow classes to be treated as datatypes, but we would additionally allow users to treat them as normal records, thus removing need for boilerplate needed to make interface usable both implicitly and explicitly (namespacing of newly introduced fields could be solved once <a href="https://github.com/ghc-proposals/ghc-proposals/pull/283"><code>LocalModules</code></a> get implemented)</li>
<li>providing (already proposed) syntax for creating instances from values:</li>
</ul>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">instance</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">bar</span>
</code></pre></div>
<p>which allows users to reuse and generate interfaces in convenient way (avoiding tricks with <code>DerivingVia</code> and stuff), while still keeping everything coherent</p>
<p>When it comes to use-cases like multiple instances of numerical interfaces, in presence of functionality above, I would propose simple solution - <code>RecordWildCards</code>:<br>
One could create class that provides needed operations:</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="kr">class</span> <span class="kt">Group</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">unit</span> <span class="ow">::</span> <span class="n">a</span>
  <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
  <span class="n">inverse</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</code></pre></div>
<p>implement clashing instances as named values</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="nf">sumRational</span><span class="p">,</span> <span class="n">prodRational</span> <span class="ow">::</span> <span class="kt">Group</span> <span class="kt">Rational</span>
<span class="nf">sumRational</span> <span class="ow">=</span> <span class="kt">Group</span><span class="p">{</span>
    <span class="n">unit</span> <span class="ow">=</span> <span class="mi">0</span>
  <span class="p">,</span> <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span>
  <span class="p">,</span> <span class="n">inverse</span> <span class="ow">=</span> <span class="n">negate</span>
  <span class="p">}</span>
<span class="nf">prodRational</span> <span class="ow">=</span> <span class="kt">Group</span><span class="p">{</span>
    <span class="n">unit</span> <span class="ow">=</span> <span class="mi">1</span>
  <span class="p">,</span> <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
  <span class="p">,</span> <span class="n">inverse</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre></div>
<p>and "open" them in scope where needed</p>
<div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="nf">foo</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">&lt;&gt;</span> <span class="mi">2</span> <span class="kr">where</span> <span class="kt">Group</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="n">prodRational</span>
</code></pre></div>
<p>If wanted interface contains more methods than class provides, one could use solution that's already used for this purpose with normal values - <code>PatternSynonyms</code></p>
<div class="message_embed"><a class="message_embed_image" href="https://stackoverflow.com/a/25880674" style="background-image: url(https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded)"></a><div class="data-container"><div class="message_embed_title"><a href="https://stackoverflow.com/a/25880674" title="Are typeclasses essential?">Are typeclasses essential?</a></div><div class="message_embed_description">I once asked a question on haskell beginners, whether to use data/newtype or a typeclass. In my particular case it turned out that no typeclass was required. Additionally Tom Ellis gave me a brilli...</div></div></div><div class="message_embed"><a class="message_embed_image" href="https://github.com/ghc-proposals/ghc-proposals/pull/283" style="background-image: url(https://avatars0.githubusercontent.com/u/20374637?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/ghc-proposals/ghc-proposals/pull/283" title="Local modules by goldfirere · Pull Request #283 · ghc-proposals/ghc-proposals">Local modules by goldfirere · Pull Request #283 · ghc-proposals/ghc-proposals</a></div><div class="message_embed_description">This is an alternative to #205 that appears to be more compositional.
Rendered</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/bd1c2dd9ab5e95cae3e7a38c2f373739e5a1acba?version=2"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#216468673" name="216468673"><div>2020-11-12 13:41:54</div></a></div><div class="text"><p>this is also very similar to what agda does</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#216468848" name="216468848"><div>2020-11-12 13:43:09</div></a></div><div class="text"><p>Technically, it wouldn't even make much sense to keep <code>instance</code>s restricted to <code>class</code>es in that case - we could just as well allow <code>instance</code>s of any datatype as long as they follow normal restrictions</p>
<p><span class="user-mention" data-user-id="254032">@Georgi Lyubenov // googleson78</span> that's where</p>
<blockquote>
<p>"open"</p>
</blockquote>
<p>comes from <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/bd1c2dd9ab5e95cae3e7a38c2f373739e5a1acba?version=2"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#216469096" name="216469096"><div>2020-11-12 13:44:52</div></a></div><div class="text"><p>if you make a proposal now, maybe my (potential) grandchildren could benefit from it!<br>
<span aria-label="sob" class="emoji emoji-1f62d" role="img" title="sob">:sob:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#216473915" name="216473915"><div>2020-11-12 14:21:02</div></a></div><div class="text"><p>Pinging <span class="user-mention" data-user-id="225136">@Asad Saeeduddin</span>, because you have bunch of experience with passing dictionaries around, not only in Haskell <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/bd1c2dd9ab5e95cae3e7a38c2f373739e5a1acba?version=2"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#216743160" name="216743160"><div>2020-11-14 18:37:54</div></a></div><div class="text"><p><a href="https://github.com/ghc-proposals/ghc-proposals/pull/378">https://github.com/ghc-proposals/ghc-proposals/pull/378</a><br>
maybe I was a bit too pessimistic? <span class="user-mention" data-user-id="225127">@TheMatten</span></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/ghc-proposals/ghc-proposals/pull/378" style="background-image: url(https://avatars0.githubusercontent.com/u/20374637?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/ghc-proposals/ghc-proposals/pull/378" title="Support ergonomic dependent types by goldfirere · Pull Request #378 · ghc-proposals/ghc-proposals">Support ergonomic dependent types by goldfirere · Pull Request #378 · ghc-proposals/ghc-proposals</a></div><div class="message_embed_description">This proposal describes the tension between two important criteria the committee (and broader community) have implicitly been using to evaluate new features. In several proposals (#270, #281, and #...</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#216743479" name="216743479"><div>2020-11-14 18:43:14</div></a></div><div class="text"><p>@rae's thesis was literally about Dependent types in Haskell, and he's paid to work on GHC, so I guess it's just a matter of few years maximum <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/bd1c2dd9ab5e95cae3e7a38c2f373739e5a1acba?version=2"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#216743553" name="216743553"><div>2020-11-14 18:44:23</div></a></div><div class="text"><p>I was referencing more the fact that ghc hq might actually shift into "more drastic changes" mode</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>