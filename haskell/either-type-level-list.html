<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="Using Either as a type operator makes the signature more palatable for nested Eithers:
parse :: String -&gt; Foo `Either` Bar `Either` Baz
parse = undefined



But writing Right (Left bar) is pretty janky. Can that be improved as well?" name="description"><link href="https://funprog.srid.ca/haskell/either-type-level-list.html" rel="canonical"><meta property="og:title" content="Either type-level list - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2020-04-25T17:25:42Z"><meta property="og:article:published_time" content="2020-04-25T04:05:42Z"><meta property="og:image" content="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"><title>Either type-level list - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">Either type-level list - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">Either type-level list</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195266644" name="195266644"><div>2020-04-25 04:05:42</div></a></div><div class="text"><p>Using Either as a type operator makes the signature more palatable for nested Eithers:</p>
<div class="codehilite"><pre><span></span><span class="nf">parse</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Foo</span> <span class="p">`</span><span class="kt">Either</span><span class="p">`</span> <span class="kt">Bar</span> <span class="p">`</span><span class="kt">Either</span><span class="p">`</span> <span class="kt">Baz</span>
<span class="nf">parse</span> <span class="ow">=</span> <span class="n">undefined</span>
</pre></div>


<p>But writing <code>Right (Left bar)</code> is pretty janky. Can that be improved as well?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195267010" name="195267010"><div>2020-04-25 04:16:21</div></a></div><div class="text"><div class="codehilite"><pre><span></span><span class="kr">class</span> <span class="kt">Way</span> <span class="n">v</span> <span class="n">e</span> <span class="kr">where</span>
  <span class="n">this</span> <span class="ow">::</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="n">e</span>

<span class="kr">instance</span> <span class="kt">Way</span> <span class="n">a</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="kt">Either</span><span class="p">`</span> <span class="n">b</span> <span class="p">`</span><span class="kt">Either</span><span class="p">`</span> <span class="n">c</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">this</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="o">.</span> <span class="kt">Left</span>

<span class="kr">instance</span> <span class="kt">Way</span> <span class="n">b</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="kt">Either</span><span class="p">`</span> <span class="n">b</span> <span class="p">`</span><span class="kt">Either</span><span class="p">`</span> <span class="n">c</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">this</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="o">.</span> <span class="kt">Right</span>

<span class="kr">instance</span> <span class="kt">Way</span> <span class="n">c</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="kt">Either</span><span class="p">`</span> <span class="n">b</span> <span class="p">`</span><span class="kt">Either</span><span class="p">`</span> <span class="n">c</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">this</span> <span class="ow">=</span> <span class="kt">Right</span>

<span class="nf">parse</span> <span class="ow">::</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">Foo</span> <span class="p">`</span><span class="kt">Either</span><span class="p">`</span> <span class="kt">Bar</span> <span class="p">`</span><span class="kt">Either</span><span class="p">`</span> <span class="kt">Baz</span>
<span class="nf">parse</span> <span class="ow">=</span> <span class="n">this</span> <span class="p">(</span><span class="n">undefined</span> <span class="ow">::</span> <span class="kt">Bar</span><span class="p">)</span>
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195267083" name="195267083"><div>2020-04-25 04:18:10</div></a></div><div class="text"><p>Now can we do that in _reverse_? i.e., pattern match on the either values?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#195267854" name="195267854"><div>2020-04-25 04:40:53</div></a></div><div class="text"><p><span class="user-mention" data-user-id="251311">@Sridhar Ratnakumar</span> idk if you want to go this far, but take a look at: <a href="https://github.com/masaeedu/co-optics/blob/master/src/SOP/EOT.hs" title="https://github.com/masaeedu/co-optics/blob/master/src/SOP/EOT.hs">https://github.com/masaeedu/co-optics/blob/master/src/SOP/EOT.hs</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/masaeedu/co-optics/blob/master/src/SOP/EOT.hs" style="background-image: url(https://avatars3.githubusercontent.com/u/3674056?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/masaeedu/co-optics/blob/master/src/SOP/EOT.hs" title="masaeedu/co-optics">masaeedu/co-optics</a></div><div class="message_embed_description">Two optics for the price of one. Contribute to masaeedu/co-optics development by creating an account on GitHub.</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#195267925" name="195267925"><div>2020-04-25 04:42:11</div></a></div><div class="text"><p>this lets you write stuff like:</p>
<div class="codehilite"><pre><span></span><span class="kr">data</span> <span class="kt">Value</span> <span class="ow">=</span> <span class="kt">N</span> <span class="kt">Number</span> <span class="o">|</span> <span class="kt">S</span> <span class="kt">String</span> <span class="o">|</span> <span class="kt">B</span> <span class="kt">Bool</span> <span class="o">|</span> <span class="kt">Null</span> <span class="o">|</span> <span class="kt">O</span> <span class="kt">Object</span> <span class="o">|</span> <span class="kt">A</span> <span class="kt">Array</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
<span class="kr">instance</span> <span class="kt">SOP</span><span class="o">.</span><span class="kt">Generic</span> <span class="kt">Value</span>

<span class="c1">-- Parse/print a JSON value (without leading/trailing whitespace)</span>
<span class="nf">jsonValue</span> <span class="ow">::</span> <span class="kt">Biparser&#39;</span> <span class="kt">Maybe</span> <span class="kt">Value</span>
<span class="nf">jsonValue</span> <span class="ow">=</span> <span class="n">gsop</span> <span class="o">$</span>
  <span class="n">jsonNumber</span> <span class="o">\/</span>
  <span class="n">jsonString</span> <span class="o">\/</span>
  <span class="n">jsonBool</span>   <span class="o">\/</span>
  <span class="n">jsonNull</span>   <span class="o">\/</span>
  <span class="n">jsonObject</span> <span class="o">\/</span>
  <span class="n">jsonArray</span>
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#195268144" name="195268144"><div>2020-04-25 04:50:34</div></a></div><div class="text"><p>where <code>(\/) :: Demux p =&gt; p a b -&gt; p c d -&gt; p (Either a c) (Either b d)</code>. assuming your parsers are functors instead of profunctors, you'll be building up nested eithers via the analogous <code>Alternative</code> class, which has <code>union :: Alternative f =&gt; f a -&gt; f b -&gt; f (Either a b)</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?x=x&amp;version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#195275449" name="195275449"><div>2020-04-25 08:52:10</div></a></div><div class="text"><p>Data types á la carte (<a href="http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf" title="http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf">http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf</a>, section 4) describes <code>:&lt;:</code> constraint capturing "subtype" relation</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195290385" name="195290385"><div>2020-04-25 15:51:32</div></a></div><div class="text"><p><span class="user-mention" data-user-id="225136">@Asad Saeeduddin</span> But you still have to create a wrapper ADT (<code>Value</code> in your case), no?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195290399" name="195290399"><div>2020-04-25 15:51:56</div></a></div><div class="text"><p><span class="user-mention" data-user-id="225127">@TheMatten</span> Interesting, but why does it need to be a functor? In my case they could be any types. I came up with this:</p>
<div class="codehilite"><pre><span></span><span class="kr">type</span> <span class="p">(</span><span class="kt">:+:</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Either</span>

<span class="kr">instance</span> <span class="n">a</span> <span class="kt">:&lt;:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:+:</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">inj</span> <span class="ow">=</span> <span class="kt">Left</span>

<span class="kr">instance</span> <span class="n">b</span> <span class="kt">:&lt;:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:+:</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">inj</span> <span class="ow">=</span> <span class="kt">Right</span>

<span class="kr">instance</span> <span class="cm">{-# OVERLAPPABLE #-}</span> <span class="n">a</span> <span class="kt">:&lt;:</span> <span class="n">c</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="kt">:&lt;:</span> <span class="p">(</span><span class="n">c</span> <span class="kt">:+:</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">inj</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="o">.</span> <span class="n">inj</span>

<span class="nf">x</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="kt">:+:</span> <span class="kt">String</span> <span class="kt">:+:</span> <span class="kt">Char</span> <span class="kt">:+:</span> <span class="kt">Text</span>
<span class="nf">x</span> <span class="ow">=</span> <span class="n">inj</span> <span class="p">(</span><span class="s">&quot;hello&quot;</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">)</span>
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195290461" name="195290461"><div>2020-04-25 15:52:56</div></a></div><div class="text"><p>This supports arbitrarily nested Either, compared to the <code>Way</code> class above, which is nice.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195290645" name="195290645"><div>2020-04-25 15:57:28</div></a></div><div class="text"><p>Wait, can <code>Polysemy.Internal.Union</code> be used here?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195290653" name="195290653"><div>2020-04-25 15:57:52</div></a></div><div class="text"><p>But it is not general enough. Uses <code>Effect</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195291415" name="195291415"><div>2020-04-25 16:15:56</div></a></div><div class="text"><p>And here's the pattern matching part. </p>
<div class="codehilite"><pre><span></span><span class="kr">type</span> <span class="p">(</span><span class="kt">:+:</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Either</span>

<span class="kr">instance</span> <span class="n">a</span> <span class="kt">:&lt;:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:+:</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">inj</span> <span class="ow">=</span> <span class="kt">Left</span>
  <span class="n">pick</span> <span class="ow">=</span> <span class="n">either</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">const</span> <span class="kt">Nothing</span><span class="p">)</span>

<span class="kr">instance</span> <span class="n">b</span> <span class="kt">:&lt;:</span> <span class="p">(</span><span class="n">a</span> <span class="kt">:+:</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">inj</span> <span class="ow">=</span> <span class="kt">Right</span>
  <span class="n">pick</span> <span class="ow">=</span> <span class="n">either</span> <span class="p">(</span><span class="n">const</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="kt">Just</span>

<span class="kr">instance</span> <span class="cm">{-# OVERLAPPABLE #-}</span> <span class="n">a</span> <span class="kt">:&lt;:</span> <span class="n">c</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="kt">:&lt;:</span> <span class="p">(</span><span class="n">c</span> <span class="kt">:+:</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">inj</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="o">.</span> <span class="n">inj</span>
  <span class="n">pick</span> <span class="ow">=</span> <span class="n">either</span> <span class="n">pick</span> <span class="p">(</span><span class="n">const</span> <span class="kt">Nothing</span><span class="p">)</span>

<span class="nf">pattern</span> <span class="kt">Member</span> <span class="p">{</span><span class="n">thing</span><span class="p">}</span> <span class="ow">&lt;-</span>
  <span class="p">(</span><span class="n">pick</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="n">thing</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="kt">Member</span> <span class="ow">=</span> <span class="n">inj</span>

<span class="nf">mkStuff</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="kt">:+:</span> <span class="kt">String</span> <span class="kt">:+:</span> <span class="kt">Char</span> <span class="kt">:+:</span> <span class="kt">Text</span>
<span class="nf">mkStuff</span> <span class="ow">=</span> <span class="kt">Member</span> <span class="p">(</span><span class="s">&quot;hello&quot;</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">)</span>

<span class="nf">useStuff</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="kt">:+:</span> <span class="kt">String</span> <span class="kt">:+:</span> <span class="kt">Char</span> <span class="kt">:+:</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">useStuff</span> <span class="ow">=</span> <span class="nf">\</span><span class="kr">case</span>
  <span class="kt">Member</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">s</span>
  <span class="kt">Member</span> <span class="p">(</span><span class="n">n</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">show</span> <span class="n">n</span>
  <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="ne">error</span> <span class="s">&quot;No string&quot;</span>
</pre></div>


<p>Very nice!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#195291463" name="195291463"><div>2020-04-25 16:16:18</div></a></div><div class="text"><p><span class="user-mention" data-user-id="251311">@Sridhar Ratnakumar</span> The ADT isn't a wrapper, it's the end result I'm trying to get. The point is I can have a nested type level tree of tuples and eithers, and as long as its shape conforms to some generic datatype, i can just use a standard isomorphism <code>gsop</code> to convert it, without having to manually fiddle with all the lefts and rights and <code>fst</code>s and <code>snd</code>s</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195291716" name="195291716"><div>2020-04-25 16:23:40</div></a></div><div class="text"><p>Not sure if it is possible to write a <code>COMPLETE</code> pragma for polymorphic pattern synonyms though ...</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195292187" name="195292187"><div>2020-04-25 16:35:31</div></a></div><div class="text"><p>Yea, it seems impossible to write a <code>COMPLETE</code> pragma for the <code>Member</code> pattern. Sheesh</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195292211" name="195292211"><div>2020-04-25 16:35:57</div></a></div><div class="text"><p>Thought I was getting close to arriving at a simple solution for the open union problem.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195292268" name="195292268"><div>2020-04-25 16:36:29</div></a></div><div class="text"><p>I can suppress the warning with <code>{-# COMPLETE Member :: Either #-}</code> though, but that's not ideal of course.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195292528" name="195292528"><div>2020-04-25 16:43:53</div></a></div><div class="text"><p>Asked for help here: <a href="https://discourse.haskell.org/t/writing-complete-pragma-for-polymorphic-pattern-synonyms/1198" title="https://discourse.haskell.org/t/writing-complete-pragma-for-polymorphic-pattern-synonyms/1198">https://discourse.haskell.org/t/writing-complete-pragma-for-polymorphic-pattern-synonyms/1198</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://discourse.haskell.org/t/writing-complete-pragma-for-polymorphic-pattern-synonyms/1198" style="background-image: url(https://discourse.haskell.org/uploads/default/original/1X/89166504e40f4869ea825dd70048017861ec8578.png)"></a><div class="data-container"><div class="message_embed_title"><a href="https://discourse.haskell.org/t/writing-complete-pragma-for-polymorphic-pattern-synonyms/1198" title="Writing COMPLETE pragma for polymorphic pattern synonyms">Writing COMPLETE pragma for polymorphic pattern synonyms</a></div><div class="message_embed_description">I have arrived at this approach of making handling of nested Either's more elegant; it uses pattern synonyms to allow case'ing directly on the inner Either values.  type (:+:) = Either  instance a :&lt;: (a :+: b) where   inj = Left   pick = either Just (const Nothing)  instance b :&lt;: (a :+: b) where   inj = Right   pick = either (const Nothing) Just  instance {-# OVERLAPPABLE #-} a :&lt;: c =&gt; a :&lt;: (c :+: b) where   inj = Left . inj   pick = either pick (const Nothing)  pattern Member :: x :&lt;: c =&gt; ...</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#195294324" name="195294324"><div>2020-04-25 17:25:42</div></a></div><div class="text"><p>fffuuuuuu <a href="https://ghc-devs.haskell.narkive.com/NXBBDXg1/suppressing-false-incomplete-pattern-matching-warnings-for-polymorphic-pattern-synonyms" title="https://ghc-devs.haskell.narkive.com/NXBBDXg1/suppressing-false-incomplete-pattern-matching-warnings-for-polymorphic-pattern-synonyms">https://ghc-devs.haskell.narkive.com/NXBBDXg1/suppressing-false-incomplete-pattern-matching-warnings-for-polymorphic-pattern-synonyms</a></p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>