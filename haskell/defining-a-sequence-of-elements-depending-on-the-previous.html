<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="Hi,
there is a classic programming exercice in C++ : transposing a matrix inplace for matrix stored in a linear fashion.
It&#39;s trivial for square matrix, but for non square matrix, you have a non trivial permutation of elements and then it&#39;s natural to determine the cycle which makes the permutation " name="description"><link href="https://funprog.srid.ca/haskell/defining-a-sequence-of-elements-depending-on-the-previous.html" rel="canonical"><meta property="og:title" content="Defining a sequence  of elements depending on the previous ? - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2021-11-22T23:46:47Z"><meta property="og:article:published_time" content="2021-10-12T21:19:39Z"><title>Defining a sequence  of elements depending on the previous ? - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">Defining a sequence  of elements depending on the previous ? - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">Defining a sequence  of elements depending on the previous ?</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/e844be7cf589bf69bd17fc26cc4b4e95"></a><div class="content"><a class="author">Vincent L</a><div class="metadata"><a href="#257273869" name="257273869"><div>2021-10-12 21:19:39</div></a></div><div class="text"><p>Hi,<br>
there is a classic programming exercice in C++ : transposing a matrix inplace for matrix stored in a linear fashion.<br>
It's trivial for square matrix, but for non square matrix, you have a non trivial permutation of elements and then it's natural to determine the cycle which makes the permutation (see <a href="https://en.wikipedia.org/wiki/In-place_matrix_transposition">https://en.wikipedia.org/wiki/In-place_matrix_transposition</a>).</p>
<p>I wonder if it's possible to compute this cycle in a lazy way in a one liner in Haskell ? Basically the idea is that linear index <code>i</code> is moved to linear index <code>j</code> based on the shape of the matrix, and then <code>j</code>is moved to <code>k</code> and so on... basically the value of the next index is depending only on the previous one. If you have the function that turns an element to the next one, is there an elegant way to build a sequence out of it ?  I suppose it could be done via a fold but it would be much nicer with a the same kind of trick with lazy evaluation + zipwith for factorial and fibonacci sequence.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/b450c754c95e372799d56cb7eef2eba2"></a><div class="content"><a class="author">James Sully</a><div class="metadata"><a href="#262393741" name="262393741"><div>2021-11-22 23:46:47</div></a></div><div class="text"><p>I don't really understand the details of the matrix stuff, but it sounds like you might be after <a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Prelude.html#v:iterate">iterate</a>, or more generally <a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-List.html#v:unfoldr">unfold</a></p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>