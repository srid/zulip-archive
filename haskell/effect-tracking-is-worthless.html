<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="https://degoes.net/articles/no-effect-tracking

It’s my contention that effect tracking is worthless precisely because if a developer has any idea about what a function is intended to do, then they already know with a high degree of certainty whether or not the function performs side-effects

https:" name="description"><link href="https://funprog.srid.ca/haskell/effect-tracking-is-worthless.html" rel="canonical"><meta property="og:title" content="&quot;Effect tracking is worthless&quot; - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2020-06-04T06:26:31Z"><meta property="og:article:published_time" content="2020-05-24T19:20:42Z"><title>&quot;Effect tracking is worthless&quot; - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">&quot;Effect tracking is worthless&quot; - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">&quot;Effect tracking is worthless&quot;</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/7c6c8647784cae80af5f575103af4c7e"></a><div class="content"><a class="author">Chris Wendt</a><div class="metadata"><a href="#198596066" name="198596066"><div>2020-05-24 19:20:42</div></a></div><div class="text"><p><a href="https://degoes.net/articles/no-effect-tracking">https://degoes.net/articles/no-effect-tracking</a></p>
<blockquote>
<p>It’s my contention that effect tracking is worthless precisely because if a developer has any idea about what a function is intended to do, then they already know with a high degree of certainty whether or not the function performs side-effects</p>
</blockquote>
<p><a href="https://twitter.com/jdegoes/status/1257022839443554312">https://twitter.com/jdegoes/status/1257022839443554312</a></p>
<div class="inline-preview-twitter"><div class="twitter-tweet"><a href="https://twitter.com/jdegoes/status/1257022839443554312"><img class="twitter-avatar" src="https://pbs.twimg.com/profile_images/1257444017543020547/2fSCJ2ha_normal.jpg"></a><p>Just blogged, 'Effect Tracking Is Commercially Worthless', in which I introduce…

<span aria-label="boom" class="emoji emoji-1f4a5" role="img" title="boom">:boom:</span>Tagless-Final Effect-Tracked Java™<span aria-label="boom" class="emoji emoji-1f4a5" role="img" title="boom">:boom:</span>

…and thoroughly reject use of 'IO' to track purity in functional code. <span aria-label="scream" class="emoji emoji-1f631" role="img" title="scream">:scream:</span><span aria-label="smiling devil" class="emoji emoji-1f608" role="img" title="smiling devil">:smiling_devil:</span>

Get it while it's hot! <span aria-label="point down" class="emoji emoji-1f447" role="img" title="point down">:point_down:</span>

#scala #haskell #zio #fp

<a href="https://t.co/WCPQj6URfb">https://degoes.net/articles/no-effect-tracking</a></p><span>- John A De Goes (@jdegoes)</span></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#198600078" name="198600078"><div>2020-05-24 21:02:53</div></a></div><div class="text"><p>If the premise is that "effects are not about tracking side-effects", then I sorta agree - just <code>IO</code> by itself isn't that helpful if all the code you write is inside of it and effects being just "tags" wouldn't be that useful either - but effect systems aren't really about "tagging side-effects", they're more about clean composition of state/control flow, restriction of effects in specific contexts and sort of "parametrization" over implementation similar to dependency injection - that's sort of what author is saying about ZIO. Reason why multiple current solutions in Haskell are not really beginner-friendly and have their own problems is simply that these goals are <em>hard</em> to achieve and what "impure" languages basically do is that they "sweep them under the rug" by using one, big, shared "context". And as your program grows, interactions between different parts of code in this shared environment may become less and less clear...</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#198600154" name="198600154"><div>2020-05-24 21:05:24</div></a></div><div class="text"><p>Question is - if global shared state is fine, why do we care so much about encapsulation, separation of concerns or DI? What if we had model that not only let's us use convention to achieve them, but can <em>prove</em> that they hold and so some classes of bugs can't occur?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#198601259" name="198601259"><div>2020-05-24 21:33:57</div></a></div><div class="text"><p>I don't get what the goal is in that article, sounds just like a string of conflated semantics and terminology</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#198602779" name="198602779"><div>2020-05-24 22:15:01</div></a></div><div class="text"><p>I agree this post is not very concise</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#198643233" name="198643233"><div>2020-05-25 07:56:34</div></a></div><div class="text"><blockquote>
<p>So effect tracking—the ability to “track effects” in the type system—is a gigantic misnomer, because the IO type does not track side-effects.</p>
</blockquote>
<p>Isn't "effect tracking" a term invented in the blog post itself?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#198690698" name="198690698"><div>2020-05-25 17:57:25</div></a></div><div class="text"><p>I don't really understand this article. The premise establishes that "effect tracking," is a problem we're wasting time on and the conclusion claims "effect tracking" is a misnomer. It also claims that the interesting and valid research being done in this area by both academics and industry users is... a myth?</p>
<p>There is much said about <code>IO</code> but... aren't algebraic effects about interpreters and free(r) monads? I thought the whole point of algebraic effects was that I could write a function that is polymorphic over some monad so long as it gives me the expected operations.</p>
<p>I think the commercial viability argument is even weaker. "Java would have implemented them by now," is a reductionist argument if I ever heard one. The worst thing you can say about the "commercial viability" of algebraic effects is that there's not enough data to say one way or another if they make developers more productive or reduce errors. Which isn't saying much. We also don't have enough data to know if static type systems have a statistically significant effect on error rates in software... even unit testing, a common practice, has very little evidence for this.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#198691503" name="198691503"><div>2020-05-25 18:09:54</div></a></div><div class="text"><p>I read that one reason for his getting banned from typelevel was that he kept on debating nonsensical problems in github issues</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/c42af76c243b56f44f94c7640bb1735d"></a><div class="content"><a class="author">Dooodle</a><div class="metadata"><a href="#198794654" name="198794654"><div>2020-05-26 17:27:34</div></a></div><div class="text"><p>ґїззщшгнекуцй</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#198862713" name="198862713"><div>2020-05-27 08:24:46</div></a></div><div class="text"><p>I find this to be relevant: <a href="https://github.com/thma/PolysemyCleanArchitecture#readme">https://github.com/thma/PolysemyCleanArchitecture#readme</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/thma/PolysemyCleanArchitecture#readme" style="background-image: url(https://avatars3.githubusercontent.com/u/11872995?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/thma/PolysemyCleanArchitecture#readme" title="thma/PolysemyCleanArchitecture">thma/PolysemyCleanArchitecture</a></div><div class="message_embed_description">Showcasing how the Polysemy library can be used to implement a REST application conforming to the guidelines of the Clean Architecture model. - thma/PolysemyCleanArchitecture</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#198866777" name="198866777"><div>2020-05-27 09:06:48</div></a></div><div class="text"><p>That's an awesome showcase</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#198866923" name="198866923"><div>2020-05-27 09:08:34</div></a></div><div class="text"><p>I have something not so well structured but I think is worth to share </p>
<p><a href="https://github.com/bolt12/generic-crud">https://github.com/bolt12/generic-crud</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bolt12/generic-crud" style="background-image: url(https://avatars3.githubusercontent.com/u/20261421?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bolt12/generic-crud" title="bolt12/generic-crud">bolt12/generic-crud</a></div><div class="message_embed_description">Generic CRUD REST server with Servant, Beam and Polysemy - bolt12/generic-crud</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/7c6c8647784cae80af5f575103af4c7e"></a><div class="content"><a class="author">Chris Wendt</a><div class="metadata"><a href="#198882584" name="198882584"><div>2020-05-27 12:18:46</div></a></div><div class="text"><p>Looking past the distractions (the tongue-in-cheek sales rhetoric, the conspicuous advertisement for his ZIO project, and the vacuous is-Haskell-really-pure debate), there are some compelling arguments against enforcing purity that I've never heard before. The novelty of the counterarguments has drawn my attention to studying this subject further.</p>
<p>Just to clarify, by "enforcing purity" I'm referring to modeling effects in the type system. The term is intended to be contrasted with languages that allow side-effects in functions and how programmers still write pure functions in them because purity has value in those languages, too (e.g. <code>function plus5(x) { return x + 5; }</code> in JavaScript).</p>
<p>As an aside, I don't think John is saying that the dependency-injection-like property of effects systems is worthless, but rather that any restriction-of-side-effects property (just like <code>IO</code> has) is worthless.</p>
<p><strong>Original motivation for <code>IO</code> in Haskell:</strong> ensure that expressions that describe interactions with the world are evaluated in a deterministic order (specified by the programmer) even under lazy evaluation and in the presence of an optimizing compiler, while maintaining purity. Paper for reference: <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/1993/01/imperative.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/1993/01/imperative.pdf</a></p>
<p><strong>Mechanism by which <code>IO</code> enforces purity:</strong> the <code>IO</code> data type is essentially the state monad where the world is the state <code>data IO a = IO (World -&gt; (a, World))</code> and the <code>&gt;&gt;=</code>+<code>return</code> interface exposed to the programmer only enables chaining <code>IO</code> values together such that each value of type <code>World</code> is used exactly once, passing it from one <code>IO</code> action to the next in sequence. In other words, each function that takes a <code>World</code> (e.g. <code>getLine :: IO String</code>, <code>getLine :: World -&gt; (String, World)</code>) is never called with the same <code>World</code> value twice. All function calls that interact with the world take a different <code>World</code> value, and therefore it's impossible to observe the same function applied to the same arguments return a different value. That's precisely the definition of referential transparency, A.K.A. purity.</p>
<p><strong>Motivation for enforcing purity:</strong> I found less information on this topic, so I'm mostly going off of intuition here.</p>
<ul>
<li>STM is guaranteed to be correct</li>
<li>Equational reasoning always holds (i.e. factoring out common code into a binding never changes program behavior)</li>
<li>The type of a function documents whether or not it interacts with the world</li>
<li>Programs tend to be written in such a way that interactions with the world are more separated from logic than they would be without enforced purity</li>
<li>There's a pervasive undercurrent of "it's good for you" in a "slavery is freedom" sort of way</li>
<li>It's the only lazy+pure language and a lot of learning has come out of programming with that mind-bending combination of properties (myself included)</li>
</ul>
<p><strong>Motivation for not enforcing purity:</strong> Starting with John's reasons, with a few I thought of:</p>
<ul>
<li>If it were worthwhile, annotation processors would be in widespread use for mainstream languages and have IDE support (proof by contradiction)</li>
<li>Tooling alone using static call tree analysis would achieve the same goal without placing a burden on the programmer</li>
<li>The Checker framework has no commercial traction <a href="https://checkerframework.org/manual/#purity-checker">https://checkerframework.org/manual/#purity-checker</a></li>
<li>PureScript went from pure+tags to pure (still enforces purity, but with less granularity)</li>
<li>Almost every other aspect of FP has been widely adopted while enforced purity has not: first-class and anonymous functions (e.g. in Java 8), lexical scoping (e.g. arrow functions for <code>this</code> and <code>let</code> vs <code>var</code> in JavaScript), immutable annotations (e.g. <code>const</code> vs <code>let</code> in JavaScript), option chaining (e.g. C#'s and TypeScript's <code>?.</code> operator), the <code>Maybe</code> data type (e.g. <code>Optional</code> in Java), parser combinators, QuickCheck, STM, list comprehensions, pattern matching, parametric polymorphism (A.K.A. generics), type inference, the list goes on...</li>
<li>Programmers already know using intuition with a high degree of certainty whether or not a function interacts with the world. Functions that violations that intuition are avoided and are quickly rectified or worked around (e.g. <code>java.net.URL#hashCode/equals</code> <a href="https://news.ycombinator.com/item?id=21765788">https://news.ycombinator.com/item?id=21765788</a></li>
<li>Enforcing purity places burdens of boilerplate and ceremony on programmers (e.g. when to use <code>let</code> vs <code>&lt;-</code>, doing acrobatics with <code>&lt;$&gt;</code>/<code>fmap</code>/<code>=&lt;&lt;</code>/<code>&gt;&gt;=</code>/<code>&lt;*&gt;</code>/etc. to satisfy the type checker, need to add an import of <code>Debug.Trace</code> and use special functions to be able to inspect the execution of functions that definitely don't interact with the world, need to create a new variable binding for many trivial values such as <code>count &lt;- readIORef countRef</code>)</li>
<li>Telling beginners "don't worry, you don't need to understand what <code>IO</code> is or how it works, just use these combinators you won't understand for the first 20 hours of learning Haskell" is Haskell's equivalent of "oh just ignore all that public static void main String[] args stuff for now and don't forget to wrap you hello world in a class"</li>
<li>I can't remember ever accidentally running IO at all or in the wrong order in any language (not just Haskell). It just doesn't seem to happen. I've been bitten by mutation quite a few times, but they were always a conscious choice of tradeoffs or something silly like JavaScript's <code>array.reverse()</code> which both mutates the array and returns a reversed shallow copy.</li>
</ul></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/7c6c8647784cae80af5f575103af4c7e"></a><div class="content"><a class="author">Chris Wendt</a><div class="metadata"><a href="#198883690" name="198883690"><div>2020-05-27 12:31:42</div></a></div><div class="text"><p>I'm considering modifying the Haskell backend of CodeWyng (commercial project I'm working on <a href="http://codewyng.io/">http://codewyng.io/</a>) to use <code>LANGUAGE Strict</code> and insert <code>unsafePerformIO</code> in a bunch of places, especially usages of <code>IORef</code>s and <code>MVar</code>s to see 1) if it works 2) if there are any bugs 3) if it's easier or more intuitive to program that way. Will post back here if/when I do.</p>
<div class="message_embed"><a class="message_embed_image" href="http://codewyng.io/" style="background-image: url(https://storage.googleapis.com/codewyng-public/icon-128.png)"></a><div class="data-container"><div class="message_embed_title"><a href="http://codewyng.io/" title="CodeWyng browser extension">CodeWyng browser extension</a></div><div class="message_embed_description">Browser extension for GitHub: fast hover documentation, go-to-definition, and find-references</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/b10e5343a097452b2b3f411febc67e282658af76?version=2"></a><div class="content"><a class="author">Matt Peddie</a><div class="metadata"><a href="#198884390" name="198884390"><div>2020-05-27 12:39:03</div></a></div><div class="text"><p>I'm having trouble following the argument that anything that hasn't been widely adopted by mainstream languages can't be commercially valuable.  does that mean that lambdas only became commercially valuable once C++, Java etc. adopted them, and they had no value in the '80s?   was the <code>Maybe</code> monad only valuable once C# introduced option chaining?  and so on with the other features in the list.  maybe purity will never be valuable, but maybe nobody has figured out the right way to introduce it to mainstream languages yet?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/b10e5343a097452b2b3f411febc67e282658af76?version=2"></a><div class="content"><a class="author">Matt Peddie</a><div class="metadata"><a href="#198884546" name="198884546"><div>2020-05-27 12:40:40</div></a></div><div class="text"><p>I don't know much about OCaml, but maybe the fact that people programming in an impure language sometimes use monads and have syntax extensions for do-notation suggests that purity and modelling your effects does have value in some situations</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#198889606" name="198889606"><div>2020-05-27 13:26:40</div></a></div><div class="text"><p><span class="user-mention" data-user-id="294416">@Chris Wendt</span> interesting, I didn't think anything in the post was particularly new. The usual argument I am familiar with is: </p>
<p>"OK, we accept that pure functions are useful. However, I can still have pure functions in JavaScript. But in Haskell the tracking/enforcing in the type system has such a high cost in terms of understanding (how to deal with all the ways things get weird). Is it really worth it? What value does that provide?"</p>
<p>There are a myriad answers to this, but I think the one that is most compelling to me personally, after having learned how to do it, it is really a nice way to program. Experientially it is a handy practice. And once you know how to work with IO, for example, the burden to deal with it is not high.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/31b0847ae161d8af30e1a2fcb059be4d"></a><div class="content"><a class="author">Hazem</a><div class="metadata"><a href="#198890984" name="198890984"><div>2020-05-27 13:38:49</div></a></div><div class="text"><blockquote>
<p>I'm considering modifying the Haskell backend of CodeWyng (commercial project I'm working on <a href="http://codewyng.io/">http://codewyng.io/</a>) to use LANGUAGE Strict and insert unsafePerformIO in a bunch of places, especially usages of IORefs and MVars to see 1) if it works 2) if there are any bugs 3) if it's easier or more intuitive to program that way. Will post back here if/when I do.</p>
</blockquote>
<p><span class="user-mention" data-user-id="294416">@Chris Wendt</span>  I'd love to see the follow up post if you end up following this plan! Also, I have a (possibly stupid) question:<br>
Would <code>LANGUAGE Strict</code> be required for the whole code base or only restricted to modules that perform IO?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#198891412" name="198891412"><div>2020-05-27 13:41:35</div></a></div><div class="text"><p>something I've noticed, in langs without effect tracking, if you do try to enforce pure/impure divide, the impure code grows and grows, becoming a mix of effect logic and what could be pure logic that is handy in the effect functions.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#198895074" name="198895074"><div>2020-05-27 14:05:48</div></a></div><div class="text"><p><span class="user-mention" data-user-id="252949">@Joel McCracken</span>  it's worth noting that this is also easily possible with Haskell - you end up with "IO blobs" where most of your code lives in IO (e.g. while "prototyping")<br>
the benefit for me here is that when you want to actually "purify" your functions, it takes no effort to see where you're doing IO, whereas without the IO tag you would need to make a conscious choice while initially writing your IO blob to somehow document which parts are impure (or invest the effort later to check <strong>everything</strong> manually)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#198895253" name="198895253"><div>2020-05-27 14:07:01</div></a></div><div class="text"><p>yeah so it def happens, but whats nice is that you have to factor it out if you want to use that logic in a pure context</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#198895414" name="198895414"><div>2020-05-27 14:08:09</div></a></div><div class="text"><p>that is, if you say "oh ive already done this", finding it in an IO function, you can't just extract that little portion as a separate funciton on IO becuse that limits you to only use  in IO functions</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#198895458" name="198895458"><div>2020-05-27 14:08:27</div></a></div><div class="text"><p>I've been bitten by impure IO in languages that don't have that concept. Multithreaded code in C++ is an absolute nightmare unless someone was smart enough to use monoids and enforce immutability... and be really, really careful.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#198895465" name="198895465"><div>2020-05-27 14:08:30</div></a></div><div class="text"><p>and yeah what you're saying is <span aria-label="100" class="emoji emoji-1f4af" role="img" title="100">:100:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#198895763" name="198895763"><div>2020-05-27 14:10:20</div></a></div><div class="text"><p>isn't the scenario the article is advocating more like "what if Polysemy but using <code>unsafePerformIO</code> in the interpreters"?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#198895917" name="198895917"><div>2020-05-27 14:11:33</div></a></div><div class="text"><p>in every impure language code base I have ever worked, I always feel the need to read every line of code basically for every function I need to call, and then transitiviely read every line of the functions called... because things are too ambiguous and its way too easy to throw IO in the middle of something</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#198896047" name="198896047"><div>2020-05-27 14:12:23</div></a></div><div class="text"><p>Like, tell me, <code>reservation.reserveTickets(10)</code>, do you think this does IO?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#198896122" name="198896122"><div>2020-05-27 14:12:45</div></a></div><div class="text"><p>absolutely</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#198896166" name="198896166"><div>2020-05-27 14:13:01</div></a></div><div class="text"><p>i agree, but is it clear one way or the other?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#198896210" name="198896210"><div>2020-05-27 14:13:15</div></a></div><div class="text"><p>how do you know its not implemented purely?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#198896242" name="198896242"><div>2020-05-27 14:13:30</div></a></div><div class="text"><p>the "I know intuitively which function performs IO" does not hold for transitivity</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#198896257" name="198896257"><div>2020-05-27 14:13:36</div></a></div><div class="text"><p>yeah</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#198896433" name="198896433"><div>2020-05-27 14:14:28</div></a></div><div class="text"><p>I think the claim is that if you wrap every IO action with a (polysemy) effect constructor, <code>IO</code> becomes pointless</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#198896706" name="198896706"><div>2020-05-27 14:15:57</div></a></div><div class="text"><p>it feels like this should be easily contradictable, maybe <span class="user-mention" data-user-id="254034">@Love Waern (King of the Homeless)</span> can make a sound argument</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#198896866" name="198896866"><div>2020-05-27 14:16:43</div></a></div><div class="text"><p>a naive argument would be "then <code>Sem</code> replaces <code>IO</code>"</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#198897008" name="198897008"><div>2020-05-27 14:17:38</div></a></div><div class="text"><p>but since everything gets optimized away when compiling, would everything just come crashing down?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#198897454" name="198897454"><div>2020-05-27 14:19:59</div></a></div><div class="text"><p>if everything gets inlined away, yeah the <code>unsafePerformIO</code>s would indeed be a problem (as is the usual problem with inlining <code>unsafePerformIO</code>s encountered when wanting to have a global <code>MVar</code> for example)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#198919340" name="198919340"><div>2020-05-27 16:47:40</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="294416">Chris Wendt</span> <a href="#narrow/stream/201385-Haskell/topic/.22Effect.20tracking.20is.20worthless.22/near/198883690">said</a>:</p>
<blockquote>
<p>I'm considering modifying the Haskell backend of CodeWyng (commercial project I'm working on <a href="http://codewyng.io/">http://codewyng.io/</a>) to use <code>LANGUAGE Strict</code> and insert <code>unsafePerformIO</code> in a bunch of places, especially usages of <code>IORef</code>s and <code>MVar</code>s to see 1) if it works 2) if there are any bugs 3) if it's easier or more intuitive to program that way. Will post back here if/when I do.</p>
</blockquote>
<p>Oh, CodeWyng is interesting. What sort of GitHub API do you use for this if you don't mind me asking?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#198924118" name="198924118"><div>2020-05-27 17:23:21</div></a></div><div class="text"><p><span class="user-mention" data-user-id="294416">@Chris Wendt</span> Good analysis, I think you should make this into a blog post or something</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#198924478" name="198924478"><div>2020-05-27 17:26:22</div></a></div><div class="text"><p>One thing I didn't see mentioned is that restrictions like purity make mathematically modeling the language a tractable problem. The less a language can do, the more connections there are to logic/category theory/algebra/etc. Of course this doesn't mean we can't do things like state modification etc. at all, it just means we need to maintain some kind of boundary between what is "within" the language (and hence must be accounted for by a mathematical model) and what is "without".</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#198925057" name="198925057"><div>2020-05-27 17:31:24</div></a></div><div class="text"><p>Purity is just one restriction of this kind btw. For example it may seem tedious and annoying to lose the ability to arbitrarily duplicate or discard values in our language (at least without some kind of explicit effect demarcating code that does this from the language itself). But what we lose in power _in_ the language, we gain in power _on_ the language, in that there are many optimizations that are sound for a linearly typed program but not for one that creates or destroys values willy nilly.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#198925118" name="198925118"><div>2020-05-27 17:32:00</div></a></div><div class="text"><p>Tractable and sufficiently easy for practicing programmers. Even C and Javascript have been formally modelled but it takes significantly more effort to do.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#198925497" name="198925497"><div>2020-05-27 17:35:13</div></a></div><div class="text"><p>tl;dr: <a href="https://www.youtube.com/watch?v=GqmsQeSzMdw">YouTube - Constraints Liberate, Liberties Constrain — Runar Bjarnason</a></p>
<div class="youtube-video message_inline_image"><a data-id="GqmsQeSzMdw" href="https://www.youtube.com/watch?v=GqmsQeSzMdw"><img src="https://i.ytimg.com/vi/GqmsQeSzMdw/default.jpg"></a></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/7c6c8647784cae80af5f575103af4c7e"></a><div class="content"><a class="author">Chris Wendt</a><div class="metadata"><a href="#198938258" name="198938258"><div>2020-05-27 19:12:46</div></a></div><div class="text"><p>I included some insights from the discussion here and posted <a href="https://chrismwendt.github.io/blog/2020/05/27/the-cost-of-enforcing-purity-in-haskell.html">https://chrismwendt.github.io/blog/2020/05/27/the-cost-of-enforcing-purity-in-haskell.html</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#198942554" name="198942554"><div>2020-05-27 19:42:57</div></a></div><div class="text"><p><span class="user-mention" data-user-id="294416">@Chris Wendt</span> Zulip link doesn't render correctly. By the way, you may want to link to <a href="https://funprog.srid.ca/haskell/effect-tracking-is-worthless.html">https://funprog.srid.ca/haskell/effect-tracking-is-worthless.html</a> instead as it doedsn't require login to view messages.</p>
<div class="message_embed"><a class="message_embed_image" href="https://funprog.srid.ca/haskell/effect-tracking-is-worthless.html" style="background-image: url(https://secure.gravatar.com/avatar/7c6c8647784cae80af5f575103af4c7e?d=identicon&amp;version=1)"></a><div class="data-container"><div class="message_embed_title"><a href="https://funprog.srid.ca/haskell/effect-tracking-is-worthless.html" title="&quot;Effect tracking is worthless&quot; - Haskell">"Effect tracking is worthless" - Haskell</a></div><div class="message_embed_description">https://degoes.net/articles/no-effect-tracking

It’s my contention that effect tracking is worthless precisely because if a developer has any idea about what a function is intended to do, then they already know with a high degree of certainty whether or not the function performs side-effects

https:</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/7c6c8647784cae80af5f575103af4c7e"></a><div class="content"><a class="author">Chris Wendt</a><div class="metadata"><a href="#198942658" name="198942658"><div>2020-05-27 19:43:53</div></a></div><div class="text"><p>Thanks, fixed the link, it's live now</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/7c6c8647784cae80af5f575103af4c7e"></a><div class="content"><a class="author">Chris Wendt</a><div class="metadata"><a href="#199124520" name="199124520"><div>2020-05-29 08:04:48</div></a></div><div class="text"><p>I completed my experiment with <code>LANGUAGE Strict</code> and <code>unsafePerformIO</code> on my commercial project CodeWyng:</p>
<ul>
<li>Adding <code>{-# LANGUAGE Strict #-}</code> worked right away, I didn't notice any bugs</li>
<li>While replacing <code>IO</code> functions with impure non-<code>IO</code> versions, I replaced <code>withMVar</code> with an impure version and doing so caused an infinite loop, so I reverted that one</li>
<li>I found some dead code that was doing the equivalent of <code>x &lt;- readMVar xVar</code></li>
<li>Inlining variables into pure expressions helped align the code and prettify it</li>
<li>Some control functions like <code>unlessM</code> broke in unexpected ways</li>
<li>All I could think about for the last 25% was "man, all these tricks with <code>&gt;&gt;=</code>/<code>&lt;-</code>/<code>&lt;$&gt;</code>/<code>=&lt;&lt;</code> to retain purity are completely unnecessary"</li>
</ul>
<p>Added these notes to <a href="https://chrismwendt.github.io/blog/2020/05/27/the-cost-of-enforcing-purity-in-haskell.html">https://chrismwendt.github.io/blog/2020/05/27/the-cost-of-enforcing-purity-in-haskell.html</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#199128171" name="199128171"><div>2020-05-29 08:45:55</div></a></div><div class="text"><p>Honestly I'm worried this will break at some point - All <code>Strict</code> does is putting <code>BangPatterns</code> everywhere, so while it enforces strict evaluation, it language where bindings are not guaranteed to be evaluated in any specific order it may introduce some troubles<br>
Plus there's stuff like let-floating which can move bindings to completely different places AFAIK<br>
And all of the <code>base</code> is still lazy, so unless you switch to one compiled with <code>Strict</code> (that may possibly need some fixes too to work), you're going to have problems with standard functions/datatypes</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#199179872" name="199179872"><div>2020-05-29 16:42:20</div></a></div><div class="text"><p>Honestly, if you want to do haskell like that, I think it would be better to use Rust or OCaml</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#199190317" name="199190317"><div>2020-05-29 18:05:23</div></a></div><div class="text"><p><span class="user-mention" data-user-id="294416">@Chris Wendt</span> do you have any traversals in your codebase?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#199190380" name="199190380"><div>2020-05-29 18:05:47</div></a></div><div class="text"><p>over IO I mean</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/7c6c8647784cae80af5f575103af4c7e"></a><div class="content"><a class="author">Chris Wendt</a><div class="metadata"><a href="#199192873" name="199192873"><div>2020-05-29 18:25:23</div></a></div><div class="text"><p>Haskell definitely wasn't intended to be used like this, and it's not a huge pain point, so I'm not going to actually leave it strict and impure</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/7c6c8647784cae80af5f575103af4c7e"></a><div class="content"><a class="author">Chris Wendt</a><div class="metadata"><a href="#199192908" name="199192908"><div>2020-05-29 18:25:40</div></a></div><div class="text"><p>Not sure what you mean by traversals, I have a few <code>forM_</code>s and <code>sequence</code>s</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#199193456" name="199193456"><div>2020-05-29 18:30:32</div></a></div><div class="text"><p>Those are what I meant. Do those interact properly with <code>unsafePerformIO</code>?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/7c6c8647784cae80af5f575103af4c7e"></a><div class="content"><a class="author">Chris Wendt</a><div class="metadata"><a href="#199195307" name="199195307"><div>2020-05-29 18:44:50</div></a></div><div class="text"><p>Yes, as far as I could tell, I didn't notice a problem with them</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/074c66f0b64377e140623a34ed479409"></a><div class="content"><a class="author">Avi Dessauer</a><div class="metadata"><a href="#199219992" name="199219992"><div>2020-05-29 22:26:03</div></a></div><div class="text"><blockquote>
<p>Enforcing purity places burdens of boilerplate and ceremony on programmers (e.g. when to use let vs &lt;-, doing acrobatics with &lt;$&gt;/fmap/=&lt;&lt;/&gt;&gt;=/&lt;*&gt;/etc. to satisfy the type checker, need to add an import of Debug.Trace and use special functions to be able to inspect the execution of functions that definitely don’t interact with the world, need to create a new variable binding for many trivial values such as count &lt;- readIORef countRef)</p>
</blockquote>
<p>This is only the case because Haskell lacks a built-in algebraic effect system. Boiler plate is not fundamental to the design space (<a href="https://www.unisonweb.org/docs/abilities/">see Unison Abilities</a>).</p>
<p>The issue with giving up effect tracking is not just that it makes STM unsound, it also makes lazy data structures unintelligible (even in embedded in a strict language).</p>
<p>In fact the issue is even more general you lose everything that requires algebraic reasoning. All the good things listed about ZIO are only possible because of effect tracking. Look at Unison for example how could you distribute arbitrary effect full computations across multiple servers without fine-grained effects? To say effect tracking is commercially worthless, but ZIO is useful as the article does is a oxymoron.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#199220851" name="199220851"><div>2020-05-29 22:38:46</div></a></div><div class="text"><p><span class="user-mention" data-user-id="271930">@Avi Dessauer</span> does that mean that your assessment is that ZIO's "runtime" implements a similar mechanism as Haskell's <code>IO</code>?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/074c66f0b64377e140623a34ed479409"></a><div class="content"><a class="author">Avi Dessauer</a><div class="metadata"><a href="#199221237" name="199221237"><div>2020-05-29 22:43:05</div></a></div><div class="text"><p>The stronger the tracking the better libraries.<code>IO</code> is insufficient. I'm not assessing ZIO I'm describing why tacking is needed.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#199221603" name="199221603"><div>2020-05-29 22:47:22</div></a></div><div class="text"><p>I'm asking because the article claims that ZIO has the benefits you mentioned, but "without effect tracking". So since you said that that was unsound, I assume that ZIO must implement something that satisfies the same operational requirements.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#199221603" name="199221603"><div>2020-05-29 22:47:22</div></a></div><div class="text"><p>I'm asking because the article claims that ZIO has the benefits you mentioned, but "without effect tracking". So since you said that that was unsound, I assume that ZIO must implement something that satisfies the same operational requirements.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/074c66f0b64377e140623a34ed479409"></a><div class="content"><a class="author">Avi Dessauer</a><div class="metadata"><a href="#199225921" name="199225921"><div>2020-05-29 23:53:48</div></a></div><div class="text"><p>That's not my interpretation of the article.</p>
<p>ZIO is a effect system tacked on to Scala it's not as sound as it would be in Haskell or Unison, but it's an affect system.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/074c66f0b64377e140623a34ed479409"></a><div class="content"><a class="author">Avi Dessauer</a><div class="metadata"><a href="#199226020" name="199226020"><div>2020-05-29 23:54:48</div></a></div><div class="text"><p><a href="https://zio.dev/docs/overview/overview_creating_effects">https://zio.dev/docs/overview/overview_creating_effects</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/7c6c8647784cae80af5f575103af4c7e"></a><div class="content"><a class="author">Chris Wendt</a><div class="metadata"><a href="#199228968" name="199228968"><div>2020-05-30 00:45:36</div></a></div><div class="text"><p>It seems that the term "effect tracking" is ambiguous and causing us to talk past one another, so I propose we use these two terms instead:</p>
<ul>
<li><strong>Enforcing purity</strong> prevents the use of functions that interact with the world to be used in any context that doesn't allow it. The mechanism by which purity is enforced in Haskell is a combination of the type system (e.g. you can't use <code>IO Int</code> in a function like <code>sum :: [Int] -&gt; Int</code>) and the specific interface to <code>IO</code> exposed to the programmer (i.e. all functions that interact with the world return something wrapped in <code>IO</code> and there is no <code>IO a -&gt; a</code> to circumvent the intended interface, except for the backdoor <code>unsafePerformIO</code>).</li>
<li><strong>Dependency injection</strong> is a technique where the implementation of dependencies of a function can be changed at the call site. For example, the dependency on the database can be swapped out for a mock implementation in tests. Some mechanisms by which dependency injection can be performed include: passing an explicit argument <code>runApp :: DB -&gt; IO ()</code>, adding a type class constraint <code>runApp :: (HasDB m, MonadIO m) =&gt; m ()</code>, or mutating the global DB variable to set it to a mock implementation prior to running tests.</li>
</ul>
<p>Do these terms capture the meanings being used in this conversation?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/074c66f0b64377e140623a34ed479409"></a><div class="content"><a class="author">Avi Dessauer</a><div class="metadata"><a href="#199229641" name="199229641"><div>2020-05-30 00:57:52</div></a></div><div class="text"><p>Dependency injection is expressible as an instance of algebraic effects.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/074c66f0b64377e140623a34ed479409"></a><div class="content"><a class="author">Avi Dessauer</a><div class="metadata"><a href="#199229753" name="199229753"><div>2020-05-30 01:00:08</div></a></div><div class="text"><p>Enforcing purity is another instance of effects.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/074c66f0b64377e140623a34ed479409"></a><div class="content"><a class="author">Avi Dessauer</a><div class="metadata"><a href="#199231671" name="199231671"><div>2020-05-30 01:48:38</div></a></div><div class="text"><p>Type classes are a poor mechanism for expressing effects. This is why effects are difficult in Haskell. Type classes are great when you want coherence, but are not the right fit for effects. Languages like Unison and it's forbearer Frank have effect inference, which allows you not to write out all your constraints, improves error messages and makes tracking affects first class.</p>
<p>Enforcing purity is tracking affects. You tack a effect system on ala ZIO analogous to typescript or flow, you can build a affect system on GADTs, type classes, and monads, or you can use a single monads at a time (concretely transformers, or abstractly MTL).</p>
<p>All ZIO does is track the affects you care about in a nice-ish way. If you track only the effects that affect concurrency mutation and exceptions as the article argues, you lose the ability to care about more effects later. In a <em>strict language</em> you gain less boiler plate and the ability to still think imperatively. In a lazy language, you can't sequence effects without tracking.</p>
<p>But languages don't need to trade off fine grain tracking for ergonomics as Unison demonstrates.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#199252430" name="199252430"><div>2020-05-30 11:32:39</div></a></div><div class="text"><p>Unison abilities look dope <span aria-label="sunglasses" class="emoji emoji-1f60e" role="img" title="sunglasses">:sunglasses:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#199252436" name="199252436"><div>2020-05-30 11:33:03</div></a></div><div class="text"><p>I should look back into its progress again</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#199257665" name="199257665"><div>2020-05-30 13:47:55</div></a></div><div class="text"><p>I was just reading about that last night, they do look really interesting</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#199264517" name="199264517"><div>2020-05-30 16:27:31</div></a></div><div class="text"><p>they don't work very well</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#199264520" name="199264520"><div>2020-05-30 16:27:41</div></a></div><div class="text"><p>they suffer from all of the problems effect handlers do</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#199264561" name="199264561"><div>2020-05-30 16:28:10</div></a></div><div class="text"><p><a href="https://github.com/unisonweb/unison/issues/822">https://github.com/unisonweb/unison/issues/822</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/unisonweb/unison/issues/822" style="background-image: url(https://avatars1.githubusercontent.com/u/7087133?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/unisonweb/unison/issues/822" title="Ability system crashes with higher-order abilities · Issue #822 · unisonweb/unison">Ability system crashes with higher-order abilities · Issue #822 · unisonweb/unison</a></div><div class="message_embed_description">The following program defines two ability: State s and Error e. The Error e ability is row-polymorphic on the effects it can receive in its actions. use .base use .base.Either ability State s where...</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/074c66f0b64377e140623a34ed479409"></a><div class="content"><a class="author">Avi Dessauer</a><div class="metadata"><a href="#199265404" name="199265404"><div>2020-05-30 16:46:38</div></a></div><div class="text"><p><span class="user-mention" data-user-id="251120">@Sandy Maguire</span> that's very good to know.</p>
<p>Could eff's handler order independent approach be adopted by Unison?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/24b62e7b62bbbc0f4f0617b5ccd66e6f8fe784f6?version=2"></a><div class="content"><a class="author">tristanC</a><div class="metadata"><a href="#199273794" name="199273794"><div>2020-05-30 20:05:32</div></a></div><div class="text"><p>Following up on "examples of bug that could have been prevented using effect tracking", I could not find the example I referred to. It would be nice to get concrete examples of bug that could have been prevented with an effect tracking system. However, even if such system does not prevent bugs directly, it seems like very useful for code review where change to non-IO function would take less time to review.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/24b62e7b62bbbc0f4f0617b5ccd66e6f8fe784f6?version=2"></a><div class="content"><a class="author">tristanC</a><div class="metadata"><a href="#199274095" name="199274095"><div>2020-05-30 20:13:29</div></a></div><div class="text"><p>And from my limited understanding, anything that could improve code review is hardly worthless because code review can be tricky and very error prone on its own :-)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#199371538" name="199371538"><div>2020-06-01 13:51:40</div></a></div><div class="text"><p>I'd be interested in more retrospectives on effect systems. Semantic had a neat one. For my own projects I have tried converting some mtl code to capabilities but I haven't gotten very far with it yet.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#199380870" name="199380870"><div>2020-06-01 15:14:04</div></a></div><div class="text"><p>To follow up on the chat about effects at the video chat this last saturday, Semantic made a pretty interesting point about their use of Haskell and effect systems: <a href="https://github.com/github/semantic/blob/master/docs/why-haskell.md">https://github.com/github/semantic/blob/master/docs/why-haskell.md</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/github/semantic/blob/master/docs/why-haskell.md" style="background-image: url(https://avatars3.githubusercontent.com/u/9919?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/github/semantic/blob/master/docs/why-haskell.md" title="github/semantic">github/semantic</a></div><div class="message_embed_description">Parsing, analyzing, and comparing source code across many languages - github/semantic</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/ddb0de8a0ae419d9707a4e01ad986b2d"></a><div class="content"><a class="author">Vance Palacio</a><div class="metadata"><a href="#199381071" name="199381071"><div>2020-06-01 15:15:42</div></a></div><div class="text"><p>I'm also interested in seeing what types of bugs are reduced by effect tracking, and fine-grained effect tracking in particular.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/ddb0de8a0ae419d9707a4e01ad986b2d"></a><div class="content"><a class="author">Vance Palacio</a><div class="metadata"><a href="#199381960" name="199381960"><div>2020-06-01 15:20:57</div></a></div><div class="text"><blockquote>
<p>the fact that the Semantic Code team spends the majority of its time working on features rather than debugging production crashes is truly remarkable—and this can largely be attributed to our choice of language.</p>
</blockquote>
<p>This quote here is amazing. This is one of those selling points of Haskell that needs to be pointed out more often</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/ddb0de8a0ae419d9707a4e01ad986b2d"></a><div class="content"><a class="author">Vance Palacio</a><div class="metadata"><a href="#199382984" name="199382984"><div>2020-06-01 15:29:17</div></a></div><div class="text"><p>Lol the whole write up is amazing. That document needs to be pushed more often as a response to "Haskell has no killer applications"</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#199383085" name="199383085"><div>2020-06-01 15:30:02</div></a></div><div class="text"><p>I find myself referring to it a lot. I find parallels in my own adoption of Haskell as well.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#199422951" name="199422951"><div>2020-06-01 21:02:50</div></a></div><div class="text"><p>wrt: what bugs are reduced by effect tracking, i don't think that's the goal</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#199422986" name="199422986"><div>2020-06-01 21:03:04</div></a></div><div class="text"><p>the goal is that it forces you to think through your architecture much more than you would otherwise</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#199423016" name="199423016"><div>2020-06-01 21:03:19</div></a></div><div class="text"><p>you don't prevent bugs; you prevent unmaintainability</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#199424291" name="199424291"><div>2020-06-01 21:12:03</div></a></div><div class="text"><p>I use this same line of reasoning when explaining formal methods. <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#199503864" name="199503864"><div>2020-06-02 14:52:58</div></a></div><div class="text"><p>I also don't totally get why effect tracking being worthless is different from saying that type systems are worthless</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#199525329" name="199525329"><div>2020-06-02 17:25:31</div></a></div><div class="text"><p>Nice point, everything would be worthless if the human being never made mistakes and always remembered what he was thinking when he wrote that piece of code <span aria-label="stuck out tongue" class="emoji emoji-1f61d" role="img" title="stuck out tongue">:stuck_out_tongue:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#199526873" name="199526873"><div>2020-06-02 17:37:18</div></a></div><div class="text"><p>writing good code is commercially worthless, otherwise companies would have picked up on it</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#199533313" name="199533313"><div>2020-06-02 18:26:15</div></a></div><div class="text"><p>This assumes that companies in 2020 are all-knowing and perfectly wise</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#199540867" name="199540867"><div>2020-06-02 19:25:25</div></a></div><div class="text"><p>But anyway i think he is correct in so far as effect tracking is not directly worthy; it is valuable for its side effects however :P</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/2f4316c80f59f157d26cb515ed98026308998f44?version=2"></a><div class="content"><a class="author">Nick Scheel</a><div class="metadata"><a href="#199551039" name="199551039"><div>2020-06-02 20:46:20</div></a></div><div class="text"><p>As soon as you say “I’m okay with impure functions”, you’re choosing a default set of effects (such as mutability, I/O, and exceptions 😱) that are easiest to work with, and as a consequence, support for other effects either fall by the wayside (suddenly async effects have to be expressed differently, e.g. via callbacks or promises in JS, which then got syntactic sugar added for them) or they get subsumed by the default impure effects (e.g. state will often be tracked using mutability, even though that’s not always the best implementation, especially if you need backtracking, asynchronicity, or other effects that might interact with it in subtle ways). And one consequence of this subsumption of most effects into the default set is that they can no longer be disentangled, limiting your ability to think about them separately or refactor them neatly. So by choosing to not set impure functions as the default, Haskell does endorse tracking effects to a point where we can talk about effects separately and have tools to work with them fairly uniformly (Monad/Applicative classes and MTL, do notation, traverse, etc.), although it does still bless a set of default effects in the runtime with IO and STM (which interestingly are async, unlike most other languages whose impure functions are all sync).</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#199587456" name="199587456"><div>2020-06-03 07:33:45</div></a></div><div class="text"><p>You could probably set up a similar strawman saying that: Documentation is worthless. It doesn't help commercially. You can just figure out what the code does every time. Who needs it? Well, I say I do :)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/2c3c795b7e14eeb6a5a5660a9c84593b"></a><div class="content"><a class="author">Julian KG</a><div class="metadata"><a href="#199709471" name="199709471"><div>2020-06-04 06:26:31</div></a></div><div class="text"><p>I think a descriptive type system is really useful for documentation purposes. You could argue that if all of your top level type signatures don't lie it doesn't matter if you sprinkle in a few unsafePerformIO. I'd still disagree with that for the same reason I use semicolons when writing javascript. 99% of the time it doesn't cause problems, but when it does it's really painful, and typing a few extra characters doesn't waste that much time considering I spend most of my time debugging not typing.</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>