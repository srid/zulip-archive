<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="Does it make any sense to use trivial (i.e. constant/nonvarying) generators for types that functions/classes under test are parametric with respect to?" name="description"><link href="https://funprog.srid.ca/haskell/accounting-for-parametricity-in-property-testing.html" rel="canonical"><meta property="og:title" content="Accounting for parametricity in property testing - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2020-04-23T18:01:34Z"><meta property="og:article:published_time" content="2020-04-22T17:11:37Z"><title>Accounting for parametricity in property testing - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">Accounting for parametricity in property testing - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">Accounting for parametricity in property testing</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194962401" name="194962401"><div>2020-04-22 17:11:37</div></a></div><div class="text"><p>Does it make any sense to use trivial (i.e. constant/nonvarying) generators for types that functions/classes under test are parametric with respect to?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194962683" name="194962683"><div>2020-04-22 17:13:35</div></a></div><div class="text"><p>the type system already guarantees the function can't screw up by examining the values of those types, so you can basically put unit in there and still discover any bugs there are to find, no?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194963246" name="194963246"><div>2020-04-22 17:17:26</div></a></div><div class="text"><p>is there something prompting you to suspect otherwise?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194963336" name="194963336"><div>2020-04-22 17:18:01</div></a></div><div class="text"><p>Just my inexperience with property based testing :)</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194963420" name="194963420"><div>2020-04-22 17:18:23</div></a></div><div class="text"><p>most of the "xyz-classes" collections of laws I've seen online use something like an integer for types that the class is parametric wrt</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194963532" name="194963532"><div>2020-04-22 17:19:19</div></a></div><div class="text"><p>e.g. if testing the functor laws for <code>(a -&gt; b) -&gt; f a -&gt; f b</code>, they'll use integers for <code>a</code> and <code>b</code>. what I'm wondering is if its' safe for me to be stupider and just use <code>()</code>. will i still uncover whatever bugs there are to be found?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194963607" name="194963607"><div>2020-04-22 17:19:54</div></a></div><div class="text"><p>well.. I would still use something with more than one value</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194963687" name="194963687"><div>2020-04-22 17:20:19</div></a></div><div class="text"><p>Ok, why is that?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194963698" name="194963698"><div>2020-04-22 17:20:26</div></a></div><div class="text"><p>if you want to check <code>fmap f . fmap g $ xs == fmap (f . g) xs</code> you would need to use some <code>f</code>, and if that <code>f</code> is also <code>Identity</code> it would matter</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194963748" name="194963748"><div>2020-04-22 17:20:53</div></a></div><div class="text"><p>because <code>Identity ()</code> has only one (not containing bottom) value, so it will always be <code>==</code> to itself</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194963754" name="194963754"><div>2020-04-22 17:20:56</div></a></div><div class="text"><p>the <code>fmap</code> implementation never analyzes the <code>a</code> or <code>b</code>, that's guaranteed by the type system. so why would it matter whether I have a <code>Bool</code> or a <code>()</code>?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194963807" name="194963807"><div>2020-04-22 17:21:21</div></a></div><div class="text"><p>right. and there is actually only one way to write the fmap function for <code>Identity</code> just based on the types I think</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194963944" name="194963944"><div>2020-04-22 17:22:08</div></a></div><div class="text"><div class="codehilite"><pre><span></span>forall a b. (a -&gt; b) -&gt; Identity a -&gt; Identity b
</pre></div>


<p>If you erase the newtype, that's:</p>
<div class="codehilite"><pre><span></span>forall a b. (a -&gt; b) -&gt; a -&gt; b
</pre></div>


<p>I don't think it's possible to screw that up and still typecheck</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194963941" name="194963941"><div>2020-04-22 17:22:08</div></a></div><div class="text"><p>so you wouldn't be testing it for <code>Identity</code> anyway</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194964027" name="194964027"><div>2020-04-22 17:22:50</div></a></div><div class="text"><p>but I think this argument can be transferred to something more complex, e.g. <code>Maybe</code>?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194964054" name="194964054"><div>2020-04-22 17:23:14</div></a></div><div class="text"><p>hmm. with <code>Maybe</code> can't I just return <code>Nothing</code> for the <code>Just</code> case and screw up?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194964107" name="194964107"><div>2020-04-22 17:23:42</div></a></div><div class="text"><div class="codehilite"><pre><span></span>fmap f _ = Nothing
</pre></div></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194964240" name="194964240"><div>2020-04-22 17:24:36</div></a></div><div class="text"><p>if I have that bad implementation, and I'm only ever using <code>()</code>s for the type parameter to <code>Maybe</code>, i think I'd still catch it</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194964510" name="194964510"><div>2020-04-22 17:26:26</div></a></div><div class="text"><p>Like I said, I actually don't know whether this generalizes, that's why i'm asking. It just sounds like something that might make sense.</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194964605" name="194964605"><div>2020-04-22 17:27:14</div></a></div><div class="text"><p>I'd also wager on "it doesn't matter", I'm just trying to "play devil's advocate"</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194964638" name="194964638"><div>2020-04-22 17:27:28</div></a></div><div class="text"><p>yes, that's exactly what i'm looking for, thanks</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194964687" name="194964687"><div>2020-04-22 17:27:52</div></a></div><div class="text"><p>e.g. does something go wrong if we apply this principle to <code>Traversable</code>? Is <code>Identity</code> the only applicative I need to test with?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194965237" name="194965237"><div>2020-04-22 17:31:50</div></a></div><div class="text"><div class="codehilite"><pre><span></span><span class="nf">listToMaybe</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
</pre></div>


<p>for this using <code>[()] -&gt; Maybe ()</code> will never be able to catch that this implementation is "wrong":</p>
<div class="codehilite"><pre><span></span><span class="nf">listToMaybe</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">listToMaybe</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">x</span>
<span class="nf">listToMaybe</span> <span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">y</span>
</pre></div></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194965319" name="194965319"><div>2020-04-22 17:32:09</div></a></div><div class="text"><p>whereas <code>[Integer] -&gt; Maybe Integer</code> has a chance of doing so</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194965387" name="194965387"><div>2020-04-22 17:32:44</div></a></div><div class="text"><p>what is wrong with it?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194965475" name="194965475"><div>2020-04-22 17:33:28</div></a></div><div class="text"><p>like, what's the law we're testing?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194965495" name="194965495"><div>2020-04-22 17:33:36</div></a></div><div class="text"><p>wrong in the sense that it doesn't do the same thing as <code>Data.Maybe.listToMaybe</code>:</p>
<ol start="0">
<li>if the list is empty, return <code>Nothing</code></li>
<li>if it isn't, return the first element</li>
</ol></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194965618" name="194965618"><div>2020-04-22 17:34:20</div></a></div><div class="text"><p>so the law requires an <code>Eq</code> constraint on <code>a</code>?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194965631" name="194965631"><div>2020-04-22 17:34:29</div></a></div><div class="text"><p>yes</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194965641" name="194965641"><div>2020-04-22 17:34:33</div></a></div><div class="text"><p>like the <code>fmap</code> one</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194966077" name="194966077"><div>2020-04-22 17:37:56</div></a></div><div class="text"><p>hmm ok. I guess that's a good counterexample.</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194966292" name="194966292"><div>2020-04-22 17:39:21</div></a></div><div class="text"><p>i'm having some trouble figuring out how to write the law</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194966317" name="194966317"><div>2020-04-22 17:39:32</div></a></div><div class="text"><p><code>listToMaybe [] = Nothing</code> is law 0</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194966370" name="194966370"><div>2020-04-22 17:39:56</div></a></div><div class="text"><p>that's the problem with the example - the law is the implementation itself, basically</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194966377" name="194966377"><div>2020-04-22 17:39:59</div></a></div><div class="text"><p><code>listToMaybe (x : xs) = Just x</code></p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194966430" name="194966430"><div>2020-04-22 17:40:08</div></a></div><div class="text"><p>i guess that's the second one?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194966832" name="194966832"><div>2020-04-22 17:43:37</div></a></div><div class="text"><p>this gives us a counterexample for the fmap thing as well I believe</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194966847" name="194966847"><div>2020-04-22 17:43:48</div></a></div><div class="text"><p>for <code>fmap :: (a -&gt; b) -&gt; [a] -&gt; [b]</code> I mean</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194966993" name="194966993"><div>2020-04-22 17:44:53</div></a></div><div class="text"><div class="codehilite"><pre><span></span><span class="nf">fmap</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">fmap</span> <span class="n">f</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="nf">fmap</span> <span class="n">f</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="ow">=</span> <span class="p">[</span><span class="n">f</span> <span class="n">y</span><span class="p">,</span> <span class="n">f</span> <span class="n">x</span><span class="p">]</span>
<span class="nf">fmap</span> <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>
</pre></div></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194966996" name="194966996"><div>2020-04-22 17:44:55</div></a></div><div class="text"><p>like so?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194967036" name="194967036"><div>2020-04-22 17:45:23</div></a></div><div class="text"><p>hmm, i'm not sure we can actually write that second case</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194967043" name="194967043"><div>2020-04-22 17:45:29</div></a></div><div class="text"><p>oops</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194967062" name="194967062"><div>2020-04-22 17:45:41</div></a></div><div class="text"><p>ah, ok</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194967145" name="194967145"><div>2020-04-22 17:46:11</div></a></div><div class="text"><p>yeah, exactly. so that one would be fine if we were looking at <code>()</code>s all the time</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?x=x&amp;version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#194968113" name="194968113"><div>2020-04-22 17:53:33</div></a></div><div class="text"><p>Isn't it that for such type of testing, we want "counting" generator? We don't really care about the content, we care about it's uniqueness and position in resulting value (you can only move value around and apply arguments to it if it's polymorphic, can't you?). Simply spitting out unique values would uncover "moving around" immediately,  while random generator could potentially need more runs in case it "accidentally" generates same values in multiple places.</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194968119" name="194968119"><div>2020-04-22 17:53:37</div></a></div><div class="text"><p>very interesting. ok, so now that you've invalidated that hypothesis, how about the "dual" hypothesis: does using a generator that never produces the same thing twice for those type parameters work?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194968135" name="194968135"><div>2020-04-22 17:53:44</div></a></div><div class="text"><p><span class="user-mention" data-user-id="225127">@TheMatten</span> you beat me to it!</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194968268" name="194968268"><div>2020-04-22 17:54:52</div></a></div><div class="text"><p>(using <code>Const ()</code> for testing <code>Traversable</code>s should also exhibit the same flaw, I think)</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194969551" name="194969551"><div>2020-04-22 18:04:46</div></a></div><div class="text"><p>then you can't test the property of "being a function"</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194969565" name="194969565"><div>2020-04-22 18:04:53</div></a></div><div class="text"><p>because you'll never encounter the same <code>x</code> twice</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194969926" name="194969926"><div>2020-04-22 18:07:47</div></a></div><div class="text"><p>granted, that is a very weird thing to test</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?x=x&amp;version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#194970523" name="194970523"><div>2020-04-22 18:12:53</div></a></div><div class="text"><p><code>unsafePerformIO</code> stuff may need more than property testing <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#194972069" name="194972069"><div>2020-04-22 18:25:21</div></a></div><div class="text"><p>not only for actual functions:</p>
<p>if you've implemented <code>Map k v</code> as <code>[(k, v)]</code> under the hood, you may want a property that for all <code>Map</code>s, for each <code>k</code> there is at most one <code>v</code></p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194993876" name="194993876"><div>2020-04-22 21:30:44</div></a></div><div class="text"><p>this thread is too long for me to work through, so at the risk of repeating something already said</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194993881" name="194993881"><div>2020-04-22 21:30:48</div></a></div><div class="text"><p>no, you still want randomness!</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194993966" name="194993966"><div>2020-04-22 21:31:38</div></a></div><div class="text"><p>maybe i am implementing a set and property testing it</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194993993" name="194993993"><div>2020-04-22 21:31:59</div></a></div><div class="text"><p>probably i want a law that says <code>insert a (insert b s) == insert b (insert a s)</code></p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194994062" name="194994062"><div>2020-04-22 21:32:25</div></a></div><div class="text"><p>everything here is polymorphic! but if i have (badly) implemented <code>insert</code> in such a way that it only works once. in this case, a constant generator will say "yup, everything is fine!"</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194994128" name="194994128"><div>2020-04-22 21:33:08</div></a></div><div class="text"><p>there is a trivial model where you map everything to <code>()</code>; using a constant generator can't differentiate your model from that one</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194996231" name="194996231"><div>2020-04-22 21:56:49</div></a></div><div class="text"><p><span class="user-mention" data-user-id="251120">@Sandy Maguire</span> What about the non random generator that always generates distinct values discussed above (e.g. natural numbers 0..infinity)?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194996272" name="194996272"><div>2020-04-22 21:57:29</div></a></div><div class="text"><p>would that fail to detect an unlawful implementation in your set example?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194996370" name="194996370"><div>2020-04-22 21:58:35</div></a></div><div class="text"><p>then you don't get automatic testing of crazy values</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194996381" name="194996381"><div>2020-04-22 21:58:43</div></a></div><div class="text"><p>maybe my code only works up to 100 or something?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194996427" name="194996427"><div>2020-04-22 21:59:16</div></a></div><div class="text"><p>Your code doesn't have the opportunity to only work up to 100</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194996430" name="194996430"><div>2020-04-22 21:59:19</div></a></div><div class="text"><p>because it is parametric</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194996435" name="194996435"><div>2020-04-22 21:59:23</div></a></div><div class="text"><p>not true</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194996458" name="194996458"><div>2020-04-22 21:59:35</div></a></div><div class="text"><p>well, i guess true if you don't have any constraints</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194996468" name="194996468"><div>2020-04-22 21:59:45</div></a></div><div class="text"><p>but constraints can do arbitrarily crazy things :)</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194996476" name="194996476"><div>2020-04-22 21:59:50</div></a></div><div class="text"><p>If it isn't parametric in the relevant type then it's not relevant to what we're talking about</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194996569" name="194996569"><div>2020-04-22 22:00:28</div></a></div><div class="text"><p>if you're talking fully <code>forall a. a -&gt; ...</code> then yeah, sure, it's fine</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194996616" name="194996616"><div>2020-04-22 22:00:55</div></a></div><div class="text"><p>except if your code doesn't work now if you get two of the same value?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194996745" name="194996745"><div>2020-04-22 22:02:11</div></a></div><div class="text"><p>I don't quite understand that last bit</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194996848" name="194996848"><div>2020-04-22 22:03:51</div></a></div><div class="text"><p>trying hard to construct an example</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194996853" name="194996853"><div>2020-04-22 22:03:56</div></a></div><div class="text"><p>maybe it can't be done without an <code>Eq</code></p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#194996924" name="194996924"><div>2020-04-22 22:04:30</div></a></div><div class="text"><blockquote>
<p>except if your code doesn't work now if you get two of the same value?</p>
</blockquote>
<p>I'm talking about this bit. I don't quite understand what this means.</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194996937" name="194996937"><div>2020-04-22 22:04:41</div></a></div><div class="text"><p>okay well let's assume i have an eq on <code>a</code></p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194996987" name="194996987"><div>2020-04-22 22:05:35</div></a></div><div class="text"><p>i have a bad impl:</p>
<div class="codehilite"><pre><span></span>f a b | a == b = error &quot;uh oh&quot;
      | otherwise = pure 5
</pre></div></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194997052" name="194997052"><div>2020-04-22 22:06:13</div></a></div><div class="text"><p>maybe this can't exist without an eq constraint, so maybe you're fine</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#194997150" name="194997150"><div>2020-04-22 22:07:32</div></a></div><div class="text"><p>let's assume you're right that parametricity solves this problem for us! even then, you're also going to want to test code that is concrete, where a deterministic generator can always be detected, and then hide functionality or w/e</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#195096489" name="195096489"><div>2020-04-23 17:49:24</div></a></div><div class="text"><p>Seems like this is the weakness of not having dependent or refinement types to serve as proofs. Property tests generate values so that we can assert invariants on the domain and codomain of our functions which types alone are not able to express, no?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#195096870" name="195096870"><div>2020-04-23 17:52:40</div></a></div><div class="text"><p>They're not proofs but they give us some amount of certainty that for a sampling of the domain our invariant holds.</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#195097965" name="195097965"><div>2020-04-23 18:01:34</div></a></div><div class="text"><p>I think polymorphism alone is not sufficient to describe such properties otherwise we would be able to prove a functor is valid in Haskell alone, wouldn't we?</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>