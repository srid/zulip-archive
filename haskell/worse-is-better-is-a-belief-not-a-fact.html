<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="
So, Haskell, I conclude: it was definitely worth my time, even if it had only been so I can understand PL research papers. I can wholeheartedly endorse you learning it as well. But I&#39;m sad to say I don&#39;t imagine myself basing a new major project (or company) around it.
Strangely lately I&#39;ve been wr" name="description"><link href="https://funprog.srid.ca/haskell/worse-is-better-is-a-belief-not-a-fact.html" rel="canonical"><meta property="og:title" content="&quot;Worse is better&quot; is a belief, not a fact - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2020-07-19T04:41:55Z"><meta property="og:article:published_time" content="2020-05-13T15:21:13Z"><meta property="og:image" content="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"><title>&quot;Worse is better&quot; is a belief, not a fact - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">&quot;Worse is better&quot; is a belief, not a fact - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">&quot;Worse is better&quot; is a belief, not a fact</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#197428117" name="197428117"><div>2020-05-13 15:21:13</div></a></div><div class="text"><blockquote>
<p>So, Haskell, I conclude: it was definitely worth my time, even if it had only been so I can understand PL research papers. I can wholeheartedly endorse you learning it as well. But I'm sad to say <strong>I don't imagine myself basing a new major project (or company) around it</strong>.</p>
<p>Strangely lately I've been writing a lot of code in Go, which seems to have attracted a lot of other people I know. I think of the Go language as sort of the anti-Haskell: visually ugly, semantically warty, written with apparently little regard for the state of the art in research â€” but on the other hand, <strong>incredibly pragmatic throughout</strong>. A shining example of worse is better.</p>
</blockquote>
<p><a href="http://neugierig.org/software/blog/2011/10/why-not-haskell.html">http://neugierig.org/software/blog/2011/10/why-not-haskell.html</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#197431368" name="197431368"><div>2020-05-13 15:41:52</div></a></div><div class="text"><p>That is an odd opinion. "Warty" semantics make Go more pragmatic than Haskell?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#197431740" name="197431740"><div>2020-05-13 15:43:26</div></a></div><div class="text"><p>Via <a href="https://lobste.rs/s/q34wcy/why_not_haskell_2011">https://lobste.rs/s/q34wcy/why_not_haskell_2011</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#197433030" name="197433030"><div>2020-05-13 15:50:15</div></a></div><div class="text"><p>That's a valid trade-off but to categorically exclude Haskell even when what you <em>need</em> is a language with Haskell's features seems premature.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#197434301" name="197434301"><div>2020-05-13 15:58:16</div></a></div><div class="text"><p>Haskell is incredibly pragmatic throughout. Maybe we need more blog posts and articles about the practical aspects of Haskell.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#197434377" name="197434377"><div>2020-05-13 15:58:53</div></a></div><div class="text"><p>I find that even terribly written, no good, down and dirty Haskell is easier to work with and refactor into a clean, maintainable program than the same in C++...</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#197434612" name="197434612"><div>2020-05-13 16:00:19</div></a></div><div class="text"><p>I wonder what the golang circle on that diagram would look like</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/31b0847ae161d8af30e1a2fcb059be4d"></a><div class="content"><a class="author">Hazem</a><div class="metadata"><a href="#197435781" name="197435781"><div>2020-05-13 16:08:29</div></a></div><div class="text"><p>It's worth mentioning that this post is from 2011. I don't know about the state of Haskell back then (specifically in terms of tooling/libraries/docs), but Go was still new and shiny when the author made this post (Go first appeared in 2009) and that may have had an influence on the conclusion of the post.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#197436633" name="197436633"><div>2020-05-13 16:13:58</div></a></div><div class="text"><p>a lot will have changed</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#197436723" name="197436723"><div>2020-05-13 16:14:27</div></a></div><div class="text"><p>"... compile it due to the "DLL hell" that is package versioning of Hackage" solved with stack and <em>maybe</em> cabal sanboxes, depending upon things</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#197437413" name="197437413"><div>2020-05-13 16:19:34</div></a></div><div class="text"><p>so one thing in my philosophy to add to this is that getting started with a new tech on a project is largely a function of how familiar that tech is</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#197437443" name="197437443"><div>2020-05-13 16:19:52</div></a></div><div class="text"><p>and getting familiar is a one time const</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#197437524" name="197437524"><div>2020-05-13 16:20:09</div></a></div><div class="text"><p>whereas maintenance pain is an ongoing problem</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#197437560" name="197437560"><div>2020-05-13 16:20:29</div></a></div><div class="text"><p>But, i can easily imagine being familar-enough with enough of haskell to make it faster to prototype in than say ruby</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#197443547" name="197443547"><div>2020-05-13 17:01:37</div></a></div><div class="text"><p>I like using Haskell for prototyping now more than say, Javascript or Python, because I spend less time worrying about defined-ness or duck typing and more time on the actual problem.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#197444731" name="197444731"><div>2020-05-13 17:08:53</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="225136">Asad Saeeduddin</span> <a href="#narrow/stream/201385-Haskell/topic/.22Worse.20is.20better.22.20is.20a.20belief.2C.20not.20a.20fact/near/197434612">said</a>:</p>
<blockquote>
<p>I wonder what the golang circle on that diagram would look like</p>
</blockquote>
<p>I'd imagine the circles would be inverted.</p>
<p><code>( code written in go           (code that works)                    )</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#197446222" name="197446222"><div>2020-05-13 17:18:16</div></a></div><div class="text"><p>But to be less snarky... it took a while to get comfortable enough with Haskell to use it for <em>rapid</em> prototyping. As it does with pretty much any language you haven't been using and practicing with for years.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?x=x&amp;version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#197462052" name="197462052"><div>2020-05-13 19:13:57</div></a></div><div class="text"><p>It does require more principled approach to prototyping though - you can't really mash random blobs of POC code together, instead you may need to take more top-down approach... unless you use <code>-fdefer-type-errors</code> <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/2c3c795b7e14eeb6a5a5660a9c84593b"></a><div class="content"><a class="author">Julian KG</a><div class="metadata"><a href="#204181203" name="204181203"><div>2020-07-17 08:16:44</div></a></div><div class="text"><p>As one of the few people who really likes Go let me add to this thread really late. I think Go is a great language for correctness relatively speaking. In my opinion the reason why Haskell is so great for correctness is not just that it gives you certain compile time guarantees, but that it frees up that space in your brain to focus on solving logic problems. When I'm writing Go I only think about how to solve the problem, not any of the complexities of the language.  And for difficult problems (resource managment, concurrency) they give you easy to use custom built tools (defer, channels). This is why I was a big person pushing against Java style generics when everyone was clamoring for them. Writing generic code is hard, and when things don't need to be generic they shouldn't be. Go sometimes feels awkward and verbose sometimes especially from a Haskell background, I'm not going to sugar coat it. But I have yet to find a difficult to read Go project, and I can't say the same about Haskell. Under abstraction is better than over abstraction in my opinion.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/2c3c795b7e14eeb6a5a5660a9c84593b"></a><div class="content"><a class="author">Julian KG</a><div class="metadata"><a href="#204181888" name="204181888"><div>2020-07-17 08:26:27</div></a></div><div class="text"><p>I'd also like to add that IMO Go is not really competing with Haskell in my opinion. Go's biggest problem IMO, is there are some things it just isn't powerful enough to do (this may be changing with generics, but I'm not convinced). Something like LLVM will never be written in Go. The languages Haskell competes with are typed languages with are other swiss army knife languages like C++, and dynamically typed languages which achieve Haskell-esque expressiveness by throwing out guarantees.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#204196868" name="204196868"><div>2020-07-17 11:53:03</div></a></div><div class="text"><p>Go <strong>is</strong> competing with Haskell, at least in my company - we have services written in both</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/8084ff35e892945a460a7ed9885325c7804e1b87?x=x&amp;version=2"></a><div class="content"><a class="author">Rizary</a><div class="metadata"><a href="#204197132" name="204197132"><div>2020-07-17 11:57:20</div></a></div><div class="text"><p>whose win? This happen to me, when it more easy to find Go programmer than Haskell one, or when we are afraid if only few people can maintain Haskell code, Go win.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#204205176" name="204205176"><div>2020-07-17 13:26:07</div></a></div><div class="text"><p>well I can't say "win" or "loss" - they're coexisting, it's just different teams</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#204205204" name="204205204"><div>2020-07-17 13:26:23</div></a></div><div class="text"><p>personally I really would rather not give up servant and all the things that come with it</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/ca2e2c3442a73f84394abb35d6236b12"></a><div class="content"><a class="author">Magnus Therning</a><div class="metadata"><a href="#204209060" name="204209060"><div>2020-07-17 14:00:59</div></a></div><div class="text"><p>(deleted)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#204264739" name="204264739"><div>2020-07-17 22:01:16</div></a></div><div class="text"><p>I have not written much go at all, but I have seen go and what I have seen is extremely verbose</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#204264872" name="204264872"><div>2020-07-17 22:02:49</div></a></div><div class="text"><p>it can be quite hard to grok because of that, and also the lack of controlled effects means you have lots of things happening</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/d5f51e76392d18898a66faf360be0416"></a><div class="content"><a class="author">Daniel DÃ­az Carrete</a><div class="metadata"><a href="#204319360" name="204319360"><div>2020-07-18 21:48:51</div></a></div><div class="text"><p>I'm not fluent in Go, but there seem to be things that are better. Not "worse is better" better, but "honest-to-God better" better. Things like struct tags to decouple serialized field names from the internal field names of structs, and also this: <a href="https://www.youtube.com/watch?v=Dq0WFigax_c&amp;t=15m20s">YouTube - Phil Wadler: Featherweight Go</a></p>
<div class="youtube-video message_inline_image"><a data-id="Dq0WFigax_c" href="https://www.youtube.com/watch?v=Dq0WFigax_c&amp;t=15m20s"><img src="https://i.ytimg.com/vi/Dq0WFigax_c/default.jpg"></a></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#204332819" name="204332819"><div>2020-07-19 04:41:55</div></a></div><div class="text"><p>Haskell is pretty old. It would be quite surprising if you couln't find <em>anything</em> in a language made 20 years later that was better in some way.</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>