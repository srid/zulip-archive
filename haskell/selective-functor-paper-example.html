<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="I&#39;m a little bit confused about one of the examples in the selective functors paper:
pasted image
I don&#39;t get why the output isn&#39;t &quot;abdef&quot;, given that ifS is defined as:
pasted image 
It seems like that would pick only one of the two given f as, and not both (specifically, the first when the f Bool " name="description"><link href="https://funprog.srid.ca/haskell/selective-functor-paper-example.html" rel="canonical"><meta property="og:title" content="Selective functor paper example - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2020-01-29T14:05:17Z"><meta property="og:article:published_time" content="2020-01-29T06:52:31Z"><meta property="og:image" content="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"><title>Selective functor paper example - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">Selective functor paper example - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">Selective functor paper example</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186860459" name="186860459"><div>2020-01-29 06:52:31</div></a></div><div class="text"><p>I'm a little bit confused about one of the examples in the selective functors <a href="https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf" target="_blank" title="https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf">paper</a>:</p>
<p><a href="/user_uploads/13896/aglLtUGPL0oUj1-4FKlg9m6q/pasted_image.png" target="_blank" title="pasted_image.png">pasted image</a></p>
<div class="message_inline_image"><a href="/user_uploads/13896/aglLtUGPL0oUj1-4FKlg9m6q/pasted_image.png" target="_blank" title="pasted image"><img src="/user_uploads/13896/aglLtUGPL0oUj1-4FKlg9m6q/pasted_image.png"></a></div><p>I don't get why the output isn't "abdef", given that <code>ifS</code> is defined as:</p>
<p><a href="/user_uploads/13896/lV59-P4_FFsLDUZ86cwktlNl/pasted_image.png" target="_blank" title="pasted_image.png">pasted image</a> </p>
<div class="message_inline_image"><a href="/user_uploads/13896/lV59-P4_FFsLDUZ86cwktlNl/pasted_image.png" target="_blank" title="pasted image"><img src="/user_uploads/13896/lV59-P4_FFsLDUZ86cwktlNl/pasted_image.png"></a></div><p>It seems like that would pick only one of the two given <code>f a</code>s, and not both (specifically, the first when the <code>f Bool</code> contains a <code>True</code>). Am I just misunderstanding something?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186860485" name="186860485"><div>2020-01-29 06:53:34</div></a></div><div class="text"><p><span class="user-mention" data-user-id="251120">@Sandy Maguire</span> I remember you were explaining something about the paper to me a while back, so I know you've gone through it. Can you maybe what I'm missing?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543?d=identicon&amp;version=1"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#186866943" name="186866943"><div>2020-01-29 09:08:02</div></a></div><div class="text"><p>been a while since i read it, but IIRC, selectives are not required to perform the untaken branches, but may if they choose to</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543?d=identicon&amp;version=1"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#186866981" name="186866981"><div>2020-01-29 09:08:33</div></a></div><div class="text"><p>the <code>Over</code> selective is <em>over</em>ly eager in what it reports --- aka the entire call graph possible</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543?d=identicon&amp;version=1"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#186867019" name="186867019"><div>2020-01-29 09:09:28</div></a></div><div class="text"><p>there is also <code>Under</code> which i think will give you <code>Under "abdef"</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543?d=identicon&amp;version=1"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#186867033" name="186867033"><div>2020-01-29 09:09:45</div></a></div><div class="text"><p>(or maybe even less!)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543?d=identicon&amp;version=1"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#186867150" name="186867150"><div>2020-01-29 09:11:05</div></a></div><div class="text"><p>actually i think it will give you <code>Under "ade"</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186874438" name="186874438"><div>2020-01-29 10:55:12</div></a></div><div class="text"><p>Yes <code>Over</code> over-approximates the the effects. So you have both effects on the <code>ifS</code> I very much like the applicability on build systems as it helps to build an intuition! </p>
<p>For instance, in this particular example one branch of the if could need one dependency and the other another different dependency. Then over approximating the effects would give info about which dependencies should be needed in total!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186875457" name="186875457"><div>2020-01-29 11:08:44</div></a></div><div class="text"><p>Btw <span class="user-mention" data-user-id="225136">@Asad Saeeduddin</span>  I read your draft README on the selectivemonoidal repository and caught my attention, is there really the concept of <code>Decisive</code> in CT being the dual of a <code>Monoidal</code> functor?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186875961" name="186875961"><div>2020-01-29 11:14:03</div></a></div><div class="text"><p><span class="user-mention" data-user-id="250742">@Bolt</span> That's very close. <code>Decisive</code> isn't the dual of a monoidal functor, it <em>is</em> a kind of monoidal functor, just as <code>Applicative</code> is a kind of monoidal functor. The concept of a monoidal functor is "parametrized" by a source and a target "monoidal category", which in turn is a concept consisting of a category + a "monoidal structure". You get a <code>Decisive</code> functor by taking an <code>Applicative</code> lax monoidal functor and replacing both the category and the monoidal structure with their duals</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186876040" name="186876040"><div>2020-01-29 11:15:43</div></a></div><div class="text"><p>What can you say about Strong Functors relation with Selective functors??</p>
<div class="codehilite"><pre><span></span><span class="nf">lstr</span> <span class="ow">::</span> <span class="kt">Strong</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">rstr</span> <span class="ow">::</span> <span class="kt">Strong</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="nf">select</span> <span class="ow">::</span> <span class="kt">Strong</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="nf">select</span> <span class="ow">=</span> <span class="n">curry</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">h</span> <span class="o">.</span> <span class="n">rstr</span><span class="p">)</span>
  <span class="kr">where</span> <span class="n">h</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">either</span> <span class="n">f</span> <span class="n">id</span> <span class="n">x</span>
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186876049" name="186876049"><div>2020-01-29 11:15:50</div></a></div><div class="text"><p>Btw, I figured out how to "break" things to get the same results as in the paper: I just have to derive <code>branch</code> from <code>select</code> instead of the other way around. I think having <code>Over "abcdef"</code> and <code>Under "acde"</code> is actually more correct than <code>Over "abdef"</code> and <code>Under "ade"</code>, but I've explained more in the comments</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186876130" name="186876130"><div>2020-01-29 11:16:28</div></a></div><div class="text"><p>What exactly is <code>Strong</code>? Strength is with respect to a particular tensor, and every endofunctor on Hask is strong with respect to <code>(,)</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186876168" name="186876168"><div>2020-01-29 11:17:06</div></a></div><div class="text"><p>Strong is a typeclass with <code>lstr</code> and <code>rstr</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186876188" name="186876188"><div>2020-01-29 11:17:27</div></a></div><div class="text"><p>That typeclass can be instantiated for every functor</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186876200" name="186876200"><div>2020-01-29 11:17:49</div></a></div><div class="text"><p>i.e. you need no more than <code>fmap</code> and the characteristics of <code>(,)</code> to implement that</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186876257" name="186876257"><div>2020-01-29 11:18:16</div></a></div><div class="text"><p>Yes I think that is because every functor in Set is strong, I know very little about it</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186876319" name="186876319"><div>2020-01-29 11:19:45</div></a></div><div class="text"><p>But I asked this because they also fit in the whole Monoidal functor thing you have going</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186876645" name="186876645"><div>2020-01-29 11:24:19</div></a></div><div class="text"><blockquote>
<p>i.e. you need no more than <code>fmap</code> and the characteristics of <code>(,)</code> to implement that</p>
</blockquote>
<p>And this is interesting right? The fact that you only need this (a Strong Functor) to derive <code>select</code> and the fact that every functor in Set is Strong might be useful</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186876861" name="186876861"><div>2020-01-29 11:27:48</div></a></div><div class="text"><p>In Set the product is <code>(,)</code> but for example in Mat (the matrix category) the product is the Kronecker product. I do not know if it is trivial to have a strong functor in other categories</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186877198" name="186877198"><div>2020-01-29 11:32:40</div></a></div><div class="text"><p>are you sure that the <code>select</code> derived from <code>Strong</code> typechecks? I'm not sure how that's working without relying on <code>Applicative</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186877266" name="186877266"><div>2020-01-29 11:33:45</div></a></div><div class="text"><p>all <code>lstr</code> and <code>rstr</code> are is <code>lstr (b, fa) = fmap (b, ) fa</code> and <code>rstr (fa, b) = fmap (, b) fa</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186877516" name="186877516"><div>2020-01-29 11:37:22</div></a></div><div class="text"><p>It's not super clear to me what <code>Strong</code> has to do with <code>Monoidal</code> in this context (note that I have no idea what <code>Monoidal</code> classes are out there, they may or may not have anything to do with the concept of a lax monoidal functor), but here for example is the lax monoidal functor representation of <code>Applicative</code>:</p>
<div class="codehilite"><pre><span></span>class Functor f =&gt; Applicative&#39; f
  where
  zip :: (-&gt;) (f a, f b) f (a, b)
  husk :: (-&gt;) () (f ())
</pre></div>


<p>Compare and contrast with:</p>
<div class="codehilite"><pre><span></span>class Functor f =&gt; Decisive f
  where
  decide :: Op (-&gt;) (Either (f a) (f b)) (f (Either a b))
  guarantee :: Op (-&gt;) Void (f Void)
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186877844" name="186877844"><div>2020-01-29 11:42:46</div></a></div><div class="text"><p><span class="user-mention" data-user-id="250742">@Bolt</span> When I try to compile:</p>
<div class="codehilite"><pre><span></span>rstr :: Functor f =&gt; (f a, b) -&gt; f (a, b)
rstr (fa, b) = fmap (, b) fa

select&#39; :: Functor f =&gt; f (a -&gt; b) -&gt; f (Either a b) -&gt; f b
select&#39; = curry (fmap h . rstr)
  where h (f,x) = either f id x
</pre></div>


<p>I get:</p>
<div class="codehilite"><pre><span></span>[typecheck] [E] /mnt/data/depot/git/haskell/experiments/selectivemonoidal/src/Main.hs:57:11: error:
    • Occurs check: cannot construct the infinite type: b ~ Either a b
      Expected type: f (a -&gt; b) -&gt; f (Either a b) -&gt; f b
        Actual type: f (a -&gt; b) -&gt; Either a b -&gt; f b
    • In the expression: curry (fmap h . rstr)
      In an equation for ‘select&#39;’:
          select&#39;
            = curry (fmap h . rstr)
            where
                h (f, x) = either f id x
    • Relevant bindings include
        select&#39; :: f (a -&gt; b) -&gt; f (Either a b) -&gt; f b
          (bound at /mnt/data/depot/git/haskell/experiments/selectivemonoidal/src/Main.hs:57:1)
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186877874" name="186877874"><div>2020-01-29 11:43:59</div></a></div><div class="text"><p>At any rate I've updated the repo, so you can play around with a variant of <code>branch</code> and <code>ifS</code> that exactly replicate the results from the selective functors paper (although I think the results that differ are "more correct"). It all flows down from <code>Decisive</code> regardless of which seems more correct to you</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186877957" name="186877957"><div>2020-01-29 11:45:26</div></a></div><div class="text"><p>Interesting, I'll read it!</p>
<p>I probably misspelled something because I'm on my phone, let me try again <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186878561" name="186878561"><div>2020-01-29 11:54:10</div></a></div><div class="text"><p><span class="user-mention" data-user-id="225136">@Asad Saeeduddin</span> No, you are right it is needed the Applicative instance, that's unfortunate :P But was a nice exercise!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186882318" name="186882318"><div>2020-01-29 12:52:43</div></a></div><div class="text"><p>It's interesting to see the difference between the implementations of branch and select! But I think I prefer the semantics where <code>ifS</code> gives every effect. I'm not sure which approach is more flexible since you cannot encode a <code>Selective</code> <code>Over</code> instance that gives the more intuitive result with <code>ifS</code> and neither can you encode a <code>Decide</code> <code>Over</code> instance that gives the results seen in the paper. But since the <code>Decide</code> class brings out the different interactions when implementing <code>select</code> as <code>branch</code> and vice-versa I think your approach wins in that respect</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186882365" name="186882365"><div>2020-01-29 12:53:52</div></a></div><div class="text"><p><span class="user-mention" data-user-id="250742">@Bolt</span> I'm not sure I fully understand the comment about flexibility, but starting from an instance of <code>Decide</code> we can obtain either implementation of <code>ifS</code>. We can get the one from the paper, or a different one that actually behaves like if _ else _ then _</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186882543" name="186882543"><div>2020-01-29 12:56:08</div></a></div><div class="text"><p>The flexibility I am talking about is basically the ability of changing the semantics of <code>Over</code> wrt to its instance implementation. If such an instance could exist then we'd have 2 newtype wrappers around <code>Over</code> one for each semantic!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186882606" name="186882606"><div>2020-01-29 12:57:25</div></a></div><div class="text"><p>With <code>Decide</code> you can have that but is not very straightforward, is more like exploiting a hidden behaviour. Although it is able to do it is not very elegant, but it still is better than <code>Selective</code> which does not allow that (I think)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186882909" name="186882909"><div>2020-01-29 13:01:02</div></a></div><div class="text"><p>In the repo, we have both <code>Over</code> and <code>Under</code>. The <code>select</code> operation on <code>Over</code> unconditionally executes both the <code>f (Either a b)</code> and the <code>f (a -&gt; b)</code> (just as in the paper), and the <code>select</code> operation on <code>Under</code> never executes the <code>f (a -&gt; b)</code> (just as in the paper). Similarly, what the paper calls <code>branch</code> and I call <code>branch'</code> (but probably should call something like <code>fallthrough</code>) will for <code>Over</code> execute all three of the effects given to it, and for <code>Under</code> will only execute the first effect. This also aligns with the paper.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186883024" name="186883024"><div>2020-01-29 13:02:47</div></a></div><div class="text"><p>The only new thing is that now there are two extra operations <code>actuallyBranch</code> and <code>actuallyIfS</code>, that actually branch and behave like if else. The <code>actuallyBranch</code> is the primitive "unadulterated" operation from which you can derive <code>select</code> and <code>fallthrough</code> and everything else, and of course you can use it itself as an operation that is not available in the paper.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186883132" name="186883132"><div>2020-01-29 13:04:05</div></a></div><div class="text"><p>Right! But can you have <code>actuallyBranch</code> and <code>actuallyIfS</code> by using only the <code>select</code> from the paper?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186883181" name="186883181"><div>2020-01-29 13:05:08</div></a></div><div class="text"><p>You can't change the semantics of <code>select</code> for <code>Over</code> or the semantics of <code>select</code> for <code>Under</code>, those are just part of the instance. You can't really change any of their semantics to resemble each other in fact. None of the operations for <code>Over</code> behave like the operations for <code>Under</code>, and vice versa. <code>Over</code> just has a new pair of operations <code>actuallyBranch</code> and <code>actuallyIfS</code> (which always evaluate the first two effects, having no actual boolean to branch on), and so does <code>Under</code> (which instead always chooses the first and third ones).</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186883228" name="186883228"><div>2020-01-29 13:06:00</div></a></div><div class="text"><p>No, you can only go in the other direction. You can get the <code>select</code> from the paper out of <code>actuallyBranch</code>, but if you start with <code>select</code> you can never get <code>actuallyBranch</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186883279" name="186883279"><div>2020-01-29 13:06:10</div></a></div><div class="text"><p>Also:</p>
<blockquote>
<p>F is an applicative functor<br>
    F is a decisive functor</p>
</blockquote>
<p>From my understanding a <code>Decisive</code> functor is a concrete instance of a <code>Monoidal</code> functor just as <code>Applicative</code> is, shouldn't this hypotheses be something more fundamental? I dont know if what I'm saying makes sense</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186883288" name="186883288"><div>2020-01-29 13:06:17</div></a></div><div class="text"><p>because it muddles up different operations so that you can't separate them again</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186883324" name="186883324"><div>2020-01-29 13:07:00</div></a></div><div class="text"><p>I would stop capitalizing <code>Monoidal</code> here (unless <code>Monoidal</code> is an extremely general typeclass that I doubt it is)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186883457" name="186883457"><div>2020-01-29 13:08:48</div></a></div><div class="text"><p>Maybe not an instance but there's an isomorphism between them</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186883522" name="186883522"><div>2020-01-29 13:09:40</div></a></div><div class="text"><p>Also this does suggest the claim that a Selective functor can be seen as the composition of an applicative functor with the <code>Either</code> monad, right?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186883588" name="186883588"><div>2020-01-29 13:10:07</div></a></div><div class="text"><p>I guess where I'm trying to get at is some kind of formal ground where this can all be eventually proved</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186883675" name="186883675"><div>2020-01-29 13:11:36</div></a></div><div class="text"><blockquote>
<p>Maybe not an instance but there's an isomorphism between them</p>
</blockquote>
<p>If you mean there's an isomorphism between <code>Applicative</code> and <code>Selective</code> somehow, then no, we're getting confused</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186883805" name="186883805"><div>2020-01-29 13:13:12</div></a></div><div class="text"><p>Here is the actual <code>MonoidalFunctor</code> class you should be looking at if you want to see the way in which all <code>Applicative</code>s are monoidal functors of one kind and all <code>Selective</code>s are monoidal functors of another kind: <a href="https://gist.github.com/masaeedu/9706a06969e5ce127753cb55c622ae77#file-monoidal-hs-L40" target="_blank" title="https://gist.github.com/masaeedu/9706a06969e5ce127753cb55c622ae77#file-monoidal-hs-L40">https://gist.github.com/masaeedu/9706a06969e5ce127753cb55c622ae77#file-monoidal-hs-L40</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://gist.github.com/masaeedu/9706a06969e5ce127753cb55c622ae77#file-monoidal-hs-L40" style="background-image: url(https://github.githubassets.com/images/modules/gists/gist-og-image.png)" target="_blank"></a><div class="data-container"><div class="message_embed_title"><a href="https://gist.github.com/masaeedu/9706a06969e5ce127753cb55c622ae77#file-monoidal-hs-L40" target="_blank" title="Various monoidal categories, monoidal functors, and monoid objects">Various monoidal categories, monoidal functors, and monoid objects</a></div><div class="message_embed_description">Various monoidal categories, monoidal functors, and monoid objects - monoidal.hs</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186883845" name="186883845"><div>2020-01-29 13:13:59</div></a></div><div class="text"><p>Here's the formal definition of a lax monoidal functor: <a href="https://en.wikipedia.org/wiki/Monoidal_functor" target="_blank" title="https://en.wikipedia.org/wiki/Monoidal_functor">https://en.wikipedia.org/wiki/Monoidal_functor</a>, although you should probably first look at the definition of a monoidal category</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186884064" name="186884064"><div>2020-01-29 13:16:47</div></a></div><div class="text"><p><code>Applicative</code>s are lax monoidal functors from the monoidal category <code>(-&gt;, (,), ())</code> to itself, and <code>Decisive</code>s are lax monoidal functors from <code>(&lt;-, Either, Void)</code> to itself</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186884102" name="186884102"><div>2020-01-29 13:17:16</div></a></div><div class="text"><p>The isomorphism I was talking about was between <code>Applicative </code> and <code>Monoidal</code>!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186884143" name="186884143"><div>2020-01-29 13:17:49</div></a></div><div class="text"><p>But that's some nice info about the subject, I sometimes get confused! Thanks</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186884147" name="186884147"><div>2020-01-29 13:17:54</div></a></div><div class="text"><p>Ah. Well what is <code>Monoidal</code>? I forget if you already linked it</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186884228" name="186884228"><div>2020-01-29 13:18:30</div></a></div><div class="text"><p>My <code>Monoidal</code> is actually the <code>MonoidalFunctor</code> you linked :P</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186884379" name="186884379"><div>2020-01-29 13:20:28</div></a></div><div class="text"><p>In that case there is an isomorphism between <code>Applicative</code> and a particular <em>instantiation</em> of <code>MonoidalFunctor</code>. Specifically, its instantiation at <code>→ = -&gt;</code>, <code>⊗ = (,)</code> and <code>I = ()</code> for both categories</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186884446" name="186884446"><div>2020-01-29 13:21:30</div></a></div><div class="text"><p>If we instead instantiate it at  <code>→ = &lt;-</code>, <code>⊗ = Either</code> and <code>I = Void</code> for both categories instead, we end up with <code>Decisive</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186884712" name="186884712"><div>2020-01-29 13:24:25</div></a></div><div class="text"><p>There's other interesting examples as well, although they're irrelevant to selectives. E.g. if we instead instantiate the first category at <code>→ = -&gt;</code>, <code>⊗ = Either</code> and <code>I = Void</code> and the second at <code>→ = -&gt;</code>, <code>⊗ = (,)</code> and <code>I = ()</code>, we end up with <code>Alternative</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186885578" name="186885578"><div>2020-01-29 13:35:03</div></a></div><div class="text"><p>the most explicit way I can think of to write out the class is:</p>
<div class="codehilite"><pre><span></span>class
  (SemigroupalCategory (→₁) (⊗₁), SemigroupalCategory (→₂) (⊗₂), Functor (→₁) (→₂) f)
  =&gt;
  SemigroupalFunctor (→₁) (⊗₁) (→₂) (⊗₂) f
  where
  zip :: f a ⊗₂ f b →₂ f (a ⊗₁ b)

class
  (MonoidalCategory (→₁) (⊗₁) (I₁), MonoidalCategory (→₂) (⊗₂) (I₂), SemigroupalFunctor (→₁) (→₂) f)
  =&gt;
  MonoidalFunctor (→₁) (⊗₁) (I₁) (→₂) (⊗₂) (I₂) f
  where
  pure :: I₂ →₂ f I₁
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186885707" name="186885707"><div>2020-01-29 13:36:34</div></a></div><div class="text"><p>so then:</p>
<div class="codehilite"><pre><span></span>type Applicative = MonoidalFunctor (-&gt;) (,) () (-&gt;) (,) ()
type Decisive = MonoidalFunctor (Op (-&gt;)) Either Void (Op (-&gt;)) Either Void
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186885758" name="186885758"><div>2020-01-29 13:37:39</div></a></div><div class="text"><p>Both of kind <code>(* -&gt; *) -&gt; Constraint</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186886853" name="186886853"><div>2020-01-29 13:51:26</div></a></div><div class="text"><p>The laws you can read off the three diagrams on the Wikipedia page: <a href="https://en.wikipedia.org/wiki/Monoidal_functor" target="_blank" title="https://en.wikipedia.org/wiki/Monoidal_functor">https://en.wikipedia.org/wiki/Monoidal_functor</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186887412" name="186887412"><div>2020-01-29 13:58:45</div></a></div><div class="text"><p>Awesome! Thank you for this!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186887460" name="186887460"><div>2020-01-29 13:59:36</div></a></div><div class="text"><p>no worries</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186887463" name="186887463"><div>2020-01-29 13:59:40</div></a></div><div class="text"><p>I have one question tho, is it correct to instantiate the product as <code>Either</code> ?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923?d=identicon&amp;version=1"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#186887579" name="186887579"><div>2020-01-29 14:00:40</div></a></div><div class="text"><p>Yes. That's the critical idea. The cartesian product and unit are just one special case of the more general concept of a "monoidal structure". There are often lots of different monoidal structures on the same category. To understand what the rules are, look up "monoidal category".</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/068f19d948936a41dcd13e340bacb9344e28944c?x=x&amp;version=2"></a><div class="content"><a class="author">Bolt</a><div class="metadata"><a href="#186887929" name="186887929"><div>2020-01-29 14:05:17</div></a></div><div class="text"><p>Super interesting!</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a></div></div></body></html>