<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="It seems to me that there is this perception that advocating for boring Haskell automatically includes resenting anything complex in regards to types of a Haskell code.
One should be careful to separate this resentment -- which is purely feeling based -- from encouraging an ecosystem of simpler (&#39;bo" name="description"><link href="https://funprog.srid.ca/haskell/boring-haskell-resenting-types.html" rel="canonical"><meta property="og:title" content="Boring Haskell /= Resenting Types - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2020-10-04T16:54:34Z"><meta property="og:article:published_time" content="2020-09-03T21:08:30Z"><meta property="og:image" content="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"><title>Boring Haskell /= Resenting Types - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">Boring Haskell /= Resenting Types - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">Boring Haskell /= Resenting Types</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209029805" name="209029805"><div>2020-09-03 21:08:30</div></a></div><div class="text"><p>It seems to me that there is this perception that advocating for boring Haskell automatically includes resenting anything complex in regards to types of a Haskell code.</p>
<p>One should be careful to separate this resentment -- which is purely feeling based -- from encouraging an ecosystem of simpler ('<a href="https://www.srid.ca/2012406.html">boring</a>') interfaces in Haskell. The former is cynical, and kills any <a href="https://www.srid.ca/2012407.html">sense of learning</a>.</p>
<p>This tweet is a case in point: <a href="https://twitter.com/jkachmar/status/1257515468530814976">https://twitter.com/jkachmar/status/1257515468530814976</a></p>
<div class="inline-preview-twitter"><div class="twitter-tweet"><a href="https://twitter.com/jkachmar/status/1257515468530814976"><img class="twitter-avatar" src="https://pbs.twimg.com/profile_images/1039970947023990785/G7Rci9qA_normal.jpg"></a><p>Done w/ Haskell, would prefer literally anything else in this moment.

Perhaps APL, J, or Brainfuck; something user-friendly. <a href="https://t.co/3bMVIycHLE">https://twitter.com/jkachmar/status/1257515468530814976/photo/1</a></p><span>- Joe Kachmar üè≥Ô∏è‚Äçüåà (@jkachmar)</span><div class="twitter-image"><a href="https://t.co/3bMVIycHLE"><img src="https://pbs.twimg.com/media/EXOXpmIWsAIxfQk.jpg:medium"></a></div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209029865" name="209029865"><div>2020-09-03 21:09:23</div></a></div><div class="text"><p>More generally, when people talk about 'toxicism' in Haskell community (something I generally can't relate to), this is the kind of the attitude that would come to my mind--the creation and maintenance of a FUD-esque ambiance.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209030465" name="209030465"><div>2020-09-03 21:14:51</div></a></div><div class="text"><p>is that Cale from obsidian?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209030496" name="209030496"><div>2020-09-03 21:15:15</div></a></div><div class="text"><p>Yup. Cale is awesome; used to pair with him at Obsidian. You would learn a ton from him.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209030731" name="209030731"><div>2020-09-03 21:17:16</div></a></div><div class="text"><p>any idea what the tweet is about? Since the library isn't for public use, did he just browse a random code repo and get mad at it?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209030883" name="209030883"><div>2020-09-03 21:18:50</div></a></div><div class="text"><p>vessel is a part of ‚ÄúIncremental View‚Äù that Obsidian is working as a successor to rhyolite (which is used in Cerveau, for real-time communications): <a href="https://www.srid.ca/2012401.html">https://www.srid.ca/2012401.html</a></p>
<p>Here's the type in the tweet: <a href="https://github.com/obsidiansystems/vessel/blob/f0c55cbd03304bc37cafb0cf444e3f65ddb34ec9/src/Data/Vessel/Vessel.hs#L55-L68">https://github.com/obsidiansystems/vessel/blob/f0c55cbd03304bc37cafb0cf444e3f65ddb34ec9/src/Data/Vessel/Vessel.hs#L55-L68</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/obsidiansystems/vessel/blob/f0c55cbd03304bc37cafb0cf444e3f65ddb34ec9/src/Data/Vessel/Vessel.hs#L55-L68" style="background-image: url(https://avatars2.githubusercontent.com/u/11916262?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/obsidiansystems/vessel/blob/f0c55cbd03304bc37cafb0cf444e3f65ddb34ec9/src/Data/Vessel/Vessel.hs#L55-L68" title="obsidiansystems/vessel">obsidiansystems/vessel</a></div><div class="message_embed_description">Functor-parametric containers. Contribute to obsidiansystems/vessel development by creating an account on GitHub.</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209030916" name="209030916"><div>2020-09-03 21:19:15</div></a></div><div class="text"><p>yeah I've seen it before</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209030987" name="209030987"><div>2020-09-03 21:19:52</div></a></div><div class="text"><p>Joe hates Obsidian / Reflex. Even today he was saying that in #nix channel of fpslack. Something to keep in mind.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209031044" name="209031044"><div>2020-09-03 21:20:07</div></a></div><div class="text"><p><span aria-label="joy cat" class="emoji emoji-1f639" role="img" title="joy cat">:joy_cat:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209031066" name="209031066"><div>2020-09-03 21:20:29</div></a></div><div class="text"><p>for other reasons, or only because of the higher-kinded types?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209031077" name="209031077"><div>2020-09-03 21:20:44</div></a></div><div class="text"><p>I'm just trying to warn people not to allow themselves to get infected by such FUD ambiance.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209031092" name="209031092"><div>2020-09-03 21:21:03</div></a></div><div class="text"><p>I don't know; maybe he had an issue in one of his prior jobs, with reflex.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209031119" name="209031119"><div>2020-09-03 21:21:24</div></a></div><div class="text"><p>that sounds like a reasonable assumption</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209031218" name="209031218"><div>2020-09-03 21:22:18</div></a></div><div class="text"><p>I've seen lots of people get mad at abstract code, mostly probably because they don't want to sacrifice their free time to learn how it works</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209031237" name="209031237"><div>2020-09-03 21:22:29</div></a></div><div class="text"><p>All I'm saying is - choose what sort of emotional contagion you would let in in your affective life <a href="https://www.pnas.org/content/111/24/8788">https://www.pnas.org/content/111/24/8788</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://www.pnas.org/content/111/24/8788" style="background-image: url(https://www.pnas.org/content/111/24/8788/F1.large.jpg)"></a><div class="data-container"><div class="message_embed_title"><a href="https://www.pnas.org/content/111/24/8788" title="Experimental evidence of massive-scale emotional contagion through social networks">Experimental evidence of massive-scale emotional contagion through social networks</a></div><div class="message_embed_description">We show, via a massive ( N = 689,003) experiment on Facebook, that emotional states can be transferred to others via emotional contagion, leading people to experience the same emotions without their awareness. We provide experimental evidence that emotional contagion occurs without direct interaction between people (exposure to a friend expressing an emotion is sufficient), and in the complete absence of nonverbal cues.</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209031301" name="209031301"><div>2020-09-03 21:23:23</div></a></div><div class="text"><p>sounds intriguing</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209032809" name="209032809"><div>2020-09-03 21:40:13</div></a></div><div class="text"><p>Emotional contagion is an interesting phrase. It's sort of resonating with me <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209033452" name="209033452"><div>2020-09-03 21:47:44</div></a></div><div class="text"><p>makes me think of mass hysteria</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209033631" name="209033631"><div>2020-09-03 21:49:45</div></a></div><div class="text"><p>Ya actually good analogy. I was just reflecting on how hearing someone's relationship with another might affect how _you_ then start seeing that person</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209033748" name="209033748"><div>2020-09-03 21:50:51</div></a></div><div class="text"><p>right, for some reason I now hate this Joe guy</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209033897" name="209033897"><div>2020-09-03 21:52:37</div></a></div><div class="text"><p>Hahaha</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209033946" name="209033946"><div>2020-09-03 21:53:09</div></a></div><div class="text"><p>I like Joe. Met him a few times</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209033971" name="209033971"><div>2020-09-03 21:53:34</div></a></div><div class="text"><p>But I think shit talking tools and companies isn't helpful</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209033975" name="209033975"><div>2020-09-03 21:53:40</div></a></div><div class="text"><p><span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209033984" name="209033984"><div>2020-09-03 21:53:48</div></a></div><div class="text"><p>well, I guess it's just venting</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209033996" name="209033996"><div>2020-09-03 21:53:59</div></a></div><div class="text"><p>Ya, I blame Twitter really</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209034062" name="209034062"><div>2020-09-03 21:54:27</div></a></div><div class="text"><p>that's what it's for <span aria-label="rolling eyes" class="emoji emoji-1f644" role="img" title="rolling eyes">:rolling_eyes:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209034068" name="209034068"><div>2020-09-03 21:54:30</div></a></div><div class="text"><p>Makes it too easy to vent to a wider audience</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209034075" name="209034075"><div>2020-09-03 21:54:37</div></a></div><div class="text"><p>Right hahaha <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209034107" name="209034107"><div>2020-09-03 21:55:06</div></a></div><div class="text"><p>That's why I don't have one. I keep my random thoughts to my trusted circle of friends</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209034117" name="209034117"><div>2020-09-03 21:55:17</div></a></div><div class="text"><p>but considering that Cale is using the opportunity to build bridges, I guess it's not hopeless</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209034452" name="209034452"><div>2020-09-03 21:59:51</div></a></div><div class="text"><p>Ya, that's something I really appreciated. Cale's response was excellent and it made me curious to see what their use case was <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209036718" name="209036718"><div>2020-09-03 22:27:51</div></a></div><div class="text"><p><a href="https://en.wikipedia.org/wiki/List_of_mass_hysteria_cases">https://en.wikipedia.org/wiki/List_of_mass_hysteria_cases</a></p>
<p>this is some seriously freaky shit</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209038584" name="209038584"><div>2020-09-03 22:53:39</div></a></div><div class="text"><p>astute. yup, mass hysteria is directly related to this phenomenon. emotional contagion is ultimately based on this notion called 'affective vibes', if anybody wants to get deeper into it.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209038644" name="209038644"><div>2020-09-03 22:54:10</div></a></div><div class="text"><p>don't mind if I do!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209038807" name="209038807"><div>2020-09-03 22:56:57</div></a></div><div class="text"><p>knock yourself out. but ... "here be dragons" </p>
<p><a href="http://www.actualfreedom.com.au/richard/catalogue/vibes.htm">http://www.actualfreedom.com.au/richard/catalogue/vibes.htm</a> </p>
<p>(The "L" link expands on the topic)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209038852" name="209038852"><div>2020-09-03 22:57:56</div></a></div><div class="text"><p>ah, had a hunch it would be related to actualism <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209051208" name="209051208"><div>2020-09-04 03:13:18</div></a></div><div class="text"><p>Joe is fine, people are allowed to have opinions. I don't even think Joe would consider himself a proponent of "boring haskell" per se</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209051278" name="209051278"><div>2020-09-04 03:15:16</div></a></div><div class="text"><p>real talk: I have heard a LOT of really negative stories about people (where people are already professional haskell devs!) who where entirely unable to maintain the code left over from Obsidian, and is causing companies who contracted with them to swear off of haskell entirely, full stop</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209051285" name="209051285"><div>2020-09-04 03:15:42</div></a></div><div class="text"><p>this is the actual worst thing that can happen to the haskell community in terms of commercial adoption</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209051329" name="209051329"><div>2020-09-04 03:16:21</div></a></div><div class="text"><p>I understand you had a great time with them Srid and I understand that multiple people can have different opinions, but I just want to be explicit about what <em>other</em> people are saying about <em>their</em> experiences</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209051333" name="209051333"><div>2020-09-04 03:16:48</div></a></div><div class="text"><p>I have 0 real exposure to the obsidian stuff so I am mostly a neutral observer</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209051346" name="209051346"><div>2020-09-04 03:17:28</div></a></div><div class="text"><p>anywya, it doesn't matter anymore because notice that that is from May -- Joe has basically left Haskell and is doing Rust</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209051463" name="209051463"><div>2020-09-04 03:20:26</div></a></div><div class="text"><p>FWIW, I <em>AM</em> a proponent of "boring haskell", but my take is very nuanced: a huge portion of value is derived from the simple, boring parts of haskell, and those are actually fairly understandable from the POV of someone who is not constantly yak shaving their PLT</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209051764" name="209051764"><div>2020-09-04 03:28:10</div></a></div><div class="text"><p>The complexity of introducing something needs to be proportional to value received, and TBH I don't feel like that is true in a lot of cases. I feel like you enountered this Srid when you removed the path library from Rib -- but perhaps you would attribute it to something else</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209051863" name="209051863"><div>2020-09-04 03:30:33</div></a></div><div class="text"><p>(Please don't take this to mean I am against fancy types -- I have have spent a huge portion of my free time for the last like 4 years learning haskell and now finally have a Haskell Job, but this rule I apply is basically the formula for sane engineering. The same problems are felt elsewhere in the industry when people use Kubernetes when they really have no reason to use it and are not driving any value from it, and this is sinking projects. But, since K8s is not super "fringe" in the industry, it doesn't matter if places swear off of it, or if the project sinks they blame it something else.)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209052866" name="209052866"><div>2020-09-04 03:58:35</div></a></div><div class="text"><p>Also, one last thing to add, my personal tolerance for abstraction may be a little bit higher than some others, which is why I am still considering using reflex et al on some personal projects; everything is a tradeoff etc, and ghcjs does provide a lot of unique value. But I would really hesitate to use it in a profiessional setting where I am not in tight control over it, because of all kinds of issues</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4d7e5bf37281d41829f7b8a95d15292ff274c327?version=2"></a><div class="content"><a class="author">Vladimir Ciobanu</a><div class="metadata"><a href="#209064073" name="209064073"><div>2020-09-04 07:43:55</div></a></div><div class="text"><p>I wonder what happens to some Haskell folks, but it seems a trend that after having reached a certain level (different for each individual), they decide they know enough abstractions and using more than an arbitrary level of abstraction is 'fancy' or too complicated and nobody should be bothered learning.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209068078" name="209068078"><div>2020-09-04 08:38:19</div></a></div><div class="text"><p>That's interesting, I haven't seen that; do you have any examples? Or are you saying that about Joe? "Nobody should be bothered learning" is a very strong statement, especially for a group of people who actually enjoy learning these things. For example, I still learn these things, even though I actually think that its a safer bet to avoid a lot of them when doing production code. Job/production code is different from research/experimentation/learning code. The fact is that a lot of these "fancy" libraries are actually still research projects, and are by definition not well understood. What downsides are there to using a library? If you don't know what downsides, how can you be confident that its worth using it?</p>
<p>Anyway, I don't think that's what <span class="user-mention" data-user-id="264455">@Joe Kachmar</span>  was trying to say. Twitter is not the best place for nuanced discussions. Its necessary to interpet things from there with some charity. Its not the right forum for 10k essays on all the nuances of a topic.</p>
<p>ofc I don't know why he was looking at that library in the first place, I don't know what its being used for etc</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#209069229" name="209069229"><div>2020-09-04 08:51:56</div></a></div><div class="text"><p>From my personal experience, after few years of doing Haskell perception of available techniques can skew from "make everything typesafe" to "do bare minimum to keep things safe" - what we actually want I guess is weight features  based on mental/size burden they introduce and avoid premature abstraction/specification</p>
<p>I think of using new features/techniques like trying to build continuous shape from discrete blocks, where you have to understand every block you use/touch - in some situations, to fully fill in available space, one would have to approach "infinite" amounts of more and more precise blocks (which you can't keep in your head), but usually you can fill in most of the space effectively with a few of them. If you value blocks over shape itself, you may end up building wrong approximation that isn't helpful at all, but if you're too shy about making use of available blocks, you approximation may end up being too rough to be helpful. If you don't understand your given shape, you can completely miss it and may have to rebuild your whole approximation.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#209069585" name="209069585"><div>2020-09-04 08:56:13</div></a></div><div class="text"><p>Then, some features/extensions/techniques can be of varying "size" and difficulty - block that looks small at first glance, with high difficulty to understand may not usually be worth it, but it may happen that it precisely fits the empty space of high importance - then it suddenly becomes very useful</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4d7e5bf37281d41829f7b8a95d15292ff274c327?version=2"></a><div class="content"><a class="author">Vladimir Ciobanu</a><div class="metadata"><a href="#209070456" name="209070456"><div>2020-09-04 09:08:28</div></a></div><div class="text"><p>I would rather not call people out, but to be a bit more nuanced: the trend seems to be people figure out abstractions up to some arbitrary level, then they arbitrarily pick a different level (usually lower than the peak of their current understanding) and advocate against abstracting at a higher level than that. I've seen multiple people do this, usually by shaming or ridiculing more abstract code, or by advocating against premature abstraction. Joe is doing that in the twitter thread, but I've seen multiple people do this on Slack and twitter.</p>
<p>At the risk of being a complete fanboy, I am absolutely in love with <span class="user-mention" data-user-id="251120">@Sandy Maguire</span> 's introduction in ADD. We always operate at some level of abstraction when writing and reasoning about code. However, if the abstraction is leaky, we will likely either introduce bugs, or we will have to mentally keep track of these leaks and dance around them (which makes these abstractions a lot less useful, if not even worthless). The key here is finding the right abstraction, regardless of how "abstract" it is. If it so happens that the particular software problem we are trying to solve is precisely described by multi-categories, then that's the thing that should be used. Even if it might take unsuspecting (the non-CT intialized) weeks to fully grok.</p>
<p>Ideally these things are commented and links to papers/references are added. Some level of awareness is good to have when introducing complex concepts, in order to make code more accessible. But that's pretty much it -- don't sacrifice the quality and precision of the code for the sake of perceived simplicity.</p>
<p>Math is giving us these amazing abstraction tools, and we're barely scratching the surface. I'm more and more confident that our job as developers is closer to "field mathematicians" than anything else: understand the requirements and figure out the correct abstraction.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/8084ff35e892945a460a7ed9885325c7804e1b87?version=2"></a><div class="content"><a class="author">Rizary</a><div class="metadata"><a href="#209084161" name="209084161"><div>2020-09-04 11:53:53</div></a></div><div class="text"><p>Cale is active in haskell's discord channel. And there is #reflex-frp channel (although it's not too active)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209100015" name="209100015"><div>2020-09-04 14:30:24</div></a></div><div class="text"><p>From my personal experience, I loved writing Haskell but it was writing Haskell at a company that I realised you can still have people write shit code that will be complex and/or unsafe. I've witnessed a load of singleton magic that was unecessary for the project and caused a lot of people and newcomers (myself included) headaches. I've seen people use <code>fromJust</code> and I would have to request changes.<br>
I've also worked beside Obsidian folks as I was in Formation. Like every org, I've seen some good code from their individuals and some bad code :) I'm sure they could say the same for me <span aria-label="joy" class="emoji emoji-1f602" role="img" title="joy">:joy:</span> <br>
But I'll tell you what though, I've been writing Rust for the past year, everything is a <code>traverse</code>, and <code>Iterators</code> piss me off</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4d7e5bf37281d41829f7b8a95d15292ff274c327?version=2"></a><div class="content"><a class="author">Vladimir Ciobanu</a><div class="metadata"><a href="#209101231" name="209101231"><div>2020-09-04 14:41:47</div></a></div><div class="text"><p>Sure, there's plenty of bad abstractions in code, some of them are complex and others are simple. But just because some people pick the wrong (complex) abstractions, it doesn't mean we should all be avoiding it, or demonizing (complex) abstractions.</p>
<p>It's kind of like when some scientists are wrong, we decide we don't trust science anymore. I wonder if this is just Haskell's version of this particular global trend.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209102111" name="209102111"><div>2020-09-04 14:49:14</div></a></div><div class="text"><p>Oh ya. Sorry I wasn't advocating that abstraction is bad. I was just relaying my experience</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209102136" name="209102136"><div>2020-09-04 14:49:29</div></a></div><div class="text"><p>I'm knee deep in 7 Sketches. Abstraction is the road to glory</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209102479" name="209102479"><div>2020-09-04 14:52:05</div></a></div><div class="text"><p>I've read the first half twice, but on the train, so much didn't really stick for application <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209102649" name="209102649"><div>2020-09-04 14:53:32</div></a></div><div class="text"><p>I haven't applied it (yet!)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209102670" name="209102670"><div>2020-09-04 14:53:44</div></a></div><div class="text"><p>Doing the exercises is definitely helping me</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209102751" name="209102751"><div>2020-09-04 14:54:12</div></a></div><div class="text"><p>And having someone in my org help me out since he studied maths</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209102820" name="209102820"><div>2020-09-04 14:54:44</div></a></div><div class="text"><p>yeah I've gotta get myself one of those</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4d7e5bf37281d41829f7b8a95d15292ff274c327?version=2"></a><div class="content"><a class="author">Vladimir Ciobanu</a><div class="metadata"><a href="#209103733" name="209103733"><div>2020-09-04 15:01:09</div></a></div><div class="text"><p>Sorry Fintan, none of that is directed at you. I was just making sure I get the nuance of my point across.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209103784" name="209103784"><div>2020-09-04 15:01:35</div></a></div><div class="text"><p>Advocating against premature abstraction is <em>not</em> the same as advocating against abstraction.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209104002" name="209104002"><div>2020-09-04 15:02:57</div></a></div><div class="text"><p>The wrong abstraction is almost always worse than no abstraction at all, and that's the big thing</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209104063" name="209104063"><div>2020-09-04 15:03:22</div></a></div><div class="text"><p>Haskell is (just) software engineering, it is not fundamentally somehow different</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209105797" name="209105797"><div>2020-09-04 15:14:14</div></a></div><div class="text"><p>again, arguing that these people are against abstraction is to me totally nonsensical; these are haskell people. Language users are self-selecting; nobody is forced to learn Haskell. We've done the work to get to this point, and its not out of fear of abstraction, its out of curiosity. So saying that people are categorically against abstraction is just false, full-stop. </p>
<p>The pattern I keep seeing is that people who, like me, want to build things and see haskell as a success in industry are butting against code that we see as being unnecessarily complex and not providing value, and sinking projects and costing jobs. Formation is one company that apparently has sworn off of Haskell, because of the very reason I am talking about. </p>
<p>I find it very worrying that this seems to be such a hard point to get across. None of what I am trying to communicate is ground-breaking. This is (simply) software engineering.</p>
<p>Maybe I am just wasting my time with Haskell, I dunno</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209106740" name="209106740"><div>2020-09-04 15:21:02</div></a></div><div class="text"><p>There is a very big tendency to abstract-abstract-abstract in haskell, which is basically the same notion as what Java folks did with FactoryFactoryFactory. My implicit understanding of what Joe is pointing out in that thread is that library is another example of such a thing. Perhaps it isn't and I'm wrong, and perhaps all of those abstractions are entirely essential and useful for what they do, but somehow I doubt it</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209108536" name="209108536"><div>2020-09-04 15:35:21</div></a></div><div class="text"><p>So to understand, are you saying that people think there's an abstraction ceiling where people get fed up with how abstract it is? <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span> Or am I misreading?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209108600" name="209108600"><div>2020-09-04 15:35:51</div></a></div><div class="text"><p>that is not what I was trying to say, huh</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209108747" name="209108747"><div>2020-09-04 15:37:05</div></a></div><div class="text"><p>there is no ceiling; there is only abstractions, sometimes well-applied, sometimes misapplied</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/374affb4db58caa9507f265d7fdf03fe"></a><div class="content"><a class="author">Fintan Halpenny</a><div class="metadata"><a href="#209109512" name="209109512"><div>2020-09-04 15:43:54</div></a></div><div class="text"><p>I was digging in on the bit about Abstraction abstraction abstraction and the analogy to factory factory factory</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209109519" name="209109519"><div>2020-09-04 15:44:00</div></a></div><div class="text"><p>ohhh</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209109652" name="209109652"><div>2020-09-04 15:44:55</div></a></div><div class="text"><p>Abstractions form a lexicon within a community or other organization.</p>
<p>The failure of ‚Äúfancy Haskell‚Äù is that the lexicon is not made accessible to people who need to interact with those abstractions at some point in time.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209109836" name="209109836"><div>2020-09-04 15:46:26</div></a></div><div class="text"><p>You don‚Äôt need to eschew fancy Haskell, but you do need to provide extensive documentation for the things that aren‚Äôt in that lexicon. Additionally, it‚Äôs good engineering practice to try and look ahead to anticipate what the failure mode may be for a particular set of design decisions you‚Äôre making today.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209110129" name="209110129"><div>2020-09-04 15:49:39</div></a></div><div class="text"><p>Failure of highly abstract Haskell code, IME, has almost always been a combination of:</p>
<p>(1) the author not being as well versed in the trade offs associated with the abstractions they‚Äôre employing<br>
(2) there being an impedance mismatch between the author and audience for the particular set of abstractions being employed without the requisite documentation/teaching/onboarding materials <br>
(3) the author employed a set of overly general abstractions to a problem prematurely, and later (typically after the author left) it becomes entirely unclear as to why that generality exists and what the original problem it solved was</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#209110323" name="209110323"><div>2020-09-04 15:51:35</div></a></div><div class="text"><p>I think everyone is missing the forest for the trees here. The question isn't whether or not abstraction is warranted or not. It's not about should we put abstraction into our codebases. As far as I can tell, there are two different phenomena here that are being muddled.</p>
<p>1) Haskell allows a few orders of magnitude more abstraction than is feasible in any mainstream language. meaning that people when they come to hs get their first glimpse of what could be possible. Nobody is good at abstraction at birth; they need to train those muscles, and that involves writing code. This is like going to the gym and doing weird exercises that aren't useful in everyday life. No, but they train your mind and make you better at abstraction. Unfortunately, this leaves behind code artefacts.</p>
<p>2) We all have horror stories about "idiot" coworkers. Everybody writes terrible code all of the time. We're all learning every day, and are hopefully all embarassed by code we wrote six months ago. This is natural and the way of the world. Our ability to design systems well stems from having <em>put in the effort</em> and gone to the gym of doing unnecessarily abstract things just for practice. All of this is to say, you need to have gone through the insane abstraction tower <em>in order to write abstractions that aren't insane.</em> Unfortunately, like someone at the gym on their first day, anybody who hasn't put in that time isn't in a position to judge whether or not the abstractions are warranted. This is <em>especially</em> so of bystanders trying to dunk on you on twitter.</p>
<p>I think what we'd all like is for people just to do those abstraction exercises on their own time, in their own projects, with big disclaimers as to what it is. If you see the disclaimer, you're not allowed to get mad at someone for overabstracting, like you wouldn't yell at someone at the gym doing a hyperspecialized exercise. Followed up with a rule of thumb that you shouldn't use any technique at work that you've learned in the last six months, because we collectively agree that it takes at least six months to develop the wisdom about "when" after learning "how."</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209110545" name="209110545"><div>2020-09-04 15:53:45</div></a></div><div class="text"><p>I think it would be nice if people didn‚Äôt have to do that sort of thing on their own time, but yeah generally I agree with the 6 month thing.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209110670" name="209110670"><div>2020-09-04 15:54:42</div></a></div><div class="text"><p>so here's a couple of recent examples I encountered in some libraries. </p>
<p>There was one time I saw where a library was using a typeclass when the typeclass instances were not going to be used polymorphically. Literally all that was necessary was passing a single <code>a -&gt; IO ()</code> type. I cannot think of any reason why the go-to would be "create a typeclass here" except for premature abstraction or a love of complexity for its own sake. This creates problems because I need to add a bunch of boilerplate instead of just passing in a funciton, and the whole typeclass itself is very confusing because what is the point of it? It just makes me think I am missing something, and then end up frustrated when it turns out that no, I was not missing something.</p>
<p>Another time is I saw someone using a GADT in a situation where it was entirely semantically equivalent to using a normal sum type. This is the same issue as above; what was the point of using it? Was i crazy or what?</p>
<p>On the flip side I have heard of people encountering many instances of like <code>Either (Ether Foo Bar) Baz</code> instead of a creating a boring sum type, which creates all kind of additional code complexity. This really provides no value and increases code complexity</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209110674" name="209110674"><div>2020-09-04 15:54:44</div></a></div><div class="text"><p>I‚Äôd say it should be 6 months of using these sorts of things in some active capacity, and not ‚ÄúI learned about recursion schemes at a conference 6 months ago and now I‚Äôm putting them into practice on a critical path‚Äù</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#209110684" name="209110684"><div>2020-09-04 15:54:50</div></a></div><div class="text"><p>Agreed. Most jobs <em>are</em> stupid and boring, and I suspect most of us are balancing a "what's best for the project" mindset against "what's best for my career" mindset, in which the learning part is always going to win.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#209110989" name="209110989"><div>2020-09-04 15:57:17</div></a></div><div class="text"><p><span class="user-mention" data-user-id="252949">@Joel McCracken</span> that first one sounds to me like it was written by someone new to Haskell who is still thinking in OO terms and thinks that haskell classes are how you do classes.</p>
<p>when you say GADT do you mean an actual GADT or just using GADT syntax?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209111004" name="209111004"><div>2020-09-04 15:57:26</div></a></div><div class="text"><p>GADT syntax</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209111032" name="209111032"><div>2020-09-04 15:57:43</div></a></div><div class="text"><p>and thinking that it was somehow adding magical typesafety</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#209111117" name="209111117"><div>2020-09-04 15:58:10</div></a></div><div class="text"><p>gadt syntax is nice</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209111166" name="209111166"><div>2020-09-04 15:58:36</div></a></div><div class="text"><p>I like the syntax fine, i don't like the magical typesafety thinking</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#209111206" name="209111206"><div>2020-09-04 15:58:58</div></a></div><div class="text"><p>hard to say more on the topic without any details :)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209111429" name="209111429"><div>2020-09-04 16:00:18</div></a></div><div class="text"><p>yeah I don't want to call anyone out. These are hard things to discuss</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#209111597" name="209111597"><div>2020-09-04 16:01:44</div></a></div><div class="text"><p>I think this discussion would be SIGNIFICANTLY more valuable for everyone involved if everyone brought a few examples of perceived too-abstract grievances and we looked at them as a community, rather than just all talking past one another. I suspect everyone would be amazed by just how much people would agree on what's good and bad.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#209111786" name="209111786"><div>2020-09-04 16:03:16</div></a></div><div class="text"><p>Let's see if we can agree on the object level before working on the meta level. Because if not the entire argument is moot and unsettable and we're just wasting our time shouting into the abyss.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209111856" name="209111856"><div>2020-09-04 16:03:54</div></a></div><div class="text"><p>well, we have people in the haskell community who think commercial adoption is a worthwhile goal</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#209111968" name="209111968"><div>2020-09-04 16:04:48</div></a></div><div class="text"><p>sorry, i fail to see the relevance of that statement</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209112368" name="209112368"><div>2020-09-04 16:08:40</div></a></div><div class="text"><p>Healthy communities are dependent on the ability for there to be some _norm_ on topics such as these.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#209112410" name="209112410"><div>2020-09-04 16:09:25</div></a></div><div class="text"><p>what do you mean, joe?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209112536" name="209112536"><div>2020-09-04 16:10:34</div></a></div><div class="text"><p>I mean that requiring an object-level analysis about the barriers that certain abstractions pose towards adoption of Haskell in different settings is a potentially useful conversation, but the fact that we (the Haskell community) keep having it is a bad sign</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209112586" name="209112586"><div>2020-09-04 16:11:06</div></a></div><div class="text"><p>it means that we have difficulty reaching consensus on what good ‚Äúground truths‚Äù are when using the language in different settings</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#209112689" name="209112689"><div>2020-09-04 16:12:17</div></a></div><div class="text"><p>tbh i have never seen it. I just keep saying people saying "abstraction is bad" or "no, abstraction is good you idiot" without anyone actually pointing to examples of wtf they mean</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209112735" name="209112735"><div>2020-09-04 16:12:50</div></a></div><div class="text"><p>Anyone saying ‚Äúabstraction is bad‚Äù and ‚Äúabstraction is good‚Äù outside of Twitter or some shit isn‚Äôt having a conversation worth participating in</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#209112819" name="209112819"><div>2020-09-04 16:13:50</div></a></div><div class="text"><p>i mean, look at all the ink spilled in this thread</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#209112887" name="209112887"><div>2020-09-04 16:14:16</div></a></div><div class="text"><p>this is exactly the conversation we're both participating in</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209112908" name="209112908"><div>2020-09-04 16:14:29</div></a></div><div class="text"><p>Introducing novel abstractions to a setting/community/organization/codebase that needs to be developed on collaboratively over time, without adequate documentation, justification, or common ground along contributors is considered harmful.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#209112914" name="209112914"><div>2020-09-04 16:14:36</div></a></div><div class="text"><p>which i will take as a good opportunity to get off the internet and go do something more valuable with my day. love you all.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209112927" name="209112927"><div>2020-09-04 16:14:46</div></a></div><div class="text"><p>so i was referring to a statement early in the "boring haskell" discussion something like "i don't see why we should care about commercial adoption, I care about experimenting with things!" This is relevant because for such a person, arriving at a consensus re: when something is appropriate for a commercial setting is going to be nearly impossible</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209112989" name="209112989"><div>2020-09-04 16:15:20</div></a></div><div class="text"><p>the thing that concerns me is people ending up in the setting I described in my previous message and coming away with the notion that abstraction is bad</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#209112992" name="209112992"><div>2020-09-04 16:15:25</div></a></div><div class="text"><p><span class="user-mention" data-user-id="252949">@Joel McCracken</span> absolutely. but that means it is explicitly worth calling out so nobody is talking past one another</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209113016" name="209113016"><div>2020-09-04 16:15:38</div></a></div><div class="text"><p>Go is my enemy here, not fancy Haskell.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209113414" name="209113414"><div>2020-09-04 16:19:13</div></a></div><div class="text"><p>Agreed Sandy; part of the problem is that I think a lot of things in this discussion are left unsaid and implicit. I've been meaning to write up something more thorough, but time and constraints exist. In the meantime I'm just trying to help others who may not have a fundamentally dissimilar point of view understand more of the overall discussion from my POV</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209114353" name="209114353"><div>2020-09-04 16:28:15</div></a></div><div class="text"><p>Anyway, last bit I‚Äôll comment on here and _only_ because it was mentioned upthread when Srid called me out</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209114716" name="209114716"><div>2020-09-04 16:32:47</div></a></div><div class="text"><p>My frustration with Obsidian stems from the fact that I‚Äôve witnessed their work directly lead to one company abandoning Haskell and Nix entirely and another company abandoning Nix and the developers fighting to keep Haskell, all of this due to poor engineering practice.</p>
<p>Beyond that, they overwork and underpay their employees to take advantage of the fact that people are generally happy to write Haskell, which really rubs me the wrong way in this industry.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#209117270" name="209117270"><div>2020-09-04 16:59:06</div></a></div><div class="text"><p>Even though I think most of the drama related to simple haskell stems from misunderstanding and subjective experiences, I would still say there's some "design tension" between practical and academic part of community - the practical one wants stability and tested, well-defined feature set, the other one wants quick iteration and possibly feature redundancy that let's them explore new ideas. Problem is, while trying to have these in one language makes people fighting, splitting these into two communities/languages can make either of those drift further from some common goal of maintaining a good language.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/1e25e79b0f430201d7f557a2a7fc5e88e2d43015?version=8"></a><div class="content"><a class="author">jkachmar</a><div class="metadata"><a href="#209118490" name="209118490"><div>2020-09-04 17:09:26</div></a></div><div class="text"><p>I‚Äôll defer to Bryan O‚ÄôSullivan on this, since he‚Äôs very well suited to straddle this academic/industrial divide: <a href="https://old.reddit.com/r/haskell/comments/2olrxn/what_is_an_intermediate_haskell_programmer/cmohivk/">https://old.reddit.com/r/haskell/comments/2olrxn/what_is_an_intermediate_haskell_programmer/cmohivk/</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://old.reddit.com/r/haskell/comments/2olrxn/what_is_an_intermediate_haskell_programmer/cmohivk/" style="background-image: url(https://www.redditstatic.com/new-icon.png)"></a><div class="data-container"><div class="message_embed_title"><a href="https://old.reddit.com/r/haskell/comments/2olrxn/what_is_an_intermediate_haskell_programmer/cmohivk/" title="What is an intermediate haskell programmer?">What is an intermediate haskell programmer?</a></div><div class="message_embed_description">This list is utterly bonkers. I agree with about 10% of it, and think the rest is shamefully bad advice. It mixes points that are almost trivial...</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#209126153" name="209126153"><div>2020-09-04 18:26:46</div></a></div><div class="text"><p>What a long and interesting thread! Zulip for the win!</p>
<p><span class="user-mention silent" data-user-id="251120">Sandy Maguire</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209110323">said</a>:</p>
<blockquote>
<p>2) We all have horror stories about "idiot" coworkers.</p>
</blockquote>
<p>Dropping by to point out that these stories make me so mad. Do people who share these stories also believe that their farts don't stink?</p>
<p>It's good to remember that your co-workers are people who are doing their best, just as you are, and deserve every bit of respect as you do. If you're going to judge someone based on the code they write don't be surprised if you find someone calling you an idiot some day.</p>
<p>It's important to be constructive when working on a team. Resist the urge to blame the person and honestly demonstrate what the error is in the abstraction and how it could be improved. They might simply not have had the same experiences as you. Don't be stingy with your knowledge and offer them concrete suggestions on what they could change to improve that piece of code that makes you cringe.</p>
<p>And don't let yourself be put down or believe that you're an idiot simply because you hear grumpy people rant about their, "idiot co-workers."</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#209127380" name="209127380"><div>2020-09-04 18:38:59</div></a></div><div class="text"><p>That's not to say that some people aren't simply mean or do things that harm us... but let's not let <em>code</em> be what divides us. :)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#209127647" name="209127647"><div>2020-09-04 18:41:28</div></a></div><div class="text"><p>And the original tweet... well that sounds like a personal decision.</p>
<p>I don't know that "complex" Haskell is what turns people away in droves. If that was all it took I don't think there would be many employed C++ programmers. <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#209127793" name="209127793"><div>2020-09-04 18:42:34</div></a></div><div class="text"><p>Though it would be nice if more people recognized that Haskell code is code and sometimes we can come up with patterns and misuse features like the best of them.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209130058" name="209130058"><div>2020-09-04 19:04:06</div></a></div><div class="text"><blockquote>
<p><span class="user-mention silent" data-user-id="252949">Joel McCracken</span> That's interesting, I haven't seen that; do you have any examples?</p>
</blockquote>
<p>Myself LOL. A while ago I was working on a project that involved type level programming. I had never done type level programming, there was a belief in me that "I ain't good for it". I decided just do it anyway, and learn what's needed in the process. </p>
<p>Our own limiting beliefs prevent us from learning further.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209131359" name="209131359"><div>2020-09-04 19:16:12</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="252949">Joel McCracken</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209111429">said</a>:</p>
<blockquote>
<p>yeah I don't want to call anyone out. These are hard things to discuss</p>
</blockquote>
<p>If that's from code I wrote, I won't get offended. Neuron uses GADTs, but that's only because you can't do that with ADTs.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209131789" name="209131789"><div>2020-09-04 19:21:09</div></a></div><div class="text"><blockquote>
<p>My frustration with Obsidian stems from the fact that I‚Äôve witnessed their work directly lead to one company abandoning Haskell and Nix entirely and another company abandoning Nix and the developers fighting to keep Haskell, all of this due to poor engineering practice.</p>
</blockquote>
<p>Just 2 companies? I consider that _success_ - as that means every other client of Obsidian is happy with Haskell!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#209132383" name="209132383"><div>2020-09-04 19:27:55</div></a></div><div class="text"><p>I've read about teams abandoning Lisp or C++ or X... it happens. There's a lot of interesting context around those decisions.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209132638" name="209132638"><div>2020-09-04 19:30:30</div></a></div><div class="text"><p>I don't think I have the permission to talk about details, but I'll just state that teams decide to give up on $tech for all sorts of reasons. We can't appraise the reasons objectively without the full context, like you say. Otherwise it is just gossip and hearsay.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209161439" name="209161439"><div>2020-09-05 04:41:44</div></a></div><div class="text"><p>Srid I wasn't talking about you FWIW</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4d7e5bf37281d41829f7b8a95d15292ff274c327?version=2"></a><div class="content"><a class="author">Vladimir Ciobanu</a><div class="metadata"><a href="#209168685" name="209168685"><div>2020-09-05 08:53:42</div></a></div><div class="text"><p><span class="user-mention" data-user-id="252949">@Joel McCracken</span> , I think this is where we fundamentally disagree: "The wrong abstraction is almost always worse than no abstraction at all, and that's the big thing". There's no such thing as "no abstraction", since code is just language to represent _something_, so when it's no abstraction, it's actually a bad or leaky abstraction which is pretty much the same thing as 'wrong abstraction'. One could argue that complex wrong abstractions are worse than simple wrong abstractions, and I'd probably agree to that. But they're both wrong, and both have their cost/toll.</p>
<p>What I'm advocating for is "correct" abstractions, regardless of their complexity. What I perceive simple haskell to be about is a bias towards simpler abstractions even if they might be "a bit" leaky.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209196407" name="209196407"><div>2020-09-05 21:17:55</div></a></div><div class="text"><p>Really interesting point. Here's how I'd respond: </p>
<p>Abstractions are always built upon other abstractions. So in the choice of<br>
having to deal with abstraction layer N or abstraction layer N + M, and<br>
somewhere in N + M is a bad abstraction, then it is generally preferable to use<br>
N, because what happens is that in order to figure out how to solve a problem,<br>
you need to understand N, N + 1, N + 2 ... N + M layers, comprehend where the<br>
actual issue exists, and then resolve it (often by improving one other<br>
abstraction).  </p>
<p>In engineering, it is very hard to know that you are at the "right"<br>
abstraction. We are often discovering what the correct solution should be *as we<br>
are implementing it*. So there is a dialog between the requirements and whatever<br>
the "correct" implementation is. We built something, we show it to stake<br>
holders. They give us feedback, and we iterate.<br>
Hence it is not generally possible to predict what will be the right abstraction<br>
and what will be the wrong one. </p>
<p>I think we've all gone down the path of implementing something we think is going<br>
to be excellent, only to realize down the line that actually we misunderstood<br>
what was necessary. However, sometimes we don't understand this until we've<br>
already had the abstraction in our system for years and years, others have built<br>
upon it, and its incredibly hard to change.</p>
<p>Because of the nature of the way we handle pure FP abstractions, generally we<br>
are trying to <em>limit</em> the possiblities of what code can do. If you look at pure<br>
code, evaluating it should not have side effects. If a functino looks like:<br>
<code>foo :: Monoid a =&gt; a -&gt; a -&gt; a</code>, you know that there really is very few things<br>
that <code>foo</code> could do. This is actually great because it lifts a huge burden off<br>
of us as programmers, making it much easier to reason about our code. But, by<br>
this nature, it also <em>limits</em> what we might need this function to do in the<br>
future. </p>
<p>IME this is actually one of the things that is most likely to sink a software<br>
project -- an abstraction gets embedded so deeply within a system that it is<br>
very hard to change, and so eventualy the entire system needs to be replaced. </p>
<p>By choosing an abstraction, you are hoping that abstraction will be right in the<br>
future. That may or may not be correct, but if it turns out to be incorrect, you<br>
need to change the abstraction, possibly breaking something, or replace the<br>
abstraction, understanding the requirements of all the code that used that<br>
abstraction and changing that code that relied on the abstraction to handle the<br>
new circumstance (Indeed, I have been in situations where<br>
nobody really knew how a certain thing is <em>supposed</em> to behave, so it was<br>
extremely hard to replace it!)</p>
<p>If I had a crystal ball and could see the entirety of the future of a project<br>
and then pinpoint what the right abstraction is, I would do so, and use it.<br>
Sadly, I don't, and can't.</p>
<p>In order to choose a good abstraction, one needs to first understand what<br>
the possible abstractions are in a situation, what<br>
are the relative weaknesses and strengths of each, what will become harder to<br>
handle in the future if requirements change, what your team will understand/what<br>
the cost will be for the team to learn it, etc. This is really tricky and<br>
requires a good bit of wisdom and experience and ability to balance trade-offs.<br>
And it requires a pretty good understanding of the problem you are solving.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#209200703" name="209200703"><div>2020-09-05 23:44:14</div></a></div><div class="text"><p>idk if this is a tangent that fits into the conversation, but I think we often talk about "the" abstraction that applies to a problem, as if there's only one perspective that is relevant to a given problem (e.g. a super duper general one vs a concrete one, or a "mathy" one vs a "practical" one, or this _one_ vs that _one_). what I wish there was more support for in languages was the ability to view a situation from multiple perspectives, i.e. to change your abstraction (and hence your abstraction level) seamlessly.</p>
<p>e.g. suppose you start with some simple, highly concrete type and write a program in it, and then you realize that if you only tweaked the type a little bit, it would be an instance of some existing typeclass and let you DRY up your code a bit. the problem is you can't just seamlessly do this without breaking the original program, even if it's morally a strict generalization. so every part of the code must be aware of the abstraction in all of its super duper general glory, or you must partition the code by what parts are wrapped in what newtypes. this is a problem if you want to seamlessly move between abstractions (maybe there is more than one useful way of looking at the problem!) and between levels of abstractions (maybe the user of your HTTP library doesn't need to know your <code>get</code> operation is implemented as the doogleberry of the floomenoid algebra!)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#209254958" name="209254958"><div>2020-09-07 03:55:53</div></a></div><div class="text"><p><span class="user-mention" data-user-id="252949">@Joel McCracken</span>  </p>
<blockquote>
<p>It is not generally possible to figure out the right abstraction</p>
</blockquote>
<p>I feel like this is kind of the core of the disagreement between camps.</p>
<p>It reads to me like you simply accept you'll likely never get the right abstraction, use N because it's replacable, and move on the the next problem?</p>
<p>That doesn't seem right to me and seems like one would never exercise their abstraction muscle.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#209255972" name="209255972"><div>2020-09-07 04:22:27</div></a></div><div class="text"><p><span class="user-mention" data-user-id="264455">@jkachmar</span>  </p>
<blockquote>
<p>I‚Äôll defer to Bryan O‚ÄôSullivan on this, since he‚Äôs very well suited to straddle this academic/industrial divide: <a href="https://old.reddit.com/r/haskell/comments/2olrxn/what_is_an_intermediate_haskell_programmer/cmohivk/">https://old.reddit.com/r/haskell/comments/2olrxn/what_is_an_intermediate_haskell_programmer/cmohivk/</a></p>
</blockquote>
<p>I can't really defer to a position of:</p>
<blockquote>
<p>A noisy subsdt of silly people has collectively gone nuts for abstractions that provide little value other than making them feel special. It is most disappointing.</p>
</blockquote>
<p>Unless I already agreed with it.</p>
<p>A statement like that should have at least a single example. What's more the disagreement that follows looks kinda similar to disagreements we still see.</p>
<blockquote>
<p>I was tempted to agree with you, but then I reviewed the list again and I can't find anything "hard to master and hardly ever useful". - sclv</p>
</blockquote>
<p>I feel hopeful about <span class="user-mention" data-user-id="270069">@TheMatten's bot</span> and <span class="user-mention" data-user-id="252949">@Joel McCracken</span>'s attempts to have more concrete examples in this conversation about the value of abstraction <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209312824" name="209312824"><div>2020-09-07 16:42:01</div></a></div><div class="text"><p>Yea, +1 for concrete examples.  Otherwise, how do we know that we are all on the same page when we are doing <em>cough</em> abstract <em>cough</em> talk.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209313035" name="209313035"><div>2020-09-07 16:44:35</div></a></div><div class="text"><p>From that link (a thread made 5 years ago, the time before I learned Haskell):</p>
<blockquote>
<p>I stay away from GADTs and rank N types on purpose in production code.</p>
</blockquote>
<p>So here we have an example. Is this a wise approach? Why avoid GADTs, when they are so useful in some cases? There are legitimate cases where you can't use ADTs anymore, and have to reach out for GADTs for type safety. Concrete example is neuron's <code>ZettelQuery</code> type, where the result type of the query is unified with the query constructor.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209313077" name="209313077"><div>2020-09-07 16:45:27</div></a></div><div class="text"><p>Now, it is perfectly okay to begin with ADTs in one's project. But there may come a point ADTs don't work anymore. What would someone do at this point?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209313094" name="209313094"><div>2020-09-07 16:45:55</div></a></div><div class="text"><p>I felt like putting an artificial limit like "I won't use GADTs" will make the code look like Elm.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209313195" name="209313195"><div>2020-09-07 16:46:46</div></a></div><div class="text"><p>Regardless, it would be interesting to see a case study on how a real-world code would look with ADT vs with GADT, comparing their pros / cons, so as to give weight to such an argument not to use GADTs in production. Otherwise, it borders on some FUDsque subjective opinion.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#209313340" name="209313340"><div>2020-09-07 16:48:49</div></a></div><div class="text"><p>One great use case for GADTs I've recently encountered - queries in Halogen, where different queries expect different return types, but you still want to represent them by single datatype - PureScript doesn't have GADTs yet, so they instead use these funky <code>Query :: (SomeType -&gt; a) -&gt; Query a</code> constructors</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209313911" name="209313911"><div>2020-09-07 16:55:24</div></a></div><div class="text"><p>my impression, not only in Haskell, is that people are intimidated by unusual concepts. What's usual is grown organically and influenced by what is consensus or popular at the time when a given programmer has their basic knowledge and habits shaped.</p>
<p>Now this intimidation does not correlate with complexity at all, in my experience, even though people see it as such, and I think the purpose of that is to euphemize and give themselves a reason not to commit to changing their views in order to save on cost. Everyone has a limited amount of time in order to earn money and one needs to select what is productive to learn.</p>
<p>I think I experienced some of this earlier in my life, but that changed in the recent years.<br>
For example, when I first discovered Polysemy, I found it to be incredibly intimidating, and not because there was a lot of abstract ceremony involved in order to use it, but because it just used semantics that I hadn't encountered yet and because it seemed so incredibly professional that I had a feeling of inadequacy.<br>
However, since I had already gotten used to this intimidation barrier, I still tried it out and learned it pretty quickly, since it is enormously ergonomic and sensible, and I learned that it offered a kind of simplicity that is on a completely different level than how you would ascribe simplicity to more "basic" code. But if you do not understand that simplicity, it will be perceived as complexity.</p>
<p>This just as a concrete account of how this dissonance might be structured.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#209314114" name="209314114"><div>2020-09-07 16:57:37</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="251311">Sridhar Ratnakumar</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209313195">said</a>:</p>
<blockquote>
<p>Regardless, it would be interesting to see a case study on how a real-world code would look with ADT vs with GADT, comparing their pros / cons, so as to give weight to such an argument not to use GADTs in production. Otherwise, it borders on some FUDsque subjective opinion.</p>
</blockquote>
<p>Okay, here's an "Algebraic data type" from Real-World Haskell:</p>
<div class="codehilite"><pre><span></span><code><span class="kr">type</span> <span class="kt">CardHolder</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">type</span> <span class="kt">CardNumber</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">type</span> <span class="kt">Address</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>

<span class="kr">data</span> <span class="kt">BillingInfo</span> <span class="ow">=</span> <span class="kt">CreditCard</span> <span class="kt">CardNumber</span> <span class="kt">CardHolder</span> <span class="kt">Address</span>
                 <span class="o">|</span> <span class="kt">CashOnDelivery</span>
                 <span class="o">|</span> <span class="kt">Invoice</span> <span class="kt">CustomerID</span>
                   <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</code></pre></div>


<p>Here it is in GADT form I think I got right (but I'm actually on painkillers from surgery so lol sanity check me):</p>
<div class="codehilite"><pre><span></span><code><span class="kr">data</span> <span class="kt">BillingInfo</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="kt">CreditCard</span> <span class="ow">::</span>  <span class="kt">CardNumber</span> <span class="ow">-&gt;</span> <span class="kt">CardHolder</span> <span class="ow">-&gt;</span> <span class="kt">Address</span> <span class="ow">-&gt;</span> <span class="kt">BillingInfo</span> <span class="n">a</span>
  <span class="kt">CashOnDelivery</span> <span class="ow">::</span> <span class="kt">BillingInfo</span> <span class="n">a</span>
  <span class="kt">Invoice</span> <span class="ow">::</span> <span class="kt">CustomerID</span> <span class="ow">-&gt;</span> <span class="kt">BillingInfo</span> <span class="n">a</span>
</code></pre></div>


<p>From just this I don't see any pros or cons, maybe I or someone else can add some pattern matching examples and it'll become obvious later.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209314387" name="209314387"><div>2020-09-07 17:00:56</div></a></div><div class="text"><p>This sounds like a nice example to add to my notes! </p>
<blockquote>
<p>For example, when I first discovered Polysemy, I found it to be <strong>incredibly intimidating</strong>, and not because there was a lot of abstract ceremony involved in order to use it, but because it just used semantics that I hadn't encountered yet and because it seemed so incredibly professional that I had a <strong>feeling of inadequacy</strong>.</p>
</blockquote>
<p><a href="https://www.srid.ca/852310bb.html">https://www.srid.ca/852310bb.html</a></p>
<blockquote>
<p>However, since I had already gotten used to this intimidation barrier, I still tried it out and <strong>learned it pretty quickly</strong></p>
</blockquote>
<p><a href="https://www.srid.ca/47ee6284.html">https://www.srid.ca/47ee6284.html</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://www.srid.ca/47ee6284.html" style="background-image: url(https://cpb-us-e1.wpmucdn.com/sites.dartmouth.edu/dist/8/197/files/2017/05/Growth-Mindset_Copyright-Big-Change1.jpg)"></a><div class="data-container"><div class="message_embed_title"><a href="https://www.srid.ca/47ee6284.html" title="Growth Mindset">Growth Mindset</a></div><div class="message_embed_description">People with a ‚Äúgrowth mindset‚Äù believe that they can acquire any given
ability provided they invest effort[1] as well as actively seek and
welcome feedback (positive or negative) especially when stuck, as
contrast to having a ‚Äúfixed mindset‚Äù.

[1] Effort alone is insufficient. See Carol Dweck Revisi</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#209314543" name="209314543"><div>2020-09-07 17:02:39</div></a></div><div class="text"><p><span class="user-mention" data-user-id="325194">@codygman</span> I think your example doesn't have any reason to use GADTs (other than nicer syntax, which is subjective)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209314562" name="209314562"><div>2020-09-07 17:03:06</div></a></div><div class="text"><p>Yes, because <code>a</code> is not used (and nice syntax surely is never a reason to use GADTs?)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209314680" name="209314680"><div>2020-09-07 17:05:30</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="251311">Sridhar Ratnakumar</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209314387">said</a>:</p>
<blockquote>
<p>This sounds like a nice example to add to my notes! </p>
<blockquote>
<p>For example, when I first discovered Polysemy, I found it to be <strong>incredibly intimidating</strong>, and not because there was a lot of abstract ceremony involved in order to use it, but because it just used semantics that I hadn't encountered yet and because it seemed so incredibly professional that I had a <strong>feeling of inadequacy</strong>.</p>
</blockquote>
<p><a href="https://www.srid.ca/852310bb.html">https://www.srid.ca/852310bb.html</a></p>
<blockquote>
<p>However, since I had already gotten used to this intimidation barrier, I still tried it out and <strong>learned it pretty quickly</strong></p>
</blockquote>
<p><a href="https://www.srid.ca/47ee6284.html">https://www.srid.ca/47ee6284.html</a></p>
</blockquote>
<p>yeah, you kind of have to balance the "sunk cost" protection impulse and the inadequacy against the desire to grow, I can empathize that this is hard</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209314751" name="209314751"><div>2020-09-07 17:06:20</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="251311">Sridhar Ratnakumar</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209314562">said</a>:</p>
<blockquote>
<p>Yes, because <code>a</code> is not used (and nice syntax surely is never a reason to use GADTs?)</p>
</blockquote>
<p>I think I've seen you get this answer in a github issue <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209314877" name="209314877"><div>2020-09-07 17:08:20</div></a></div><div class="text"><p>it was probably not a good decision to include <code>ADT</code> in the name, suggesting that they're just better replacements for normal ADTs</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#209314878" name="209314878"><div>2020-09-07 17:08:24</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="260881">Torsten Schmits</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209313911">said</a>:</p>
<blockquote>
<p>my impression, not only in Haskell, is that people are intimidated by unusual concepts. What's usual is grown organically and influenced by what is consensus or popular at the time when a given programmer has their basic knowledge and habits shaped.</p>
<p>Now this intimidation does not correlate with complexity at all, in my experience, even though people see it as such, and I think the purpose of that is to euphemize and give themselves a reason not to commit to changing their views in order to save on cost. Everyone has a limited amount of time in order to earn money and one needs to select what is productive to learn.</p>
</blockquote>
<p>You and I are on the same page here... the problem comes when someone else starts pruning things you've proven are valuable as "not productive to learn" and start spreading FUD about them not being productive to learn. I think that's one effect stemming out of these basic conversations and why I don't feel like the "boring Haskell" or "Simple Haskell" movements are "basically harmless".</p>
<p>If it were just a matter of "they want to program with that and say it's the best way" and it didn't negatively affect the view of what I'm beginning to refer to as "first principles thinking", software design in a style like Algebra Driven Design, or software that moves more invariants into the type system... I could simply ignore it.</p>
<p>I think though that others see the negative effect of those movements though and that's why there is a clash. None of this helps feel closer to a solution, it's just sort of writing out my thoughts though sadly.</p>
<blockquote>
<p>I think I experienced some of this earlier in my life, but that changed in the recent years.<br>
For example, when I first discovered Polysemy, I found it to be incredibly intimidating, and not because there was a lot of abstract ceremony involved in order to use it, but because it just used semantics that I hadn't encountered yet and because it seemed so incredibly professional that I had a feeling of inadequacy.<br>
However, since I had already gotten used to this intimidation barrier, I still tried it out and learned it pretty quickly, since it is enormously ergonomic and sensible, and I learned that it offered a kind of simplicity that is on a completely different level than how you would ascribe simplicity to more "basic" code. But if you do not understand that simplicity, it will be perceived as complexity.</p>
<p>This just as a concrete account of how this dissonance might be structured.</p>
</blockquote>
<p>Yes! Exactly. The kind of simplicity that seems to be sold in mainstream programming is very much simplicity in the small and super locally. Ironically, things like Polysemy focus on the more pragmatic real world concern of simplicity across the majority of the application. I have a blog post along these lines that'll "be done any day now" and one thing I might float or turn it into is "haskell from the beginning with Polysemy" and I think that could be dramatically simpler... I do wonder if this will end up on r/programmingcirclejerk though :D</p>
<p>I think there is more to discover and discuss about simplicity in software in general... I don't feel satisfied with current definitions.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#209315107" name="209315107"><div>2020-09-07 17:12:08</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="254032">Georgi Lyubenov // googleson78</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209314543">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="325194">codygman</span> I think your example doesn't have any reason to use GADTs (other than nicer syntax, which is subjective)</p>
</blockquote>
<p>I think I agree, but I'm actually not sure <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span> </p>
<p>I was attempting to create a "pointless usage of GADT" like I thought Bryan O Sullivan might have been talking about or critics might take issue with. That way I could understand the comment "I stay away from GADTs and rank N types on purpose in production code.". I've also seen other unsupported "avoid GADTs" comments throughout the internet and I'd like to be able to understand their criticism.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209315233" name="209315233"><div>2020-09-07 17:14:03</div></a></div><div class="text"><p><span class="user-mention" data-user-id="325194">@codygman</span> yeah, teaching that to beginners is probably an order of magnitude more efficient than to full-stack developers.</p>
<p>In any case, my experience with the Hackage ecosystem has suggested that what lots of libraries are missing is good UX. not only the docs, but how the integration points are designed. Not adressing this at Polysemy, since it has a pretty reasonable proportionality of age, accessibility and complexity, but maybe more basic stuff ‚Äì for example the regex libraries are just impossible to use quickly.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209315379" name="209315379"><div>2020-09-07 17:17:01</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="325194">codygman</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209314878">said</a>:</p>
<blockquote>
<p>You and I are on the same page here... the problem comes when someone else starts pruning things you've proven are valuable as "not productive to learn" and start spreading FUD about them not being productive to learn. I think that's one effect stemming out of these basic conversations and why I don't feel like the "boring Haskell" or "Simple Haskell" movements are "basically harmless".</p>
</blockquote>
<p>I totally agree, but I always have the impression that engaging with those discussions causes only aggravation of the situation.<br>
At least I personally don't feel up to the task, and before I just try to fix conflicts without a good plan, I'd rather say nothing and try to improve my libraries</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209315507" name="209315507"><div>2020-09-07 17:19:47</div></a></div><div class="text"><p>reminds me of how news media keep on reporting on every single stupid thing that Trump says, without any effect whatsoever on his base</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209315561" name="209315561"><div>2020-09-07 17:20:04</div></a></div><div class="text"><p>quixotic</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#209316468" name="209316468"><div>2020-09-07 17:36:13</div></a></div><div class="text"><p>Just to add - that example above would work with <code>GADTSyntax</code> alone - at the same time, you can write GADTs without <code>GADTSyntax</code> using <code>ExistentialQuantification</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kr">data</span> <span class="kt">GADT</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">~</span> <span class="kt">Int</span> <span class="ow">=&gt;</span> <span class="kt">GADT</span> <span class="n">a</span>
</code></pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#209316526" name="209316526"><div>2020-09-07 17:37:39</div></a></div><div class="text"><p>What's interesting about this is that <code>GADTs</code> aren't really about some type-level trickery as much as they are about carrying constraints in constructors - which are just sort of implicit arguments at the end</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#209316597" name="209316597"><div>2020-09-07 17:38:40</div></a></div><div class="text"><p>From this perspective, it sounds strange to say that we should "avoid carrying some specific values in datatypes"</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209328274" name="209328274"><div>2020-09-07 21:20:31</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="254032">Georgi Lyubenov // googleson78</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209314543">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="325194">codygman</span> I think your example doesn't have any reason to use GADTs (other than nicer syntax, which is subjective)</p>
</blockquote>
<p>Well, maybe not, but based upon the haskell principle of least power (don't use a Monad when a Functor will work, don't use IO when State could work), I think that GADT syntax is actually somewhat counterproductive, explicitly because it is more powerful, and hence makes  a little harder to notice. Anwyay I think GADTs are generally fine, I don't care too much about them, actually the only thing that i wish they had was a single, obvious, clear, beginner-oriented tutorial to GADTs, explaining what they do, and when you might want them. Can anyone point me at one? I've looked several times in the past and couldn't find one. </p>
<p>To me the more problematic things are adopting whole-program abastractions which "encapsulate" your application and if there is later discovered some flaw, your whole program is in trouble. But this generally does speak to the problem of not speaking about concrete abstractions, so i have one ill bring up soon, but I want to finish reading what everyone said</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209328306" name="209328306"><div>2020-09-07 21:21:50</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="251311">Sridhar Ratnakumar</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209313195">said</a>:</p>
<blockquote>
<p>Regardless, it would be interesting to see a case study on how a real-world code would look with ADT vs with GADT, comparing their pros / cons, so as to give weight to such an argument not to use GADTs in production. Otherwise, it borders on some FUDsque subjective opinion.</p>
</blockquote>
<p>The best example IMO is typesafe ASTs; try writing a PL in haskell you'll quickly run into issues where you need GADTs.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209328523" name="209328523"><div>2020-09-07 21:26:38</div></a></div><div class="text"><p>GADTs are also useful in routes and request handling. Here is how the real-time websocket requests, and their specific response type, are modelled in <a href="https://www.cerveau.app/">Cerveau</a> :<br>
<a href="/user_uploads/13896/5T1elhssV1DfJ408hf7Q2pCP/image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/13896/5T1elhssV1DfJ408hf7Q2pCP/image.png" title="image.png"><img src="/user_uploads/13896/5T1elhssV1DfJ408hf7Q2pCP/image.png"></a></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209328543" name="209328543"><div>2020-09-07 21:27:28</div></a></div><div class="text"><p>Saivng a zettel, for example, must return the new blob sha from git. This sort of constraints ("unification"?) cannot be modelled by ADTs. Believe me, I tried hard lol as I didn't want to use rhyolite at the beginning.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209329160" name="209329160"><div>2020-09-07 21:42:29</div></a></div><div class="text"><p>So, one big issue that i see over and over again is that I have a different idea of what "boring haskell" means. To me, it means identifying a set of best practices and high-quality libraries to help make it easier to navigate the Haskell ecosystem, along with identifying which weaknesses exist in each. The goal being to have a "golden path" of haskell so that people can make successful projects. </p>
<p>Now, part of this meaning is also identifying the most highly-useful parts, which IMO are clearly the basics; you can get super super far with haskell 98, if the whole industry adopted it, this would transform the economy IMHO.</p>
<p>The benefits of such a thing would also make it easier for beginners to figure out how much they need to learn. I learned haskell from <a href="http://haskellbook.com">haskellbook.com</a> and knowing that basically that book would get me to the point where I could get a job made it much easier to navigate my way into Haskell.</p>
<p>I believe it is fine to expect your coworkers to learn something new when there is a good reason for it. We all have to do that in this industry, this world moves very quickly. But, I strongly believe that in terms of production code, using an unusual technique should have a good reason, or at least <em>a</em> reason. Some folks use things just because they are curious about them (like graphql , for example), without doing the work to understand what the tradeoffs are inherent in the tech. Except, years down the line, you learn that the tradeoffs you made were bad, and suddenly your project is dead. </p>
<p>(of course, I am not making a statement about anyone's personal fun coding time -- go wild if you want to! If you expect others to contribute, realize that doing very unusual things is perhaps counter-productive, but again, personal time is play time is fun time is go wild time)</p>
<p>It seems that some <em>other</em> people think you should NEVER stray from e.g. haskell 98, which i do disagree with, simply because these features are useful at times and can make code a lot better. But, I can see their point, as a community we do for example need better training materials.</p>
<div class="message_embed"><a class="message_embed_image" href="http://haskellbook.com" style="background-image: url(http://haskellbook.com/images/book_cover-min.png)"></a><div class="data-container"><div class="message_embed_title"><a href="http://haskellbook.com" title="Haskell Programming">Haskell Programming</a></div><div class="message_embed_description">A Haskell book for beginners that works for non-programmers and experienced hackers alike.</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209329252" name="209329252"><div>2020-09-07 21:45:20</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="325194">codygman</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209254958">said</a>:</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="252949">Joel McCracken</span>  </p>
<blockquote>
<p>It is not generally possible to figure out the right abstraction</p>
</blockquote>
<p>I feel like this is kind of the core of the disagreement between camps.</p>
<p>It reads to me like you simply accept you'll likely never get the right abstraction, use N because it's replacable, and move on the the next problem?</p>
<p>That doesn't seem right to me and seems like one would never exercise their abstraction muscle.</p>
</blockquote>
<p>When I said that I meant it in a way that you don't know when you will have the right one and when you won't. Its not that you can't EVER know, for example once a thing is stable, perhaps its time to add more type safety to prevent errors, add phantom types, etc. </p>
<p>I'm really just asking for an ounce of humility, and the ability to reflect on your past decisions and realize which ones are fruitful, and which aren't.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209330410" name="209330410"><div>2020-09-07 22:10:06</div></a></div><div class="text"><p>Since everyone is asking for concrete examples of problems I see, I will point out a few.  Please understand that I just want the community to improve; it would really be easier for me to just shut up, which I have considered doing several times in this thread, but since the conversation is generally constructive I will continue because I'd like to be shown that either I am wrong, come to a shared understanding, etc. I really love Haskell and want to keep seeing the ecosystem grow in usefulness  and make a larger impact on the world in general.</p>
<p>So, here is a concrete example: the performance of free monad systems. I've heard that folks have had free monads sink their apps because of performance issues. Then I've seen other people say "well actually that's FUD and here is a benchmark that proves it is" and well what is real? </p>
<p>If you have been paying attention, you probably know where this is going. Relatively recently the community "discovered" that typecalass instance function calls do not inline across module boundaries: </p>
<p><a href="https://www.youtube.com/watch?list=PLiU7KJ5_df6aZbNfh_TUJt-6w9N3rYkTX&amp;v=0jI-AlWEwYI&amp;feature=emb_title">YouTube - Alexis King -  ‚ÄúEffects for Less‚Äù @ ZuriHac 2020</a></p>
<div class="youtube-video message_inline_image"><a data-id="0jI-AlWEwYI" href="https://www.youtube.com/watch?list=PLiU7KJ5_df6aZbNfh_TUJt-6w9N3rYkTX&amp;v=0jI-AlWEwYI&amp;feature=emb_title"><img src="https://i.ytimg.com/vi/0jI-AlWEwYI/default.jpg"></a></div><p>Years and years of discussion about relative value of microbenchmarks etc and real-world stories about how free monad libs have real, whole-application performance problems are suddenly explained.  It seems like based upon that talk the folks claiming "FUD!!" were wrong, and not only were they wrong, they hadn't bothered to try benchmarking a reasonably-complex program. I mean, how many real haskell applications only have a single module (or that is don't split things across modules like you would want to in any reasonably complex app that uses free monad libraries)?!</p>
<p>I cannot possibly understate how much that talk blew my mind, and it exposed IMO a deep problem in the community. Personally, I'm working hard to develop a Haskell presence in Pittsburgh, making the place I am currently use it at successful so we can have more people writing Haskell. I have invested a lot of my career into Haskell, avoiding other, likely higher-paying opportunities. Learning this and other things has only made me MORE conservative when it comes to choices because I DO NOT want my efforts to be wasted. So now for example I know to stick to concrete monad stacks and not adopt MTL-style typeclass constraints (except in circumstances where this problem won't matter).</p>
<p>For what its worth, I actually would LOVE to learn more about free monad libs. Its still on my todo list, because I think they are so elegant and <em>easier</em> to understand than monad transformers. But, I haven't gotten to them yet.</p>
<p>Am I wrong? Did I somehow misunderstand the main point of that talk? Is Alexis wrong?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209331379" name="209331379"><div>2020-09-07 22:31:54</div></a></div><div class="text"><p>Another example: I recently was working with the haskell <code>paths</code> library (and <span class="user-mention" data-user-id="251311">@Sridhar Ratnakumar</span> this IS related to Rib). Now, I like the library. It makes a  lot of sense. Track the "type" of a file path so you don't use absoulte file paths when a relative one is needed, and you don't use a filename when you want a directory, etc. Excellent.</p>
<p>Except, I found the actual library was missing really basic features. For example, a<code>basename</code> function. Soonish after I was working with it, apparenty a function was added that could have suited me:  the <code>splitExtension</code> function added here:  </p>
<p><a href="https://hackage.haskell.org/package/path-0.7.0/changelog">https://hackage.haskell.org/package/path-0.7.0/changelog</a></p>
<p>But, at the time, that function did not exist. It did end up in me spending a lot of time scratching my head, trying to understand why I couldn't do this super simple  normal thing. I just ended up using the <code>toFilePath</code> escape hatch and then using the function there, see <a href="https://gitlab.com/JoelMcCracken/joelmccrackencom/-/commit/53cd3c8301ddadeb015c183c76ba3059ca659632#a622bfabc24287a5a213ceae5010aef0b3de0ac4_9_6">https://gitlab.com/JoelMcCracken/joelmccrackencom/-/commit/53cd3c8301ddadeb015c183c76ba3059ca659632#a622bfabc24287a5a213ceae5010aef0b3de0ac4_9_6</a></p>
<p>Additionally, the types I was using were all monomorphic however (<code>Path Rel File</code>, basically), so I really never felt the benefit of the typesystem telling me that I made a mistake like using using a file path when only a directory would be valid. </p>
<p>I DID spend a lot of time trying to figure out how to do really basic other things, too, like here:<br>
<a href="https://gitlab.com/JoelMcCracken/joelmccrackencom/-/commit/53cd3c8301ddadeb015c183c76ba3059ca659632#903e782aede1cf232dbcff3090f737e3bc276546_44_44">https://gitlab.com/JoelMcCracken/joelmccrackencom/-/commit/53cd3c8301ddadeb015c183c76ba3059ca659632#903e782aede1cf232dbcff3090f737e3bc276546_44_44</a></p>
<p>(the types of <code>asbfile</code> and <code>relfile</code> are <code>QuasiQuoter</code>, which are not so obvious when looking for how to use something; i did spent a good half hour probably stumbling on this)</p>
<p>I recall running into other problems using the library but only the few things I mentioned made it into the source, but overall I was really happy when Srid decided to remove Path and use FilePath, the resultant code was all a  lot simpler and removed a big pain point</p>
<div class="message_embed"><a class="message_embed_image" href="https://gitlab.com/JoelMcCracken/joelmccrackencom/-/commit/53cd3c8301ddadeb015c183c76ba3059ca659632#a622bfabc24287a5a213ceae5010aef0b3de0ac4_9_6" style="background-image: url(https://assets.gitlab-static.net/assets/gitlab_logo-7ae504fe4f68fdebb3c2034e36621930cd36ea87924c11ff65dbcb8ed50dca58.png)"></a><div class="data-container"><div class="message_embed_title"><a href="https://gitlab.com/JoelMcCracken/joelmccrackencom/-/commit/53cd3c8301ddadeb015c183c76ba3059ca659632#a622bfabc24287a5a213ceae5010aef0b3de0ac4_9_6" title="upgrades (53cd3c83) ¬∑ Commits ¬∑ Joel McCracken / joelmccrackencom">upgrades (53cd3c83) ¬∑ Commits ¬∑ Joel McCracken / joelmccrackencom</a></div><div class="message_embed_description">GitLab.com</div></div></div><div class="message_embed"><a class="message_embed_image" href="https://gitlab.com/JoelMcCracken/joelmccrackencom/-/commit/53cd3c8301ddadeb015c183c76ba3059ca659632#903e782aede1cf232dbcff3090f737e3bc276546_44_44" style="background-image: url(https://assets.gitlab-static.net/assets/gitlab_logo-7ae504fe4f68fdebb3c2034e36621930cd36ea87924c11ff65dbcb8ed50dca58.png)"></a><div class="data-container"><div class="message_embed_title"><a href="https://gitlab.com/JoelMcCracken/joelmccrackencom/-/commit/53cd3c8301ddadeb015c183c76ba3059ca659632#903e782aede1cf232dbcff3090f737e3bc276546_44_44" title="upgrades (53cd3c83) ¬∑ Commits ¬∑ Joel McCracken / joelmccrackencom">upgrades (53cd3c83) ¬∑ Commits ¬∑ Joel McCracken / joelmccrackencom</a></div><div class="message_embed_description">GitLab.com</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209332659" name="209332659"><div>2020-09-07 23:01:49</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="252949">Joel McCracken</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209330410">said</a>:</p>
<blockquote>
<p>Am I wrong? Did I somehow misunderstand the main point of that talk? Is Alexis wrong?</p>
</blockquote>
<p>That's right, the module boundary thing is something that _should_ have been clear, pointing to some kind of problem that should be addressed, but I don't know what it is. However, Alexis has worked it out and in the future it will all be peachy <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>
<p><span class="user-mention silent" data-user-id="252949">Joel McCracken</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209331379">said</a>:</p>
<blockquote>
<p>I recall running into other problems using the library but only the few things I mentioned made it into the source, but overall I was really happy when Srid decided to remove Path and use FilePath, the resultant code was all a  lot simpler and removed a big pain point</p>
</blockquote>
<p><code>path</code> is certainly lacking in several ways, and its abstraction is quite notoriously questionable (see <a href="https://hackage.haskell.org/package/hpath">https://hackage.haskell.org/package/hpath</a> ), but really a very tame specimen regarding its complexity.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209332865" name="209332865"><div>2020-09-07 23:04:53</div></a></div><div class="text"><p>yes, its certainly not the worst, i'm just trying to give an example of something that i experienced that went for some more abstract solution and I felt that was more of a pain than a benefit. But its interesting to see how things can be bad at such a minor level.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209333377" name="209333377"><div>2020-09-07 23:15:42</div></a></div><div class="text"><blockquote>
<p>I really never felt the benefit of the typesystem telling me that I made a mistake like using using a file path when only a directory would be valid.</p>
</blockquote>
<p>Well, I still think this is a really useful thing to have type system check for us; however it definitely is not worth having at the cost of a sucky path interface, like you illustrated above. Which is why it was removed from rib. The costs were not worth it; and, as you say, <code>filepath</code> is not that bad.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#209333443" name="209333443"><div>2020-09-07 23:17:07</div></a></div><div class="text"><blockquote>
<p><span class="user-mention silent" data-user-id="252949">Joel McCracken</span>  </p>
<blockquote>
<p>It is not generally possible to figure out the right abstraction</p>
</blockquote>
<p>I feel like this is kind of the core of the disagreement between camps.</p>
<p>It reads to me like you simply accept you'll likely never get the right abstraction, use N because it's replacable, and move on the the next problem?</p>
<p>That doesn't seem right to me and seems like one would never exercise their abstraction muscle.<br>
When I said that I meant it in a way that you don't know when you will have the right one and when you won't. Its not that you can't EVER know, for example once a thing is stable, perhaps its time to add more type safety to prevent errors, add phantom types, etc. </p>
</blockquote>
<p>Thanks for your comments and examples! I'll look at them again tomorrow when I'm less tired. I'll try addressing some parts of what you say to keep the conversation going and hopefully get other perspectives though :)</p>
<p>When the thing is stable, you likely won't have the time nor the motivation to add more type-safety, prevent type errors, or add phantom types. This method presumes that more type safety for instance slows down or otherwise impedes the development process and is merely a nice to have that should be done after the fact if at all.</p>
<blockquote>
<p><span class="user-mention silent" data-user-id="252949">Joel McCracken</span>  <br>
I'm really just asking for an ounce of humility, and the ability to reflect on your past decisions and realize which ones are fruitful, and which aren't.</p>
</blockquote>
<p>That sounds reasonable on the surface, but the problem is the methodology actively steers one away from ever concluding "I'm going to use type-safety up front here to speed up development mistakes".</p>
<p>I <em>really</em> want the ability to reflect on past decisions to figure out which are fruitful, the concern I have is the pattern you describe doesn't allow for ever considering anything but that which you're already convinced of.</p>
<p>I'm not claiming I have a better answer either by the way.... the only solution within these assumptions is "randomly prefer type-safety sometimes" to give it a chance of proving "it could be better".</p>
<p>I see two schools of thought in the Haskell community as I've been mentioning recently:</p>
<p>"Real-world thinking" vs "First-Principles thinking"</p>
<p>"Real-world thinking" absolutely dominates industry, and it seems simple Haskell advocates want it to dominate the Haskell industry too.</p>
<p>I think you might see "first-principles thinking" as I'm describing it as an unreleastic (pie-in-the-sky even) notion that you can figure out ideal abstractions in advance, or even that it's necessary to solve the subproblem (or more likely group of larger problems) at hand.</p>
<p>The problem (solution based on who you ask?) is things like static type-safety, finding super-powerful general abstractions, and other tools that make Haskell powerful isn't possible under a mostly or exclusively "real-world thinking" framework.</p>
<p>I think that the original "Boring Haskell" blog post by Michael Snoyman didn't say anything one way or the other about "first-principles thinking", but that any advocates of "boring Haskell" since then have utterly disregarded the value of anything but "real-world thinking".</p>
<p>Then the recent "What killed Haskell, could kill Rust, too" confusion seemed to be largely based on parsing valuing "first principles thinking" as "ignoring truths from the mainstream just because they came from that "dirty" mainstream" - <a href="https://gist.github.com/graninas/22ab535d2913311e47a742c70f1d2f2b#gistcomment-3444710">source</a>.</p>
<p>The point being that I now know I don't see as much of a problem with Boring Haskell if it comes with first principles thinking, but the boring Haskell that is being pushed for seems to come along with a "prefer only real-world thinking" like other languages in industry I find alarming, unjustified, and frankly pandering to a sort of idea of "hey we aren't that different" that ultimately will hurt more than help.</p>
<div class="message_embed"><a class="message_embed_image" href="https://gist.github.com/graninas/22ab535d2913311e47a742c70f1d2f2b#gistcomment-3444710" style="background-image: url(https://github.githubassets.com/images/modules/gists/gist-og-image.png)"></a><div class="data-container"><div class="message_embed_title"><a href="https://gist.github.com/graninas/22ab535d2913311e47a742c70f1d2f2b#gistcomment-3444710" title="What killed Haskell, could kill Rust, too">What killed Haskell, could kill Rust, too</a></div><div class="message_embed_description">What killed Haskell, could kill Rust, too. GitHub Gist: instantly share code, notes, and snippets.</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209333444" name="209333444"><div>2020-09-07 23:17:09</div></a></div><div class="text"><p>I was going to use <code>hpath</code> on Rib, but I was afraid of having a repeat experience.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#209333447" name="209333447"><div>2020-09-07 23:17:24</div></a></div><div class="text"><p>Also the library was still WIP at that time</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209333714" name="209333714"><div>2020-09-07 23:22:53</div></a></div><div class="text"><p>in the case of <code>path</code>, I think that there are quite a few aspects of abstraction that need to be examined separately.<br>
The absence of basic combinators that you mentioned seems to me not to be matching our current discussion, so since this was your main pain point, what can we say about it? How did the abstraction make it hard for you to implement an operation?</p>
<p>Some relevant aspects of the lib, as far as I can conjure up now, are:</p>
<ul>
<li>having <code>MonadThrow</code> control errors, which is a slight improvement over <code>System.FilePath</code> in so far as the latter uses exceptions, which is pretty unergonomic, while in <code>path</code>  you can just type the result as <code>Maybe</code>or <code>Either</code>. Since this is a straightforward situation, I think a concrete <code>Either</code>would be better suited though, so I would consider this to be overabstracted, maybe?</li>
<li>having a type for <code>Rel</code>/<code>Abs</code>, which is basically a safety mechanism for passing a path to third party code. Not sure I would rank this as one of those "complex abstractions" either; and I consider it to be pretty helpful.</li>
<li>having a type for <code>Dir</code>/<code>File</code>, which is similar, but since the path is purely logical I don't really see that there is something substantial to back this up. I consider it more as a newtype replacement, intended to help you keep track. This is removed in <code>hpath</code> and it kinda makes sense to me</li>
<li>construction has a safety mechanism, to prevent "bad" paths with stuff like multiple slashes or something, I don't think it's very useful</li>
<li>using <code>MonadIO</code>, which should be obvious</li>
</ul>
<p>So if you want to use <code>path</code>, you should have some requirements from that list to be satisfied. In your case, you were forced to use it, so how would you characterize your experience given my description?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209333831" name="209333831"><div>2020-09-07 23:25:29</div></a></div><div class="text"><p>my opinion, though, is that the low quality of <code>path</code>'s abstraction can be avoided by following design rules. As I said before, I consider this to be the main problem.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#209333976" name="209333976"><div>2020-09-07 23:28:54</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="252949">Joel McCracken</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209330410">said</a>:</p>
<blockquote>
<p>Please understand that I just want the community to improve; it would really be easier for me to just shut up, which I have considered doing several times in this thread, but since the conversation is generally constructive I will continue because I'd like to be shown that either I am wrong, come to a shared understanding, etc. I really love Haskell and want to keep seeing the ecosystem grow in usefulness  and make a larger impact on the world in general.</p>
</blockquote>
<p><span aria-label="heart" class="emoji emoji-2764" role="img" title="heart">:heart:</span> <span aria-label="heart" class="emoji emoji-2764" role="img" title="heart">:heart:</span> 10000% agree here and that's all I want as well. </p>
<p>I want to let you know I value your input and the effort you put into things... those examples aren't easy to recover from memory and recount! Thank you!</p>
<p>I'm really enjoying the direction the conversation is going in, and it can't go in a very interesting direction with only one opinion.</p>
<p>As a heads up, I often feel it would be easier for me to just "shut up" as well... but I feel like at least everyone in this thread has the shared value of:</p>
<blockquote>
<p>I really love Haskell and want to keep seeing the ecosystem grow in usefulness  and make a larger impact on the world in general.</p>
</blockquote></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#209337787" name="209337787"><div>2020-09-08 01:08:23</div></a></div><div class="text"><p>One thing I've been thinking about lately is... what if boring Haskell (whatever subset of Haskell you mean) is not unique or interesting enough among programming languages to for late adopters to switch? Do late adopters move to Haskell because it's as boring as Java? Java already has lambda functions and is getting pattern matching. C# is getting pattern matching, eliminating nulls, getting algebraic data types, etc. C++ isn't far off either. And they're only getting better with bigger communities and bigger budgets and many, many more people invested in their continued success.</p>
<p>I was thinking more about Gabriel's marketing talk and how does Haskell bridge the gap, so to speak, within an ecosystem where it's most easily understood features are already common place in more established languages? Is it the RTS and lazy evaluation and handful of acceptable "boring" libraries that bridges the gap to the late adopter?</p>
<p>I do hope that boring Haskell finds a way to weaken the dichotomy. Calling it "Simple Haskell" and "Fancy Haskell," creates tribal boundaries. The C++ community goes through this at least once a decade where one group decries the new features and tells everyone to adopt their subset of the language. It's not bad to want to use and promote a subset, even if you think it's a better one, but does it have to come at the cost of making sure that people who use a different subset are in some fancy out-group?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209453862" name="209453862"><div>2020-09-08 22:54:15</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="325194">codygman</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209333443">said</a>:</p>
<blockquote>
<p>When the thing is stable, you likely won't have the time nor the motivation to<br>
add more type-safety, prevent type errors, or add phantom types. This method<br>
presumes that more type safety for instance slows down or otherwise impedes the<br>
development process and is merely a nice to have that should be done after the<br>
fact if at all. </p>
</blockquote>
<p>So by stable I mean "you know what your program needs to do", <br>
or you are confident that<br>
you are going to be able to address whatever downsides/risks are<br>
involved. I don't mean that you should do this once "this thing is no longer<br>
being worked on". </p>
<p>A great example is RDBMs. At this point, even though I generally really dislike<br>
SQL (for all sorts of reasons), they work well and are a great "backbone" data<br>
store. Use them for most things, and if for some reason they don't work well in<br>
a given situation, THEN examine tradeoffs. </p>
<blockquote>
<p>... the concern I have is the pattern you describe doesn't allow for ever<br>
considering anything but that which you're already convinced of... </p>
</blockquote>
<p>Perhaps you're right, and I am too conservative. But I think there is a whole<br>
range of what is acceptable, and I myself am not extremely conservative in my<br>
habits, for example since I am a big proponent of Haskell, I am sure my<br>
non-haskell programmer friends think I am extreme. But let me tell you a<br>
few stories about hype, belief, and disbelief.</p>
<ul>
<li>
<p>A friend of mine from college (who has since become an extremely-well-known<br>
  person in the programming community).<br>
  But I remember talking with him and somehow he mentioned really liking Mongo, <br>
  which was the new hotness. I remember seeing articles about it but it didn't<br>
  seem "ready" to me yet. I asked "how does mongo deal with transactions,<br>
  record locking, etc?" his answer was basically "it doesn't worry about them" <br>
  (which I believe was true at the time, circa 2009).</p>
<p>This threw up alarm bells in my mind. How can a community replace something<br>
which has these sorts of critical functionality without addressing them?<br>
For this and other reasons (which I think of in my mind as "magical thinking"),<br>
I was wise enough to avoid the Mongo hype train, and watch it as it pulled<br>
into the station and exploded, killing all the projects on board.</p>
</li>
<li>
<p>Yet, in another situation, I drank the koolaid and it made me sick.<br>
  I believed some other mistaken people about mockist-style testing, and it<br>
  significantly impacted a project I was working on and the timelines for it. <br>
  Basically, I bought into: test each class individually, carefully mocking out<br>
  the interactions it has with other classes.</p>
<p>In my experience, this style of testing leads to worthless tests. You ended up<br>
having meaningless tests, becuase what you care about is how something works<br>
witin the context of business requirements and behavior, but that is not<br>
reflected in the tests. Each class was too small, and any interesting<br>
business behavior actually an interaction between many classes. So, testing each<br>
individually was basically wasting time.</p>
<p>In hindsight, I realise this style never made much sense to me, because I<br>
couldn't connect the value <br>
between mocking out each interaction and how it would make your code easier to<br>
modify/know you didn't break the business requirements.<br>
But I trusted it, as as it was being promoted as the "one true way" at<br>
the time.</p>
<p>What happened? I think I was too inexperiencd and did not have enough<br>
context with writing tests, so I kept going on the "promised" right way, and<br>
just kept pushing. I also did not have enough confidence in myself to "trust<br>
my gut", being afraid of showing that I didn't really "get" testing.<br>
Today, I wish I asked more questions and not acted like I was the expert that<br>
I wasn't. I think perhaps if I had, I wouldn't have made those mistakes.</p>
<p>FWIW, if you are intrested in the results of what I setteled on with testing,<br>
this talk was a very effective distillation of the lessons I learned over the years:<br>
<a href="https://www.youtube.com/watch?v=EZ05e7EMOLM&amp;list=PLd0-gZCh4SXuGFlAVpt_U_x2RpGbTUa0t&amp;index=3">YouTube - üöÄ DevTernity 2017: Ian Cooper - TDD, Where Did It All Go Wrong</a><br>
I found myself "amen"ing this talk continually as I watched it.</p>
<div class="youtube-video message_inline_image"><a data-id="EZ05e7EMOLM" href="https://www.youtube.com/watch?v=EZ05e7EMOLM&amp;list=PLd0-gZCh4SXuGFlAVpt_U_x2RpGbTUa0t&amp;index=3"><img src="https://i.ytimg.com/vi/EZ05e7EMOLM/default.jpg"></a></div></li>
<li>
<p>Since then, I did gain some additional wisdom regarding things when <em>another</em><br>
  fad came around, this time it was the microservices fad.</p>
<p>Microservices never really made sense to me as a technique for anything but<br>
large, hundred-or-thousand-person teams. I think the downsides are fairly well<br>
known now, though many are still using them inappropriately. I'll speak to<br>
this if anyone cares but the entire idea is just extremely complex and this a<br>
huge topic. But, one of the biggest advocates for microservices has recanted:<br>
<a href="https://changelog.com/posts/monoliths-are-the-future">https://changelog.com/posts/monoliths-are-the-future</a> </p>
<p>What blows my mind is that most of the problems that microservices introduce<br>
are fairly obvious. </p>
</li>
</ul>
<blockquote>
<p>I'm not claiming I have a better answer either by the way.... the only solution<br>
within these assumptions is "randomly prefer type-safety sometimes" to give it a<br>
chance of proving "it could be better". </p>
</blockquote>
<p>Every situation is different. When making any decision to use some technology,<br>
ask yourself "if this is wrong, how hard will it be to fix?" If fixing it<br>
means  "replace a few lines of code", then fine, use it. If its "throw out the<br>
entire program", perhaps you should think about how to mitigate the risks, or<br>
just not use it in this project. Your professional reputation is at stake, after<br>
all.</p>
<blockquote>
<p>I see two schools of thought in the Haskell community as I've been mentioning<br>
recently: "Real-world thinking" vs "First-Principles thinking" </p>
<p>"Real-world thinking" absolutely dominates industry, and it seems simple Haskell<br>
advocates want it to dominate the Haskell industry too.</p>
<p>I think you might see "first-principles thinking" as I'm describing it as an<br>
unreleastic (pie-in-the-sky even) notion that you can figure out ideal<br>
abstractions in advance, or even that it's necessary to solve the subproblem (or<br>
more likely group of larger problems) at hand. </p>
</blockquote>
<p>I actually don't think of myself in either way. IMHO, all I am talking about is<br>
a cost/benefit/risk analaysis. This applies equally to "real world" thinking or<br>
"first principles" application.</p>
<p>I tend to find that folks who are "real world" thinkers tend to make a lot of<br>
mistakes, like the legions of microsoft people who say "well open source is<br>
fine, but in the Real World we do Real Work and solve problems for Enterprise".</p>
<p>This causes you to fall back on whatever the norms of our culture are<br>
and resist any change at all, even if what you are doing is obviously worse.<br>
Stating "in the real world we use mockist testing to get things done" is not in<br>
any way good. </p>
<p>The right way to go, in terms of everything, is somewhere in between. Or,<br>
perhaps, my preference is to develop confidence that a "first principle" system<br>
will work out when put in a "real world" situation. Or at least mentally examine<br>
the upsides and downsides before proceding, and considering if it is worthwhile<br>
or not. </p>
<blockquote>
<p>The problem (solution based on who you ask?) is things like static type-safety,<br>
finding super-powerful general abstractions, and other tools that make Haskell<br>
powerful isn't possible under a mostly or exclusively "real-world thinking"<br>
framework. </p>
</blockquote>
<p>I actually really agree and think these are very valuable. Remember, I'm a<br>
Haskell programmer, not a golang dev trolling everyone. I have accepted the<br>
value of static types and abstractions. I just want to ensure they work <br>
before I "bet the farm" on them.</p>
<blockquote>
<p>...but that any advocates of "boring Haskell" since then have utterly<br>
disregarded the value of anything but "real-world thinking". </p>
</blockquote>
<p>This is so far from my actual feelings on this that its clear I have failed in<br>
some way to communicate what my acutal opinions are. </p>
<p>Lets look at one example, that is, pure functions. I bet if you asked most<br>
programmers, I believe they would say that restricting IO to the <br>
outermost layer of your program is entirely disconnected from the "real world".<br>
But, I was open to the idea, and proved it to myself enough that actually it<br>
works. In fact, not only does it work, it works well that taking a big<br>
chunk of my free time to learn Haskell well enough to get a job was clearly<br>
worth it.</p>
<p>Then there are abstractions that seem "complicated", but if you want proof of<br>
how powerful they are, I think looking at <code>Traversable</code> is a wonderful example.<br>
Take a few simpler abstractions (<code>Functor</code>, <code>Foldable</code>, and <code>Applicative</code> or<br>
<code>Monad</code>), and combine them so that you are able to do something that would<br>
otherwise be a lot of manual, error-prone code, and would have to be implemented<br>
for every pair of types. </p>
<blockquote>
<p>"What killed Haskell, could kill Rust, too"</p>
</blockquote>
<p>I don't have much of an opinion on this piece beyond what I've already stated.<br>
Except <br>
in the comments, Alexis took his post to being rude/disrespectful, and I just<br>
want to make it clear that I value all this cool stuff people are building. I<br>
<em>really</em> want to use it. That's why I am here. If I didn't want to use it, <br>
I'd go write golang for more money. I just want to make sure projects don't<br>
fail because of technical choices that should have been obvious, such as the<br>
one dealing with persistent, which I mention later in this post.</p>
<div class="message_embed"><a class="message_embed_image" href="https://changelog.com/posts/monoliths-are-the-future" style="background-image: url(https://cdn.changelog.com/images/share/fb-sitewide-f0e5299f37b02bea4d53fefdd14b3ed4.png?vsn=d)"></a><div class="data-container"><div class="message_embed_title"><a href="https://changelog.com/posts/monoliths-are-the-future" title="Monoliths are the future">Monoliths are the future</a></div><div class="message_embed_description">Unpopular opinion! Monoliths are the future because the problem people are trying to solve with microservices doesn‚Äôt really line up with reality. Just to be honest - and I‚Äôve done this before, gone from microservices to monoliths and back again. Both directions. </div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209453956" name="209453956"><div>2020-09-08 22:55:39</div></a></div><div class="text"><blockquote>
<p>The point being that I now know I don't see as much of a problem with Boring<br>
Haskell if it comes with first principles thinking, but the boring Haskell that<br>
is being pushed for seems to come along with a "prefer only real-world thinking"<br>
like other languages in industry I find alarming, unjustified, and frankly<br>
pandering to a sort of idea of "hey we aren't that different" that ultimately<br>
will hurt more than help. </p>
</blockquote>
<p>I keep hearing this kind of opinion, and I really don't understand it. What<br>
haskell programmers are advocating for this kind of thing? We are a<br>
self-selected group of people who took our own free time to learn something that<br>
probably isn't going to improve our job prospects or our pay. </p>
<p>Ultimately, haskell <em>isn't</em> that different, at lest not as different as many<br>
seem to make it out to be. Maybe you think that's pandering, I<br>
honestly don't really care. Haskell is still software engineering. <br>
Haskell projects can fail for the same reasons golang projects can fail. It is<br>
imporant to recognize this and account for it. For example, the reasons for<br>
KISS, DRY, etc are still applicable in the world of Haskell. <br>
Of course, haskell <em>is</em> different, and so you need to adjust your principles,<br>
but most still apply.</p>
<p>Another story time. A couple of weeks back I had a twitter thread with another<br>
haskeller who worked <br>
at one of the companies who has since abandoned Haskell. He blamed persistent<br>
for the problems they had. I was curious because I generally find Persistent<br>
adequate and not-very-problematic, so I asked them about it. </p>
<p>It seemed to me that the crux of their problem was that the data model used in<br>
the database was being shared with the frontend code via GHCJS, and they had a<br>
bunch of problems with scaling their Postgres database. </p>
<p>From here it is EASY to fill in the blanks with what happened, because elsewhere<br>
in the industry the same idea has been tried, and the same problems arose. I<br>
have encountered the idea before.<br>
If you reuse your db data model in your frontend, you probably will save some time<br>
upfront, but you are also very tightly coupling these two very different things.<br>
You WILL have a problem if you ever get into a situation where the frontend and<br>
the backend data models need to change. For example, if the frontent needs to<br>
have data organized a little differently because the browser freezes for 5<br>
seconds while rendering happens, or perhaps because your database schema is not<br>
scaling well and you need to reorganize how the tables are stored, perhaps even<br>
splitting some specific thing into a NoSQL data store.</p>
<p>And, this is what happened to them. Their application was tightly coupled to<br>
these few data models and they weren't able to make changes to their database to<br>
make it scale better.</p>
<p>To reiterate, tightly coupling very disparate things<br>
<em>can</em> be faster if those things happen to mirror each other, but once they don't,<br>
you are potentially in for a lot of pain. This is, like, known, man. So why do<br>
people think that this wouldn't apply to Haskell? This is an example of magical<br>
thinking. </p>
<p>As a side point, if someone had done this kind of thing in JavaScript, I think<br>
management would have said "oh that specific thing was a mistake". But since<br>
Haskell is "unusual", Haskell <em>itself</em> was seen as being the problem.</p>
<p>If you want to convince me that Haskell is different and that that the same<br>
rules don't apply, please tell me how I am wrong here. </p>
<p>I am not trying to "pander" to people who come in wanting to write Java in<br>
Haskell. I am trying to help more project succeed by not getting hamstrug with<br>
things that have some fundamental problems.</p>
<hr>
<p><span class="user-mention silent" data-user-id="260881">Torsten Schmits</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209333714">said</a>:</p>
<blockquote>
<p>in the case of <code>path</code>, I think that there are quite a few aspects of abstraction that need to be examined separately.<br>
The absence of basic combinators that you mentioned seems to me not to be matching our current discussion, so since this was your main pain point, what can we say about it? How did the abstraction make it hard for you to implement an operation?<br>
...<br>
So if you want to use <code>path</code>, you should have some requirements from that list to be satisfied. In your case, you were forced to use it, so how would you characterize your experience given my description?</p>
</blockquote>
<p>I'm not really sure what you're asking me for. But my main point is that I want<br>
the Haskell community to use things that are more-fully baked in production<br>
code. Before picking something up that is supposed to be more type-safe, make<br>
sure they satisfy basic <br>
requirements. That's the thing about <code>path</code>. Folks are using it because its<br>
more typesafe, but meanwhile from my POV it didn't bring any benefit (to what<br>
I was working on), and it had downsides that were not-nothing. To be clear, its<br>
not that I want to use FilePath. I want <code>path</code> to be better!</p>
<p>"Too abstract" is just <em>one</em> way in which a project might have problems. I don't<br>
think <code>path</code> suffers from that, except IMO it is not obvious what the value<br>
proposition is from looking at its hackage page (or what else I should look at<br>
instead!), but that's still a matter of documentation, probably.</p>
<p>If you're writing code that other professional Haskell programmers would have<br>
problems with, perhaps consider not doing this. <br>
This is just normal engineering.<br>
What will be confusing for others is a function of cultural norms. <br>
I guarantee many in here have mocked <code>FactoryFactoryFactory</code> abstractions in<br>
Java for being too complex and devoid of value.<br>
Additional complexity is worthwhile in a project <em>if it has accompanying value</em>.<br>
Could another team mate jump in to this code and<br>
make contributions? Could you hire a Jr dev and have them productive in a<br>
reasonable amount of time? All of this is part of being a <em>profoessional</em> software<br>
developer. Writing a lot of code that only YOU understand is not something that<br>
is considered acceptable in any other area of software engineering. Haskell<br>
isn't magically different.</p>
<p>A lot of this discussion comes down to cost/benefit/risk analysis. If<br>
you deem that the cost/risk is low enough and the benefit high enough, fine, use<br>
it. Just realize what might happen if you are wrong. </p>
<p>Now, back to <code>path</code>: As I said before, I like a lot of things about <code>path</code>.<br>
I'd also like to try <code>hpath</code>, perhaps. I don't know how that would work out,<br>
but I probably wouldn't <br>
intentionally use them on a production codebase without more investigation. <br>
The problem with <code>path</code> is that it is not "fully baked" in<br>
several ways, as you can see from the diff I linked to:</p>
<ul>
<li>
<p>deficiency of documentation, specifically I stumbled for a while trying to<br>
  find out how to make a path literal. </p>
</li>
<li>
<p>deficiency of combinators; if I were writing a library like this, personally I<br>
  would look at the existing FilePath abstraction and add comparable combinators<br>
  for each of them. Since it didn't, I don't have a ton of confidence that<br>
  others standard tools would be missing.</p>
</li>
</ul>
<p>I do quite dislike that FilePath has partial functions. But it also actually<br>
did what I needed it to. </p>
<p>I generally have a very bad memory when it comes to certain things, especially<br>
the details of what I did. People are always telling me "remember when you..."<br>
and no, actually, I don't remember. This literally just happened today. So it is<br>
challenging to remember these things, and while <code>path</code> was not a perfect example<br>
by any means, it did satisfy certain criteria. But the problems with free monads<br>
are much, much, more significant.</p>
<hr>
<p><span class="user-mention silent" data-user-id="250729">James King</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209337787">said</a>:</p>
<blockquote>
<p>...but does it have to come at the cost of making sure that people who use a different subset are in some fancy out-group?</p>
</blockquote>
<p>If I have at all made anyone feel like they are part of an out group, I<br>
apologize. I really want to establish a good set of practices that people can<br>
use and be reasonably sure their projects will not have massive problems because<br>
of them. I want to minimize Haskell job erasure. </p>
<p>You can always program some other way if you want. If you have different values<br>
than I do, that's fine too. I just see certain problems again and again, and I<br>
think that I've discussed that I think some basic software engineering lessons<br>
are missing from people's thought processes.</p>
<p>Personally, since I am really hoping that Haskell will succeed at my employer, I<br>
am going to keep using the techniques that I have a reasonable confidence will<br>
yield a successful project. I will mess around on my own time. If, at some<br>
point, I believe these techniques I have learned are responsible to use as a<br>
professional, I will adopt them when I have a good reason to, but not before.</p>
<hr>
<p>I kinda feel like I am repeating myself over and over, and this is absurdly<br>
long. It feels like my point isn't really coming across clearly, so I added<br>
some personal stories, for example, which added to the length. <br>
But I feel like reiterating what I have already said, so I don't know how much<br>
more there is to discuss.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209454077" name="209454077"><div>2020-09-08 22:57:07</div></a></div><div class="text"><p>Sorry for how long these are, i'm trying hard to make things clear, and it seems like I haven't been too successful previously in this thread...</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209454889" name="209454889"><div>2020-09-08 23:06:23</div></a></div><div class="text"><p><span class="user-mention" data-user-id="252949">@Joel McCracken</span> the purpose of my question was to connect your criticism of the lib to the concept of Boring Haskell, since it seems to me that you're just stating that the library has overall low quality, which I agree with, but not that it is hard to understand how it works. I'm not trying to make a point, just an attempt at discussing concrete examples of what is too fancy. If that doesn't apply here, no worries!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#209455127" name="209455127"><div>2020-09-08 23:09:25</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="252949">Joel McCracken</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209454077">said</a>:</p>
<blockquote>
<p>Sorry for how long these are, i'm trying hard to make things clear, and it seems like I haven't been too successful previously in this thread...</p>
</blockquote>
<p>I've read through, but not yet understood your responses yet  :) I'll try with more energy tomorrow.</p>
<p>Don't be sorry for how long these are, I think this is a valuable conversation with lots of moving parts that makes it hard to communicate.</p>
<p>Your effort in making things clear is very appreciated, please don't take any of my challenges or disagreements to mean you weren't successfully communicating... I could still just disagree (whether I should or not <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span> ).</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209455138" name="209455138"><div>2020-09-08 23:09:42</div></a></div><div class="text"><p>Gotcha, thanks for clarifying. Boring Haskell is not just about easy to understand stuff, it‚Äôs also identifying the high-quality libraries etc so that it‚Äôs easier to build successful projects</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209455304" name="209455304"><div>2020-09-08 23:12:05</div></a></div><div class="text"><p>well, I guess there just isn't one for file paths <span aria-label="shrug" class="emoji emoji-1f937" role="img" title="shrug">:shrug:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209455350" name="209455350"><div>2020-09-08 23:13:18</div></a></div><div class="text"><p>I actually think that‚Äôs a super valuable observation, and the question becomes ‚Äúhow do we fix it‚Äù</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209455444" name="209455444"><div>2020-09-08 23:14:46</div></a></div><div class="text"><p>I think you just volunteered to build a better one <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209455568" name="209455568"><div>2020-09-08 23:16:24</div></a></div><div class="text"><p>tbh, I wanted to do that a few times when dealing with <code>path</code>, but obviously it isn't done in a day</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209455651" name="209455651"><div>2020-09-08 23:18:00</div></a></div><div class="text"><p>Perhaps hpath is it now?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209455716" name="209455716"><div>2020-09-08 23:18:39</div></a></div><div class="text"><p>afaict it's just a shallow fork of <code>path</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209457043" name="209457043"><div>2020-09-08 23:39:31</div></a></div><div class="text"><p><span class="user-mention" data-user-id="252949">@Joel McCracken</span> just a note, after reading the entirety of your essay, I have the impression that you're suffering more from haskellers in the industry knowing too little about non-haskell topics in software development, like large-scale architecture design, and not from too-advanced code.<br>
I can't judge that situation, but that's what it reads like to me.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209458295" name="209458295"><div>2020-09-08 23:59:29</div></a></div><div class="text"><p>I think I agree, but overly complex abstracted code may <em>also</em> cause problems. People need to be able to maintain your code after you're gone.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/8084ff35e892945a460a7ed9885325c7804e1b87?version=2"></a><div class="content"><a class="author">Rizary</a><div class="metadata"><a href="#209462078" name="209462078"><div>2020-09-09 01:00:39</div></a></div><div class="text"><p><span class="user-mention" data-user-id="252949">@Joel McCracken</span> If someone coupling their db (in this case Persistent) data model via GHCJS and the project is shutdown, instead of blaming Persistent and GHCJS, would this boring haskell initiative people find the solution to adhere the problem? Like using another library beside Persistent? (I ask this for my knowledge).</p>
<p>I feel that people behind this initiative is just group of library maintainer that really wish haskeller or beginner haskeller use their library, and then we are depend on them a lot. And I know some people that always bashing another library that is similar type with his. Like instead Persistent, why not postgresql-simple? instead of stack why not promoting cabal? if people decided to join boring haskell and he prefers cabal, is he not a member of boring haskell anymore?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209467243" name="209467243"><div>2020-09-09 02:59:35</div></a></div><div class="text"><p>I think most people would consider Persistent to be "simple haskell" I think; the issue is less the library and more the way it was used. You really can't prevent someone from using your library in a bad way, or at least I don't know how you'd be able to do that. </p>
<p>The right way to do it IMO is you would have your persistent types, and then you have "view model" types with ToJSON/FromJSON instances which are sent down to the client and then parsed by the client. IMO the client/server would be able to share these "view models" and I don't think it would be too terrible, but I'm not  totally sure and it would be something i would watch. Its quite likely that the client might need to do additional work to convert it to types that work well for it, and the view models are just used for data exchange. You need to be aware of this coupling and when you start to feel the pain, come up with ways to address it. I don't know the specifics of what happened so I can't speak to what went wrong, but sometimes if you let a problem get too bad without addressing it, it becomes essentially impossible to fix it; too many things are coupled, too many things behave weirdly to work around this other thing that is not quite perfect, etc.</p>
<p>The reason stack is promoted is because it solves a lot of problems that trip beginners up. For example, it installs the correct version of GHC. A beginner can install stack and then git clone a project and just run stack build and then be ready to go. Cabal used to not have certain features, such as sandboxes, which made certain things not work correctly, and IIRC basically the invention of stack made cabal evolve better features. I don't have a big stake in this debate, I just know that stack has always worked for me and never really caused me any grief, whereas I find working with cabal directly to be generally quite confusing. But that's just me.</p>
<p>"Boring haskell" isnt like a club. Its just an idea that a lot of people have been thinking. Its just a name for an idea. People aren't part or not part of boring haskell; they just like or dislike the ideas. and re: people just promoting their own libraries, well, you can feel that if you want. Perhaps someone is urging others to their library in bad faith; i don't know. I don't have any haskell libraries so that criticism wouldnt apply to me</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209467381" name="209467381"><div>2020-09-09 03:03:17</div></a></div><div class="text"><p>anyway there isn't any reason there couldn't be multiple libraries that do a similar thing that are both considered "boring haskell". The idea is basically say "the haskell community has said these libraries are good enough that you can use them without worrying that you are the first person who actually used this library in a significant way". At least, that's how I feel.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209494414" name="209494414"><div>2020-09-09 10:34:06</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="252949">Joel McCracken</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209458295">said</a>:</p>
<blockquote>
<p>I think I agree, but overly complex abstracted code may <em>also</em> cause problems. People need to be able to maintain your code after you're gone.</p>
</blockquote>
<p>So to bring this back to the OP, do you think that it might be possible that the <em>overly complex</em> part is a direct consequence of the lack of general software engineering skills, and basically orthogonal to abstraction?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209506873" name="209506873"><div>2020-09-09 13:01:50</div></a></div><div class="text"><p>Absolutely it is possible; its a skill to know how to write code that is consumable by other engineers</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209514591" name="209514591"><div>2020-09-09 14:03:39</div></a></div><div class="text"><p>so I guess the question is: is there a correlation between the <em>use</em> of abstraction and lack of accessiblity skill, or is it rather between academics/hobbyists/etc. and that lack, or something else? and how does that translate demographically to the community?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#209517843" name="209517843"><div>2020-09-09 14:24:41</div></a></div><div class="text"><p>I don't know that it does. It's the same old tribal hostilities you see elsewhere in programming communities. When I hear people describe what they do as, "real world programming," I'm turned off. Qualifying how <em>others</em> behave or think is a sign that they're gate-keeping their in group.</p>
<p>I'm down, as much as anyone else, for higher levels of adoption of Haskell in industry. I disagree that, "Boring Haskell," is the way. C++ had similar movements as well and it's different which subset of C++ you end up with depending on which team you talk to. Game engine developers are famous for writing their own template libraries; others only use C with templates. It's okay to use a subset at a company... Haskell is a big language! But I think it's harmful to bless a particular subset. It's great for debates but not for progress and adoption. I think we could benefit from uniting as a whole community and focusing our efforts on understanding markets better if adoption is what we want to see.</p>
<p>I realize there are stories of "teams falling apart due to inappropriate use of Haskell feature X," or because the team lacked the skills to maintain a "fancy" Haskell code base... but is that Haskell's fault or the context of the business? What if those developers aren't given the appropriate time and space to learn because they were always expected to be shipping new features? What if their manager wanted the project to fail because they didn't believe in Haskell to begin with? I don't think I can recall a project failing because of a programming language feature. It's usually because the social structures of the business were already falling apart or poor to begin with. A strong team committed to their goals and working on the same page can make things work.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209520119" name="209520119"><div>2020-09-09 14:41:00</div></a></div><div class="text"><p>Can you point at any message that indicates that "boring haskell" people are claiming that only they do "real world programming"?</p>
<p>Can you point at any message that indicates someone is trying to establish an in-community?</p>
<p>At this point I don't think you are arguing in good faith. I have made it clear that none of those things you say are what </p>
<p>Also, I think it is rude to say:</p>
<blockquote>
<p>I realize there are stories of "teams falling apart due to inappropriate use of Haskell feature X," or because the team lacked the skills to maintain a "fancy" Haskell code base... but is that Haskell's fault or the context of the business? </p>
</blockquote>
<p>Is it so impossible to believe that these people are actually right? the are after all talking about <em>their</em> experience.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209520349" name="209520349"><div>2020-09-09 14:42:30</div></a></div><div class="text"><p>If you have someone from one of these teams who says differently, and blames their dumb coworkers for not understanding their code and their bad management for not letting them put the effort in, ok, at least we would have <em>someone</em> who did it. But i don't think i've seen anyone ever make  a counterclaim lik ehtat</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#209520795" name="209520795"><div>2020-09-09 14:45:42</div></a></div><div class="text"><p>Sure, from <a href="https://www.simplehaskell.org">https://www.simplehaskell.org</a></p>
<blockquote>
<p>Commercial software is a team endeavor. Fancy Haskell is costly to teams because it usually takes more time to understand and limits the pool of people who can effectively contribute.</p>
</blockquote>
<p>I'm not saying it's an extreme problem but it's not an uncommon opinion in my experience.</p>
<p>And no I can't say definitely that a software project collapsed because someone used GADTs but I have heard stories from people who blamed language features, and this isn't unique to Haskell, but they leave out the context of everything else that might have been going on.</p>
<p>I'm not trying to argue on bad faith or anything -- I'm just trying to point out that adoption is more complicated than a subset of language features.</p>
<p>I myself tend to stick with the most simple features I can get away with before I reach for more interesting/powerful things. :)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209521679" name="209521679"><div>2020-09-09 14:51:31</div></a></div><div class="text"><p>I don't think GADTs are an issue; i honestly think they would probably be blessed by such an initiative because they are so easily comprehensible and clearly useful and it would be very hard to imagine a person walling themselves into a box with GADTs alone. Really, the only thing they need is a small, easily comprehensible blog post or wiki page, IMHO</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209521751" name="209521751"><div>2020-09-09 14:51:59</div></a></div><div class="text"><p>gotcha, sorry i reacted a bit out of anger</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#209521845" name="209521845"><div>2020-09-09 14:52:21</div></a></div><div class="text"><p>It's okay! I wasn't trying to be rude and would like to avoid being rude. :)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209521878" name="209521878"><div>2020-09-09 14:52:37</div></a></div><div class="text"><p>so can i say first of all that i really dislike that simple haskell site, I thought it was very poorly worded</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209521927" name="209521927"><div>2020-09-09 14:52:59</div></a></div><div class="text"><p>it is NOT anything that any of the people from the snoyman mailing group would have written IMHO, I acutally don't know who is behind it</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209522215" name="209522215"><div>2020-09-09 14:54:59</div></a></div><div class="text"><p>so maybe now i understand where the resentment is coming from</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209522225" name="209522225"><div>2020-09-09 14:55:03</div></a></div><div class="text"><p>sorry yall</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209522442" name="209522442"><div>2020-09-09 14:56:30</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="250729">James King</span> <a href="#narrow/stream/201385-Haskell/topic/Boring.20Haskell.20.2F.3D.20Resenting.20Types/near/209517843">said</a>:</p>
<blockquote>
<p>I realize there are stories of "teams falling apart due to inappropriate use of Haskell feature X," or because the team lacked the skills to maintain a "fancy" Haskell code base... but is that Haskell's fault or the context of the business? What if those developers aren't given the appropriate time and space to learn because they were always expected to be shipping new features? What if their manager wanted the project to fail because they didn't believe in Haskell to begin with? I don't think I can recall a project failing because of a programming language feature. It's usually because the social structures of the business were already falling apart or poor to begin with. A strong team committed to their goals and working on the same page can make things work.</p>
</blockquote>
<p>To me, this is the best point made so far. Management in companies is notorious for this kind of effect.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#209523846" name="209523846"><div>2020-09-09 15:05:14</div></a></div><div class="text"><p>Sorry for getting you upset! I think a lot of the spirit of "Boring Haskell," makes a lot of sense.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209524388" name="209524388"><div>2020-09-09 15:08:48</div></a></div><div class="text"><p>Maybe I'm wrong but i generally think its your job as an engineer to try to sense what management expects and work within those confines. It is certainly possible to have impossible expectations though, so. But in terms of the one case re: the postgres db being unable to scale, it does sound like it was a technical problem, or at least that person perceived that having their DB model coupled tightly throughout their codebase (including their frontend) was a big factor in making it "impossible to scale"</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209524400" name="209524400"><div>2020-09-09 15:08:57</div></a></div><div class="text"><p>i'm trying to find the tweet atm just so yall have context</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209524449" name="209524449"><div>2020-09-09 15:09:19</div></a></div><div class="text"><p>there was something someone chimed in with about some service being deployed in production in a tmux session</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209525836" name="209525836"><div>2020-09-09 15:17:35</div></a></div><div class="text"><p><a href="https://mobile.twitter.com/rossabaker/status/1296542252433641495?prefetchtimestamp=1599664608257">https://mobile.twitter.com/rossabaker/status/1296542252433641495?prefetchtimestamp=1599664608257</a></p>
<div class="inline-preview-twitter"><div class="twitter-tweet"><a href="https://mobile.twitter.com/rossabaker/status/1296542252433641495?prefetchtimestamp=1599664608257"><img class="twitter-avatar" src="https://pbs.twimg.com/profile_images/1302790129736708096/6q2IMapE_normal.jpg"></a><p><a href="https://twitter.com/nuttycom">@nuttycom</a> <a href="https://twitter.com/jkachmar">@jkachmar</a> <a href="https://twitter.com/JoelMcCracken">@JoelMcCracken</a> <a href="https://twitter.com/mattoflambda">@mattoflambda</a> My first day, I was shown a critical service scp'ed from a developer machine to a manually provisioned cloud instance running in bash loop inside a tmux session. It coalesced into one fire, but there were multiple acts of arson.</p><span>- Ross A. Baker (@rossabaker)</span></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209526899" name="209526899"><div>2020-09-09 15:24:25</div></a></div><div class="text"><p>this whole thread is worth a read</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#209527317" name="209527317"><div>2020-09-09 15:27:36</div></a></div><div class="text"><p>I think I've seen bits of that. It's hard to see what factors led up to that. I'd have so many questions!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209527713" name="209527713"><div>2020-09-09 15:30:50</div></a></div><div class="text"><p>ditto; i'm not sure how much everyone is willing to discuss that stuff though</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#209531454" name="209531454"><div>2020-09-09 16:00:54</div></a></div><div class="text"><p>all the issues that Kris has in the thread seem to be unrelated to persistent (and how complex or simple it is) to me, as other people have pointed out in the thread itself (using db types as domain types, every db lib forces you into IO at some point)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#209532031" name="209532031"><div>2020-09-09 16:05:23</div></a></div><div class="text"><p>yep. I agree with Kris fwiw, its better to have your business logic in pure types, and have a monad transformer stack "at the edges". I'd like to keep PersistT out of things as much as possible just because of the principle of least power!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#209538315" name="209538315"><div>2020-09-09 16:59:03</div></a></div><div class="text"><p>I did something similar in Rosby with separating the serialization types/primitives from the domain types/objects. Separation of concerns is a nice idea. :)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#209549433" name="209549433"><div>2020-09-09 18:28:34</div></a></div><div class="text"><p>thought at first you were referring to Ross Baker (tweet above) with <em>Rosby</em></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#209550660" name="209550660"><div>2020-09-09 18:39:23</div></a></div><div class="text"><p>Haha, no it's the name I gave the database I'm building on my stream: <a href="https://github.com/agentultra/rosby">https://github.com/agentultra/rosby</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/agentultra/rosby" style="background-image: url(https://avatars2.githubusercontent.com/u/120574?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/agentultra/rosby" title="agentultra/rosby">agentultra/rosby</a></div><div class="message_embed_description">A simple, reliable key key-value database. Contribute to agentultra/rosby development by creating an account on GitHub.</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#209551499" name="209551499"><div>2020-09-09 18:46:39</div></a></div><div class="text"><p>It's a reference to <em>Lord Gyles Rosby</em> in <em>A Song of Ice And Fire</em>: <a href="https://awoiaf.westeros.org/index.php/Keeper_of_the_Keys">https://awoiaf.westeros.org/index.php/Keeper_of_the_Keys</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#212178907" name="212178907"><div>2020-10-03 16:22:21</div></a></div><div class="text"><p><span class="user-mention" data-user-id="251120">@Sandy Maguire</span> posted a quote in the FP chat slack that I thought perfect captures my feelings on this whole topic:</p>
<blockquote>
<p>nice quote from hamming that I think applies well to our community <br>
"In science if you know what you are doing you should not be doing it. <br>
In engineering if you do not know what you are doing you should not be doing it."</p>
</blockquote></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#212186024" name="212186024"><div>2020-10-03 19:20:10</div></a></div><div class="text"><p><span class="user-mention" data-user-id="254032">@Georgi Lyubenov // googleson78</span> I'm becoming increasingly suspicious of db types as domain types.</p>
<p>I recently did a refactor of many functions in a system passing around tons of arguments because it feels like the simple thing to do each time because the db type was very large.</p>
<p>These parameters could be meaningful seperated into 2-4 sensible types across these functions.</p>
<p>As a first pass I've just passed along the large db type at each step, which alone simplified things.</p>
<p>It also made it obvious what fields encoded as Maybe were being used for very important domain logic and would have been better described as a sum type.</p>
<p>Most of the fields in the large db type had to become optional, which made calling code needlessly difficult.</p>
<p>As a next pass I'll create more purposeful types and refactor the functions through the system to use those.</p>
<p>Then in the read/write parts just use toDBType/fromDBType functions.</p>
<p>This entire exercise on a medium sized piece of code was way harder and took way longer than stopping for a second to think up meaningful types would have been.</p>
<p>My key takeaway though is how "db type as domain type" effectively took this more ideal option off the table and discouraged even thinking in the direction of better abstractions.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#212186994" name="212186994"><div>2020-10-03 19:47:51</div></a></div><div class="text"><p>I would say that using very large data types, especially when you already know that significant parts are optional for a subprogram, is an antipattern in itself</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?version=5"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#212187041" name="212187041"><div>2020-10-03 19:48:51</div></a></div><div class="text"><p>optimally, use one datatype per function <span aria-label="upside down" class="emoji emoji-1f643" role="img" title="upside down">:upside_down:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#212187368" name="212187368"><div>2020-10-03 19:58:59</div></a></div><div class="text"><p>yeah I think it's not that you can't change them, but rather that the simple act of using the different types with a restriction on them limits the "way you think"</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#212187381" name="212187381"><div>2020-10-03 19:59:24</div></a></div><div class="text"><p>kind of like how people in other languages often don't use types to encode more correctness, even though they theoretically could, just because they're more cumbersome</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/8084ff35e892945a460a7ed9885325c7804e1b87?version=2"></a><div class="content"><a class="author">Rizary</a><div class="metadata"><a href="#212212070" name="212212070"><div>2020-10-04 08:08:41</div></a></div><div class="text"><p>I hate slack! I have linked in one of my thread that have the <code>XtoY</code> function using persistent.</p>
<p>anyway, <span class="user-mention" data-user-id="325194">@codygman</span> if you have any of your effort in the open, I would love to look into the code to learn more!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/ca2e2c3442a73f84394abb35d6236b12"></a><div class="content"><a class="author">Magnus Therning</a><div class="metadata"><a href="#212230941" name="212230941"><div>2020-10-04 16:54:34</div></a></div><div class="text"><p>Thanks <span class="user-mention" data-user-id="325194">@codygman</span>  for the terms "first-principles thinking" and "real-world thinking". I have a feeling these are at the heart of some discussions I've had with the Product Owner at work regarding hiring. I've never quite been able to put into words what it is that rubs me the wrong way with her arguments, but these terms might just have unlocked that.</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>