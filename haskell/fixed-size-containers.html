<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="Can anyone think of a type for which we can lawfully implement the following, but for which the adjective &quot;fixed size&quot; seems unnatural?
zip :: Applicative f =&gt; (f a, f b) -&gt; f (a, b)
zip = uncurry $ liftA2 (,)

husk :: Applicative f =&gt; () -&gt; f ()
husk = pure

unzip :: Functor f =&gt; f (a, b) -&gt; (f a, " name="description"><link href="https://funprog.srid.ca/haskell/fixed-size-containers.html" rel="canonical"><meta property="og:title" content="Fixed size containers - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2020-03-09T12:36:23Z"><meta property="og:article:published_time" content="2020-03-09T05:16:41Z"><title>Fixed size containers - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">Fixed size containers - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">Fixed size containers</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190042084" name="190042084"><div>2020-03-09 05:16:41</div></a></div><div class="text"><p>Can anyone think of a type for which we can lawfully implement the following, but for which the adjective "fixed size" seems unnatural?</p>
<div class="codehilite"><pre><span></span><span class="nf">zip</span> <span class="ow">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">,</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">zip</span> <span class="ow">=</span> <span class="n">uncurry</span> <span class="o">$</span> <span class="n">liftA2</span> <span class="p">(,)</span>

<span class="nf">husk</span> <span class="ow">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="nb">()</span>
<span class="nf">husk</span> <span class="ow">=</span> <span class="n">pure</span>

<span class="nf">unzip</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">,</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">unzip</span> <span class="n">fab</span> <span class="ow">=</span> <span class="p">(</span><span class="n">fst</span> <span class="o">&lt;$&gt;</span> <span class="n">fab</span><span class="p">,</span> <span class="n">snd</span> <span class="o">&lt;$&gt;</span> <span class="n">fab</span><span class="p">)</span>

<span class="nf">unhusk</span> <span class="ow">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">unhusk</span> <span class="ow">=</span> <span class="n">const</span> <span class="nb">()</span>

<span class="kr">class</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="kt">FixedSize</span> <span class="n">f</span>
<span class="c1">-- Laws:</span>
<span class="c1">-- unzip . zip = id</span>
<span class="c1">-- zip . unzip = id</span>
<span class="c1">-- husk . unhusk = id</span>
<span class="c1">-- unhusk . husk = id -- this one is trivial, only possible function of this type is @const ()@</span>
</pre></div>


<p>Some lawful examples for which the adjective does seem to be suitable are <code>Vec (n :: Nat)</code>, <code>(,) x</code>, and infinite <code>Stream</code>s</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190048080" name="190048080"><div>2020-03-09 08:19:23</div></a></div><div class="text"><p>This intrigues me. I wonder if we can prove that the size of the objects <code>f a</code> is the same. Actually, I wonder how to define the size of those objects. For functors, we can define a support set (informally the set of all objects that can be found in <code>x :: f a</code>) but stating that the support set of <code>f a</code>  and <code>f b</code> have the same size won't work because of the possibility of duplicates.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190048458" name="190048458"><div>2020-03-09 08:28:19</div></a></div><div class="text"><p><span class="user-mention" data-user-id="250796">@Simon Hudon</span> I was thinking about something like demanding the partial derivative of the functor with respect to its parameter to be constant. Of course what exactly partial derivative means in this context is a little bit up in the air. Do we talk about the partial derivative of the "size functions"? Do we use the zipper notion of partial derivatives?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190048472" name="190048472"><div>2020-03-09 08:28:49</div></a></div><div class="text"><p>I asked a question here in case you come up with a solution: <a href="https://stackoverflow.com/questions/60596097/are-all-fixed-size-containers-strong-monoidal-functors-and-vice-versa" target="_blank" title="https://stackoverflow.com/questions/60596097/are-all-fixed-size-containers-strong-monoidal-functors-and-vice-versa">https://stackoverflow.com/questions/60596097/are-all-fixed-size-containers-strong-monoidal-functors-and-vice-versa</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://stackoverflow.com/questions/60596097/are-all-fixed-size-containers-strong-monoidal-functors-and-vice-versa" style="background-image: url(https://cdn.sstatic.net/Sites/stackoverflow/img/apple-touch-icon@2.png?v=73d79a89bded)" target="_blank"></a><div class="data-container"><div class="message_embed_title"><a href="https://stackoverflow.com/questions/60596097/are-all-fixed-size-containers-strong-monoidal-functors-and-vice-versa" target="_blank" title="Are all fixed size containers strong monoidal functors, and vice versa?">Are all fixed size containers strong monoidal functors, and vice versa?</a></div><div class="message_embed_description">The Applicative typeclass represents lax monoidal functors that preserve the cartesian monoidal structure on the category of typed functions.

In other words, given the canonical isomorphisms witne...</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190048710" name="190048710"><div>2020-03-09 08:33:56</div></a></div><div class="text"><p>btw I don't quite understand your support set idea. isn't the set of all elements that can be found in <code>f a</code> just <code>f a</code> (to the limited extent that types are sets)?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190048788" name="190048788"><div>2020-03-09 08:35:43</div></a></div><div class="text"><p>I like your <code>Strange</code> example. I think it shows that some fixed size containers are not <code>StrongApplicative</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190048866" name="190048866"><div>2020-03-09 08:36:59</div></a></div><div class="text"><p>do you mean are not?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190048893" name="190048893"><div>2020-03-09 08:37:56</div></a></div><div class="text"><p>Indeed :) in my defense, most of the words were there</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190048953" name="190048953"><div>2020-03-09 08:39:03</div></a></div><div class="text"><p>Here is formally what I mean by support with dependent ypes:</p>
<div class="codehilite"><pre><span></span>support (x : f a) = ⋂ s : set a, ∃ y : f { y : a // y ∈ s }, val &lt;$&gt; y = x
</pre></div>


<p>Basically, for <code>x : f a</code>, it is the smallest set <code>s</code> such that you can construct a replica of <code>x</code> that contains all the same "stuff" as <code>x</code> and every object of type <code>a</code> it contains, is paired with a proof that that object is a member of <code>s</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190049041" name="190049041"><div>2020-03-09 08:41:08</div></a></div><div class="text"><p>Note: <code>{ y : a // y ∈ s }</code> is a dependent type "subtype", or, as I call it above, a pair of an <code>a</code> with the proof that that <code>a</code> is a member of <code>s</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190049117" name="190049117"><div>2020-03-09 08:42:40</div></a></div><div class="text"><p>Unfortunately I'm not super familiar with this notation, so I have to ask some baby level questions. e.g. does <code>set a</code> mean the set of sets of elements of type <code>a</code>?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190049209" name="190049209"><div>2020-03-09 08:44:12</div></a></div><div class="text"><p>Almost: <code>set a</code> is the type of the sets of type <code>a</code>. <code>:</code> is Haskell's <code>::</code> (I'm using Lean notation for my dependent types)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190049223" name="190049223"><div>2020-03-09 08:44:50</div></a></div><div class="text"><p>(also, don't worry about baby level questions)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190049360" name="190049360"><div>2020-03-09 08:47:47</div></a></div><div class="text"><p>Is <code>⋂</code> an intersection of a family of sets or is it forall?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190049419" name="190049419"><div>2020-03-09 08:49:08</div></a></div><div class="text"><p>It is an intersection of a family of set. When I said "the smallest set such as", that's what I was referring to</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190049429" name="190049429"><div>2020-03-09 08:49:28</div></a></div><div class="text"><p>does this include the empty set?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190049538" name="190049538"><div>2020-03-09 08:51:56</div></a></div><div class="text"><p>Only if it satisfies the condition. You'd have to build a value of type <code>f { x : a // x ∈ ∅ }</code> which you can only do if <code>f</code> can contain no objects.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190049813" name="190049813"><div>2020-03-09 08:57:08</div></a></div><div class="text"><p>Now that I'm thinking about it maybe I'm also wrong about the writer applicative</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190049823" name="190049823"><div>2020-03-09 08:57:18</div></a></div><div class="text"><p>being <code>StrongApplicative</code> that is</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190049920" name="190049920"><div>2020-03-09 08:58:49</div></a></div><div class="text"><p><code>husk = (mempty,)</code>, so is it really true that <code>husk . (const ()) = id</code>?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190050106" name="190050106"><div>2020-03-09 09:01:33</div></a></div><div class="text"><p>e.g. <code>("hello", ()) /= husk $ unhusk $ ("hello", ())</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190050114" name="190050114"><div>2020-03-09 09:01:43</div></a></div><div class="text"><p>No, that does work. Consider your monoid is <code>[a]</code> and you apply <code>const ()</code> to <code>([1,2,3],())</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190050120" name="190050120"><div>2020-03-09 09:01:49</div></a></div><div class="text"><p>indeed</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190050254" name="190050254"><div>2020-03-09 09:03:55</div></a></div><div class="text"><p>You gave the example on Stack Overflow of <code>(,) x</code>. Does this mean that isn’t <code>StrongApplicative</code> either? If so, that would be interesting, because I suggested that as an example of a <code>Representable</code> functor which isn’t <code>StrongApplicative</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190050311" name="190050311"><div>2020-03-09 09:04:19</div></a></div><div class="text"><p>I think we could say that, for each <code>f</code> that satisfies <code>StrongApplicative</code>, there must exist a type <code>t</code> such that <code>f a</code> and <code>t -&gt; a</code> are in bijection with each other. Basically, no extra data and only objects mapped to some abstract position</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190050346" name="190050346"><div>2020-03-09 09:05:05</div></a></div><div class="text"><p><span class="user-mention" data-user-id="250796">@Simon Hudon</span> That’s the definition of <code>Representable</code>! So if that’s true, <code>StrongApplicative</code> is equivalent to <code>Representable</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190050363" name="190050363"><div>2020-03-09 09:05:32</div></a></div><div class="text"><p><span class="user-mention" data-user-id="269918">@bradrn</span> Yes, my example is wrong</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190050385" name="190050385"><div>2020-03-09 09:05:54</div></a></div><div class="text"><p><span class="user-mention" data-user-id="269918">@bradrn</span> Do you think there's a way to implement <code>Representable</code> in terms of <code>StrongApplicative</code> and vice versa?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190050439" name="190050439"><div>2020-03-09 09:06:29</div></a></div><div class="text"><p><span class="user-mention" data-user-id="225136">@Asad Saeeduddin</span>  I’m trying to figure that out now.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190050555" name="190050555"><div>2020-03-09 09:08:28</div></a></div><div class="text"><p>I’ve already run into a problem: I have no idea how to define the associated type <code>Rep f</code> given only the knowledge that <code>f</code> is <code>Applicative</code> and <code>OpApplicative</code>. Any ideas?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190050562" name="190050562"><div>2020-03-09 09:08:43</div></a></div><div class="text"><p>I can't think of a way to do that either</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190050567" name="190050567"><div>2020-03-09 09:08:55</div></a></div><div class="text"><p>you could maybe take the representation to be a natural number and walk over each position</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190050690" name="190050690"><div>2020-03-09 09:11:16</div></a></div><div class="text"><p>I was thinking along the same lines, but that doesn’t really lend itself to figuring out a concrete solution.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190050706" name="190050706"><div>2020-03-09 09:11:35</div></a></div><div class="text"><p>You'd need an instance of traversable or foldable and you would't get an answer for infinite streams</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190050749" name="190050749"><div>2020-03-09 09:12:03</div></a></div><div class="text"><p>aren't the natural numbers infinite?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190050768" name="190050768"><div>2020-03-09 09:12:16</div></a></div><div class="text"><p><span class="user-mention" data-user-id="250796">@Simon Hudon</span> Why would <code>Traversable</code> or <code>Foldable</code> needed?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190050808" name="190050808"><div>2020-03-09 09:13:11</div></a></div><div class="text"><p>Otherwise, you don't have enough to pass a counter from one element to the next</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190050813" name="190050813"><div>2020-03-09 09:13:20</div></a></div><div class="text"><p><span class="user-mention" data-user-id="269918">@bradrn</span> I think the easier starting point might be the other direction. Maybe it is true that every <code>Representable</code> is <code>StrongApplicative</code> but not necessarily vice versa (or at least constructively vice versa)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/6bc72887d0b9f71cdbc2eeb5f9899d8f"></a><div class="content"><a class="author">Simon Hudon</a><div class="metadata"><a href="#190050826" name="190050826"><div>2020-03-09 09:13:51</div></a></div><div class="text"><p>I think that direction is easy to prove</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190050828" name="190050828"><div>2020-03-09 09:13:58</div></a></div><div class="text"><p><span class="user-mention" data-user-id="225136">@Asad Saeeduddin</span> I’ll try doing that then.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190050832" name="190050832"><div>2020-03-09 09:14:02</div></a></div><div class="text"><p>Wouldn't it be fairly straightforward to convert to a function and then exploit its strong applicative?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190050882" name="190050882"><div>2020-03-09 09:14:30</div></a></div><div class="text"><p>Assuming I haven't screwed that one up as well and functions really are <code>StrongApplicative</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190050893" name="190050893"><div>2020-03-09 09:14:52</div></a></div><div class="text"><p><span class="user-mention" data-user-id="225136">@Asad Saeeduddin</span> Yes, I think that would work. Of course you’d still need to prove the laws…</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190051123" name="190051123"><div>2020-03-09 09:18:58</div></a></div><div class="text"><p>Implementations:</p>
<div class="codehilite"><pre><span></span>instance Representable f =&gt; Applicative f where
    zip (fa, fb) = tabulate $ zip (index fa, index fb)
    husk () = tabulate $ const ()

instance Representable f =&gt; OpApplicative f where
    unzip fab = let (fa, fb) = unzip (index fab) in (tabulate fa, tabulate fb)
    unhusk = const ()
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190051205" name="190051205"><div>2020-03-09 09:20:23</div></a></div><div class="text"><p>very nice</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190051222" name="190051222"><div>2020-03-09 09:20:45</div></a></div><div class="text"><p>Now I’ll see if this satisfies the laws</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190051246" name="190051246"><div>2020-03-09 09:20:56</div></a></div><div class="text"><p><code>unhusk . husk = id</code> is trivial</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190051503" name="190051503"><div>2020-03-09 09:24:59</div></a></div><div class="text"><p>Wait, I think my implementation of <code>husk</code> is wrong. It should be <code>husk () =  tabulate $ const $ return ()</code>, I think.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190051580" name="190051580"><div>2020-03-09 09:26:07</div></a></div><div class="text"><p>isn't that what you have?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190051598" name="190051598"><div>2020-03-09 09:26:28</div></a></div><div class="text"><p>Only because I just edited it. Before it was <code>tabulate $ const ()</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190051614" name="190051614"><div>2020-03-09 09:26:54</div></a></div><div class="text"><p>is <code>return</code> the one for the function monad?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190051657" name="190051657"><div>2020-03-09 09:27:34</div></a></div><div class="text"><p>Oh wait, I was right in the first place. <code>tabulate :: (Rep f -&gt; a) -&gt; f a</code>, so <code>tabulate (const ()) :: f ()</code>. I’ll edit it back.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190051748" name="190051748"><div>2020-03-09 09:28:45</div></a></div><div class="text"><p>more obvious it's right if we just write <code>husk = tabulate . husk</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190051775" name="190051775"><div>2020-03-09 09:29:31</div></a></div><div class="text"><p>That makes sense as well. So does <code>husk = tabulate (return ())</code>, which works a bit better with the laws for <code>Representable</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190051863" name="190051863"><div>2020-03-09 09:30:22</div></a></div><div class="text"><p>does that actually typecheck?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190051929" name="190051929"><div>2020-03-09 09:31:50</div></a></div><div class="text"><p>I <em>think</em> so… for functions, <code>return = husk = const</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190052029" name="190052029"><div>2020-03-09 09:32:57</div></a></div><div class="text"><p>well the codomain of <code>tabulate</code> is <code>f a</code>, but the type of <code>husk</code> is <code>() -&gt; f ()</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190052034" name="190052034"><div>2020-03-09 09:33:04</div></a></div><div class="text"><p>so you need an extra parameter in there at least</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190052050" name="190052050"><div>2020-03-09 09:33:25</div></a></div><div class="text"><p>if you did <code>tabulate . return</code> or <code>husk _ = tabulate (return ())</code> i think it makes sense</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190052140" name="190052140"><div>2020-03-09 09:34:42</div></a></div><div class="text"><p>Oh yes, I forgot that. But you can see that I included it in my original <code>Applicative</code> instance above.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190052190" name="190052190"><div>2020-03-09 09:36:01</div></a></div><div class="text"><p>But after thinking about it, I like <code>husk = tabulate . return</code> much better.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190052244" name="190052244"><div>2020-03-09 09:36:27</div></a></div><div class="text"><p>Or even <code>husk = tabulate . husk</code>, which you suggested earlier.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190052288" name="190052288"><div>2020-03-09 09:37:43</div></a></div><div class="text"><p>If we can show that <code>tabulate</code> and <code>index</code> form not just a bijection but an applicative preserving isomorphism, we will have automatically that your instance is lawful</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190052330" name="190052330"><div>2020-03-09 09:38:03</div></a></div><div class="text"><p>I’m not quite sure I understand this…</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190052382" name="190052382"><div>2020-03-09 09:38:55</div></a></div><div class="text"><p>the idea is that a function can be more than just a mere function, it can preserve some structure that exists on both its domain and codomain types</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190052424" name="190052424"><div>2020-03-09 09:39:54</div></a></div><div class="text"><p>for example you could have a monoid homomorphism <code>f :: M -&gt; N</code> for two monoids <code>M</code> and <code>N</code>, that preserves the monoid structure in the following way:</p>
<div class="codehilite"><pre><span></span>f x &lt;&gt; f y = f $ x &lt;&gt; y
f mempty = mempty
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190052488" name="190052488"><div>2020-03-09 09:40:18</div></a></div><div class="text"><p>I understand now. But how would we prove that about <code>tabulate</code> and <code>index</code>?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190052500" name="190052500"><div>2020-03-09 09:40:51</div></a></div><div class="text"><p>for <code>tabulate</code> we'd require:</p>
<div class="codehilite"><pre><span></span>zip (tabulate x, tabulate y) = tabulate $ zip (x, y)
tabulate . husk = husk
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190052591" name="190052591"><div>2020-03-09 09:42:12</div></a></div><div class="text"><p>for <code>index :: f a -&gt; (Rep f -&gt; a)</code>, we'd require the same thing:</p>
<div class="codehilite"><pre><span></span>zip (index x, index y) = index $ zip (x, y)
index . husk = husk
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190052704" name="190052704"><div>2020-03-09 09:44:24</div></a></div><div class="text"><p>That makes sense, but I’m not sure how it would help… Recall that we constructed <code>Applicative</code> and <code>OpApplicative</code> by converting <code>f a</code> to <code>r -&gt; a</code> with <code>Representable</code>, then using the <code>(-&gt;) r</code> instances of <code>Applicative</code>/<code>OpApplicative</code> to perform the ‘core’ computations, then use <code>Representable</code> to convert <code>r -&gt; a</code> back to <code>f a</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190052709" name="190052709"><div>2020-03-09 09:44:33</div></a></div><div class="text"><p>I guess that doesn't really help us get anywhere, it just gives us an alternate proof burden. But assuming we can prove that we would have that the instance is lawful</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190052853" name="190052853"><div>2020-03-09 09:47:32</div></a></div><div class="text"><p><span class="user-mention" data-user-id="269918">@bradrn</span> Right. What I mean is because of the way you've constructed the <code>Applicative</code> instance out of the <code>Representable</code> isomorphism + the <code>Applicative</code> instance of <code>(-&gt;) r</code>, having a slightly stronger "applicative preserving" property about the <code>Representable</code> isomorphism's components gives us legality of the instance</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190052921" name="190052921"><div>2020-03-09 09:48:29</div></a></div><div class="text"><p>Do you have a proof that “applicative preservation” implies legality? I’d like to see how that works.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190053084" name="190053084"><div>2020-03-09 09:51:12</div></a></div><div class="text"><p>Yes. Your instance is effectively this:</p>
<div class="codehilite"><pre><span></span>instance Representable f =&gt; Applicative f where
  zip = tabulate . zip . bimap index index
  husk = tabulate . husk
</pre></div>


<p>Let's assume that the the <code>zip</code> and <code>husk</code> for functions that we're using on the RHS is legal</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190053180" name="190053180"><div>2020-03-09 09:52:39</div></a></div><div class="text"><p>Now the thing about monoidal functors/applicatives is that they're actually just monoid objects in the functor category under Day convolution. And like in any monoidal category, you can have "monoid morphisms" that preserve the monoid structure</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190053212" name="190053212"><div>2020-03-09 09:53:20</div></a></div><div class="text"><p>here is the definition and relevant diagrams copy pasted from wikipedia</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190053214" name="190053214"><div>2020-03-09 09:53:25</div></a></div><div class="text"><p><a href="/user_uploads/13896/Kk56R3CgJ4svTw_E9tkMqgtv/image.png" target="_blank" title="image.png">image.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/13896/Kk56R3CgJ4svTw_E9tkMqgtv/image.png" target="_blank" title="image.png"><img src="/user_uploads/13896/Kk56R3CgJ4svTw_E9tkMqgtv/image.png"></a></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190053275" name="190053275"><div>2020-03-09 09:54:12</div></a></div><div class="text"><p>I’m not sure I know enough category theory to understand this…</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190053421" name="190053421"><div>2020-03-09 09:56:24</div></a></div><div class="text"><p>But I do think I understand the idea of a monoid morphism. A function <code>f :: (Monoid m, Monoid n) =&gt; m -&gt; n</code> is a monoid morphism iff <code>f mempty == mempty</code> and <code>f (x &lt;&gt; y) == (f x) &lt;&gt; (f y)</code>, right?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190053424" name="190053424"><div>2020-03-09 09:56:30</div></a></div><div class="text"><p>exactly</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190053432" name="190053432"><div>2020-03-09 09:56:39</div></a></div><div class="text"><p>but that "such that" is actually bidirectional</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190053460" name="190053460"><div>2020-03-09 09:57:30</div></a></div><div class="text"><p>True. Probably ‘if and only if’ would have been better.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190053598" name="190053598"><div>2020-03-09 09:59:40</div></a></div><div class="text"><p>in that if:</p>
<ul>
<li>for some values <code>mempty_n :: n</code> and <code>(&lt;&gt;_n) :: n -&gt; n -&gt; n</code></li>
<li>some monoid <code>m</code></li>
<li>some monoid morphism <code>f :: m -&gt; n</code></li>
<li>it is the case that <code>f mempty = mempty_n</code> and <code>f (x &lt;&gt; y) = f x &lt;&gt;_n f y</code></li>
</ul>
<p>then <code>n, mempty_n, &lt;&gt;_n</code> is a monoid</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190053868" name="190053868"><div>2020-03-09 10:02:07</div></a></div><div class="text"><p>that's what I mean about the applicative thing. you already know <code>(-&gt;) (Rep f)</code> is an applicative. if you additionally show that the isomorphism <code>tabulate :: (-&gt;) (Rep f) ~&gt; f</code>, <code>index :: f ~&gt; (-&gt;) (Rep f)</code> preserves that applicative, you'll have that <code>f</code> is an applicative</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190054199" name="190054199"><div>2020-03-09 10:06:29</div></a></div><div class="text"><p>Yes, now I understand! Thank you for explaining!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190054332" name="190054332"><div>2020-03-09 10:08:17</div></a></div><div class="text"><p>But how could we prove that <code>tabulate</code> and <code>index</code> are applicative-preserving? (And I think they need to be op-applicative preserving as well.)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190054523" name="190054523"><div>2020-03-09 10:11:12</div></a></div><div class="text"><p><span class="user-mention" data-user-id="225127">@TheMatten</span> Do we have lambdabot here?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190054551" name="190054551"><div>2020-03-09 10:11:44</div></a></div><div class="text"><p><span class="user-mention" data-user-id="269918">@bradrn</span> Sadly I'm not sure. What I'm hoping is that this mostly comes out of the free theorems of the types</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190054612" name="190054612"><div>2020-03-09 10:12:14</div></a></div><div class="text"><p>My implementation again for reference:</p>
<div class="codehilite"><pre><span></span>instance Representable f =&gt; Applicative f where
    zip (fa, fb) = tabulate $ zip (index fa, index fb)
    husk () = tabulate $ const ()

instance Representable f =&gt; OpApplicative f where
    unzip fab = let (fa, fb) = unzip (index fab) in (tabulate fa, tabulate fb)
    unhusk = const ()
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190054633" name="190054633"><div>2020-03-09 10:12:34</div></a></div><div class="text"><p>I’m thinking that it could potentially be easier to prove them directly from the implementation.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190054663" name="190054663"><div>2020-03-09 10:13:15</div></a></div><div class="text"><p>Btw you don't need to write that <code>OpApplicative</code> by hand. <code>(-&gt;) (Rep f)</code>'s <code>OpApplicative</code> is no different from the trivial one for any other <code>Functor</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190054782" name="190054782"><div>2020-03-09 10:14:32</div></a></div><div class="text"><p>Oh… somehow I missed that all <code>Functor</code>s are <code>OpApplicative</code>!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190054792" name="190054792"><div>2020-03-09 10:14:50</div></a></div><div class="text"><p>That said, yes if you can figure out a way to prove it by hand that could work. I don't see one off the top of my head :)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190054802" name="190054802"><div>2020-03-09 10:15:02</div></a></div><div class="text"><p>To copy your implementation from SO:</p>
<div class="codehilite"><pre><span></span>instance Functor f =&gt; OpApplicative f
  where
  unzip fab = (fst &lt;$&gt; fab, snd &lt;$&gt; fab)
  unhusk = const ()
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190055013" name="190055013"><div>2020-03-09 10:18:40</div></a></div><div class="text"><p><code>husk . unhusk</code> reduces to <code>\x -&gt; tabulate $ const () == \x -&gt; tabulate $ husk ()</code>, so I don’t think there’s any way around showing that <code>tabulate</code> preserves applicatives.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190055125" name="190055125"><div>2020-03-09 10:20:12</div></a></div><div class="text"><p>hmm. I wonder if that's just an irreducible law that you have to demand in order for your <code>Representable</code> to give you an <code>Applicative</code>, as opposed to something you can prove</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190055183" name="190055183"><div>2020-03-09 10:21:40</div></a></div><div class="text"><p>A law of <code>Representable</code> is <code>tabulate . return == return</code>. But <code>return == husk</code> for functions, so <code>tabulate $ husk () == return ()</code>.  Not quite sure how that helps though.</p>
<p>(In fact, that <code>Representable</code> law is quite weird: it essentially requires <code>f</code> to be an <code>Applicative</code>, but <code>Representable</code> only demands <code>f</code> to be a <code>Functor</code>!)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190055309" name="190055309"><div>2020-03-09 10:23:38</div></a></div><div class="text"><p>Wait a sec, is the second <code>return</code> in <code>tabulate . return = return</code> of type <code>a -&gt; f a</code>?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190055331" name="190055331"><div>2020-03-09 10:24:00</div></a></div><div class="text"><p>Yes</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190055394" name="190055394"><div>2020-03-09 10:24:28</div></a></div><div class="text"><p>well, that proves 1/2 things necessary to show that <code>tabulate</code> preserves applicatives, right?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190055417" name="190055417"><div>2020-03-09 10:24:53</div></a></div><div class="text"><p>here's what we need for <code>tabulate</code> again:</p>
<div class="codehilite"><pre><span></span>zip (tabulate x, tabulate y) = tabulate $ zip (x, y)
tabulate . husk = husk
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190055442" name="190055442"><div>2020-03-09 10:25:17</div></a></div><div class="text"><p>Excellent point! I can’t believe I didn’t notice that…</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190055459" name="190055459"><div>2020-03-09 10:25:35</div></a></div><div class="text"><p>so the second one is satisfied. where did you find this theorem about <code>Representable</code>?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190055461" name="190055461"><div>2020-03-09 10:25:39</div></a></div><div class="text"><p>But the first point could be tricker. Perhaps it may be necessary to assume it as a law.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190055485" name="190055485"><div>2020-03-09 10:25:58</div></a></div><div class="text"><p><span class="user-mention" data-user-id="225136">@Asad Saeeduddin</span> I found it listed in the representable laws <a href="https://www.stackage.org/haddock/lts-15.3/adjunctions-4.4/Data-Functor-Rep.html#t:Representable" target="_blank" title="https://www.stackage.org/haddock/lts-15.3/adjunctions-4.4/Data-Functor-Rep.html#t:Representable">here</a>:</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190055496" name="190055496"><div>2020-03-09 10:26:02</div></a></div><div class="text"><p>maybe we'll find the other law somewhere in there too</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190055531" name="190055531"><div>2020-03-09 10:26:07</div></a></div><div class="text"><div class="codehilite"><pre><span></span>tabulate . index  ≡ id
index . tabulate  ≡ id
tabulate . return ≡ return
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190055581" name="190055581"><div>2020-03-09 10:27:11</div></a></div><div class="text"><p>interesting. as far as I know the concept of a representable functor doesn't really involve the third law, but it seems they just demanded a bonus law for <code>Representable</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190055586" name="190055586"><div>2020-03-09 10:27:15</div></a></div><div class="text"><p>which just happened to be the one we need</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190055603" name="190055603"><div>2020-03-09 10:27:38</div></a></div><div class="text"><p>Yes, I found that to be very strange as well. Especially since not all <code>f</code>s have <code>return</code>!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190055728" name="190055728"><div>2020-03-09 10:28:50</div></a></div><div class="text"><p>i think this does point to the extra laws being irreducible. you just have to demand them somewhere (whether in <code>Representable</code>, or somewhere in the constraints for your <code>Representable f =&gt; Applicative f</code> declaration)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190055874" name="190055874"><div>2020-03-09 10:30:48</div></a></div><div class="text"><p>I think I agree as well. Do we agree then that if <code>f</code> is <code>Representable</code> and its <code>Representable</code> instance preserves applicatives, then that implies that <code>f</code> is <code>StrongApplicative</code>?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190056001" name="190056001"><div>2020-03-09 10:32:15</div></a></div><div class="text"><p>I think it indicates at least that it is <code>Applicative</code>. We can add an "strong applicative preserving" requirement for the components of the isomorphism, and then we'll get that <code>f</code> is <code>StrongApplicative</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190056058" name="190056058"><div>2020-03-09 10:33:15</div></a></div><div class="text"><p>Alright then. That makes sense.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190056108" name="190056108"><div>2020-03-09 10:34:02</div></a></div><div class="text"><p>I can’t help but feel though that we haven’t made much progress on your original question: is <code>StrongApplicative</code> equivalent to being of ‘fixed shape’? Or, in other words, are there any <code>StrongApplicative</code>s which aren’t of fixed shape?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190056274" name="190056274"><div>2020-03-09 10:36:30</div></a></div><div class="text"><p>I guess determining some <code>Representable</code> functors are <code>StrongApplicative</code> is still focused on the other half of the question (which in the global case we've already answered in the negative)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190056340" name="190056340"><div>2020-03-09 10:37:59</div></a></div><div class="text"><p>we can maybe moderate that negated conjecture and say that those fixed shape functors that are <code>Representable</code>, and whose representation preserves applicatives, are <code>StrongApplicative</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190056383" name="190056383"><div>2020-03-09 10:38:09</div></a></div><div class="text"><p>and then that much (I think) is true</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190056405" name="190056405"><div>2020-03-09 10:38:44</div></a></div><div class="text"><p>I agree. But I think the much more interesting question is: are all <code>StrongApplicative</code> functors <code>Representable</code>? (even if not constructively)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190056413" name="190056413"><div>2020-03-09 10:38:50</div></a></div><div class="text"><p>you're right in that we still didn't make any progress on discovering any variable shape containers that are <code>StrongApplicative</code> (or showing that all <code>StrongApplicative</code> containers are of fixed shape)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190056425" name="190056425"><div>2020-03-09 10:39:08</div></a></div><div class="text"><p>I guess implementing <code>Representable</code> from <code>StrongApplicative</code> would conclusively settle that question</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190056521" name="190056521"><div>2020-03-09 10:40:09</div></a></div><div class="text"><p>I don’t see any way of implementing <code>Representable</code> until we can figure out how to get <code>Rep f</code> given <code>f</code> is <code>StrongApplicative</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190056581" name="190056581"><div>2020-03-09 10:41:19</div></a></div><div class="text"><blockquote>
<p>are all StrongApplicative functors Representable? (even if not constructively)</p>
</blockquote>
<p>I can't begin to imagine how to answer this in the positive (especially lacking the constructivity qualifier). If it is in fact false finding the counterexample might be easier</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190056614" name="190056614"><div>2020-03-09 10:41:53</div></a></div><div class="text"><p>So far what's left of the <code>StrongApplicative</code> list certainly seems to admit <code>Representable</code> instances for each item</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190057400" name="190057400"><div>2020-03-09 10:52:22</div></a></div><div class="text"><p>Honestly, I doubt there’s any easy answer to this.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190057401" name="190057401"><div>2020-03-09 10:52:24</div></a></div><div class="text"><p>I have to go now, but I’ll keep on thinking about it — I’ll post here if I have any ideas.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190060313" name="190060313"><div>2020-03-09 11:38:15</div></a></div><div class="text"><p><span class="user-mention" data-user-id="225136">@Asad Saeeduddin</span> I think I’ve found a proof that a <code>StrongApplicative</code> must be of fixed shape! I’ll write it up now.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190060488" name="190060488"><div>2020-03-09 11:42:31</div></a></div><div class="text"><p>Proof: For a <code>StrongApplicative</code>, the law <code>husk . unhusk == id</code> must hold; that is, for any <code>x :: f ()</code>, <code>husk (unhusk x) == x</code>. But in Haskell, <code>unhusk == const ()</code>, so this law is equivalent to saying that for any <code>x :: f ()</code>, <code>husk () == x</code>. By the transitivity of equality, this then means that there can only exist one distinct value of type <code>f ()</code>: if <code>x, y :: f ()</code>, then <code>x == husk ()</code> and <code>y == husk ()</code>, so <code>x == y</code>. But this is only possible if <code>f</code> has a fixed shape (if <code>f</code> has multiple possible shapes, then for each shape there is a corresponding value of type <code>f ()</code>). Thus <code>husk . unhusk == id</code> implies that there exists only one distinct value of type <code>f ()</code>, and hence that <code>f</code> has a fixed shape.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190061341" name="190061341"><div>2020-03-09 11:58:58</div></a></div><div class="text"><p>That's very interesting. I don't quite follow the "transitivity of equality" step though. What does that mean?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190061363" name="190061363"><div>2020-03-09 11:59:31</div></a></div><div class="text"><p>All it means is that if <code>x == husk ()</code> and <code>y == husk ()</code>, then <code>x == y</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190061368" name="190061368"><div>2020-03-09 11:59:41</div></a></div><div class="text"><p>ah, ok</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190061607" name="190061607"><div>2020-03-09 12:03:36</div></a></div><div class="text"><p>hmm. so essentially you are saying if <code>f ()</code> is a singleton, then <code>f</code> is of fixed shape</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/89529ef093c72e16a5ce3ac00d88f354ccc08cf9?version=2"></a><div class="content"><a class="author">Lysxia</a><div class="metadata"><a href="#190061880" name="190061880"><div>2020-03-09 12:07:38</div></a></div><div class="text"><p>sounds like a decent enough definition</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190062116" name="190062116"><div>2020-03-09 12:11:21</div></a></div><div class="text"><p><span class="user-mention" data-user-id="225136">@Asad Saeeduddin</span> Yes, that is what I’m saying. I believe this definition captures the idea of ‘fixed shape’: <code>()</code> is a singleton, so if we substitute <code>a</code> with <code>()</code> in <code>f a</code>, then <code>f ()</code> can only be a non-singleton if there is variation in <code>f</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190062204" name="190062204"><div>2020-03-09 12:12:28</div></a></div><div class="text"><p>it's interesting, because this ties in to representability a bit. the Yoneda lemma implies that for any functor <code>f</code>, <code>f ()</code> is isomorphic to <code>forall x. (() -&gt; x) -&gt; f x</code>, which I guess decomposes to:</p>
<div class="codehilite"><pre><span></span>fwd :: (forall x. x -&gt; f x) -&gt; f ()
bwd :: f () -&gt; (forall x. x -&gt; f x)
</pre></div>


<p>If <code>f ()</code> is a singleton, then <code>bwd (unique :: f ())</code> gives us something that looks a lot like <code>pure :: forall x. x -&gt; f x</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190062280" name="190062280"><div>2020-03-09 12:13:55</div></a></div><div class="text"><p>anyway I find that proof convincing <span class="user-mention" data-user-id="269918">@bradrn</span>. If you add it as an answer I can accept it</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190062290" name="190062290"><div>2020-03-09 12:14:01</div></a></div><div class="text"><p>Interesting! That connection hadn’t occurred to me.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190062331" name="190062331"><div>2020-03-09 12:14:09</div></a></div><div class="text"><p>I’ll add my proof as an answer then.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190062859" name="190062859"><div>2020-03-09 12:23:00</div></a></div><div class="text"><p><span class="user-mention" data-user-id="225136">@Asad Saeeduddin</span> I’ve added it.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190062868" name="190062868"><div>2020-03-09 12:23:08</div></a></div><div class="text"><p>I guess this connection isn't really surprising, I'm just restating that <code>husk</code> and <code>unhusk</code> form a bijection in a really roundabout way (one of the types involved being the singleton <code>()</code>)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190063002" name="190063002"><div>2020-03-09 12:25:38</div></a></div><div class="text"><p>I have to go now <span class="user-mention" data-user-id="225136">@Asad Saeeduddin</span> (it’s getting really late where I am), but thanks for discussing this with me — I’ve found it fascinating! I’m glad I’ve been able to help.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190063013" name="190063013"><div>2020-03-09 12:25:53</div></a></div><div class="text"><p>Yup, likewise. Thanks for the help!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#190063084" name="190063084"><div>2020-03-09 12:26:42</div></a></div><div class="text"><p>You’re welcome!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#190063689" name="190063689"><div>2020-03-09 12:36:23</div></a></div><div class="text"><p>by composing some isomorphisms it turns out that <code>f ()</code> being a singleton implies <code>forall x. x -&gt; f x</code> being a singleton. so <code>StrongApplicative</code> functors are those for which you can only define <code>pure</code> in one way</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>