<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="I&#39;ve been playing with Haskell for one and a half years now. I believe I have a good grasp of the basics and I am aware of many concepts. I keep seeing people talk about stuff like effect systems, recursion schemes, and lenses. I believe there is more to these concepts than simply using some library" name="description"><link href="https://funprog.srid.ca/haskell/where-to-go-from-here.html" rel="canonical"><meta property="og:title" content="Where to go from here - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2021-03-10T07:47:26Z"><meta property="og:article:published_time" content="2021-03-05T14:38:16Z"><meta property="og:image" content="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?version=2"><title>Where to go from here - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">Where to go from here - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">Where to go from here</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#228963583" name="228963583"><div>2021-03-05 14:38:16</div></a></div><div class="text"><p>I've been playing with Haskell for one and a half years now. I believe I have a good grasp of the basics and I am aware of many concepts. I keep seeing people talk about stuff like effect systems, recursion schemes, and lenses. I believe there is more to these concepts than simply using some library.</p>
<p>I'd like to learn how to use those concepts (and others). I'd love to hear suggestions on how/where to learn those concepts. I am a theory/project driven learners, so I'd love to get some pointers to learning material and some interesting project suggestions to apply those projects.</p>
<p>Also, I don't know exactly how to name what I know/what I have used. I've seen people say stuff such as "I've learned mtl", which I find a bewildering claim. I've used mtl, but haven't dealt with big monad transformers stacks, for example, so I don't feel confident in saying "I know mtl" (or if that statement even makes sense).</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#228966747" name="228966747"><div>2021-03-05 14:58:25</div></a></div><div class="text"><p>what are your biggest pain points with hs so far?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/2769c37f18b3ff7bbc404d34db71f6e0"></a><div class="content"><a class="author">Peter J. Jones</a><div class="metadata"><a href="#228971038" name="228971038"><div>2021-03-05 15:23:39</div></a></div><div class="text"><p>I think it's worth noting that you can write amazing Haskell programs without ever learning or using any of those technologies.  There's even a (smallish?) movement to push back against some of those advanced techniques called <a href="https://www.simplehaskell.org/">Simple Haskell</a>.</p>
<p>It seems to me that the community is always going to be talking about and using some technology, technique, or abstraction that I've never heard of.  I think Haskell attracts people that are interested in learning and who are always pushing themselves to write better code whether it's using cutting edge research or some forgotten technique from the 1920s.</p>
<p>Here's my advice to you:</p>
<ol>
<li>
<p>Keep writing code.  It's okay that you don't know those things right now.</p>
</li>
<li>
<p>When you hear a new term or technology being thrown around don't be afraid to ask for a link to a tutorial or for someone to define what they are talking about.  Then do a little reading and don't be hard on yourself if nothing makes sense on the first pass.  Come back here and ask questions!  You may even want to keep a to-do list of the techniques you've heard mentioned that you want to follow up on.</p>
</li>
<li>
<p>Keep writing the code you've already been writing.  Just because you've heard of a new technique doesn't mean it belongs in your code.  It's really easy to destroy a project by introducing each new concept that you've learned.  (I know, I've done it.)</p>
</li>
<li>
<p>Create some test projects where you can experiment with some of the new ideas that you are learning.  I'm sure you're excellent at learning abstract concepts but writing code and making things concrete will really help you know when to put a technique into practice.</p>
</li>
</ol></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/e844be7cf589bf69bd17fc26cc4b4e95"></a><div class="content"><a class="author">Vincent L</a><div class="metadata"><a href="#229023036" name="229023036"><div>2021-03-05 20:54:15</div></a></div><div class="text"><p>Try "Category Theory for Computer Scientist" from Barr and Wells, it's in pdf form freely available from the author university, and it's very well written. It introduces category theory concept, some of them are maybe not useful in Haskell, but at least it gives some perspective</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#229026953" name="229026953"><div>2021-03-05 21:22:11</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="254032">Georgi Lyubenov // googleson78</span> <a href="#narrow/stream/201385-Haskell/topic/Where.20to.20go.20from.20here/near/228966747">said</a>:</p>
<blockquote>
<p>what are your biggest pain points with hs so far?</p>
</blockquote>
<p>Monad stacks quickly get unwieldy.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#229027741" name="229027741"><div>2021-03-05 21:28:23</div></a></div><div class="text"><p>Haha, that's when we point you to <a class="stream" data-stream-id="216942" href="/#narrow/stream/216942-Polysemy">#Polysemy</a> <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span> <br>
It's slightly unfortunate that way Haskell tends to be written often makes us think in context of explicit stack<br>
We do want composable primitives for building bigger contexts, but we don't want to write in terms of them - instead, we usually think in terms of unordered capabilities we need at hand</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#229027869" name="229027869"><div>2021-03-05 21:29:42</div></a></div><div class="text"><p>I imagine design similar to Koka or Unison may be something that could shift ergonomic approaches that way</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#229028050" name="229028050"><div>2021-03-05 21:30:44</div></a></div><div class="text"><p>I was wondering about that because I happen to have read about Koka and effect systems in Haskell recently.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#229028129" name="229028129"><div>2021-03-05 21:31:16</div></a></div><div class="text"><p>I wonder if they share the same basic theory.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#229029287" name="229029287"><div>2021-03-05 21:40:53</div></a></div><div class="text"><p>Way I look at it is that strictness and blocks implicitly define ordering of operations described by <code>Applicative</code>/<code>Monad</code> interface in Haskell - when it comes to underlying monad, in case of these two it's probably going to be similar to <a href="https://github.com/hasura/eff">https://github.com/hasura/eff</a> in principle</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/hasura/eff" style="background-image: url(https://avatars.githubusercontent.com/u/13966722?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/hasura/eff" title="hasura/eff">hasura/eff</a></div><div class="message_embed_description">🚧 a work in progress effect system for Haskell 🚧. Contribute to hasura/eff development by creating an account on GitHub.</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#229029432" name="229029432"><div>2021-03-05 21:42:06</div></a></div><div class="text"><p>(side note: continuations are worth a look <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span> )</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#229043032" name="229043032"><div>2021-03-05 23:40:07</div></a></div><div class="text"><p>Anybody use <code>eff</code> in production?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#229070840" name="229070840"><div>2021-03-06 06:12:38</div></a></div><div class="text"><p>I guess no, simply because you would have to use forked compiler without support ATM <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/2f672773f0be7b81a909829602875e3d"></a><div class="content"><a class="author">Manuel Bärenz</a><div class="metadata"><a href="#229614867" name="229614867"><div>2021-03-10 07:37:46</div></a></div><div class="text"><p>For a library similar to eff that works well with current mainline GHC, see <a href="https://hackage.haskell.org/package/fused-effects">https://hackage.haskell.org/package/fused-effects</a>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/2f672773f0be7b81a909829602875e3d"></a><div class="content"><a class="author">Manuel Bärenz</a><div class="metadata"><a href="#229615467" name="229615467"><div>2021-03-10 07:44:53</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="346868">Pedro Minicz</span> <a href="#narrow/stream/201385-Haskell/topic/Where.20to.20go.20from.20here/near/228963583">said</a>:</p>
<blockquote>
<p>I'd like to learn how to use those concepts (and others). I'd love to hear suggestions on how/where to learn those concepts. I am a theory/project driven learners, so I'd love to get some pointers to learning material and some interesting project suggestions to apply those projects.</p>
</blockquote>
<p>I would recommend reading the motivating &amp; accompanying research papers to the libraries. Haskell is an interesting hybrid between a production programming language and a research playground, and many libraries come from a fruitful fertilisation between these two.</p>
<p>For example, for lenses you can read about papers here: <a href="https://github.com/ekmett/lens/wiki/History-of-Lenses">https://github.com/ekmett/lens/wiki/History-of-Lenses</a><br>
For effect systems like <code>fused-effects</code>, look into: <a href="https://github.com/fused-effects/fused-effects#related-work">https://github.com/fused-effects/fused-effects#related-work</a> and the foundational papers they link to. Many other libraries also have articles like this, and they give you a broader and more theoretical understanding of a) how the libraries work b) why they work like that. In computer science, fortunately good research papers are often very readable (as opposed to, say, maths), so often it's possible to learn something interesting from there.</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/ekmett/lens/wiki/History-of-Lenses" style="background-image: url(https://avatars.githubusercontent.com/u/304657?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/ekmett/lens/wiki/History-of-Lenses" title="ekmett/lens">ekmett/lens</a></div><div class="message_embed_description">Lenses, Folds, and Traversals - Join us on freenode #haskell-lens - ekmett/lens</div></div></div><div class="message_embed"><a class="message_embed_image" href="https://github.com/fused-effects/fused-effects#related-work" style="background-image: url(https://avatars.githubusercontent.com/u/48320083?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/fused-effects/fused-effects#related-work" title="fused-effects/fused-effects">fused-effects/fused-effects</a></div><div class="message_embed_description">A fast, flexible, fused effect system for Haskell. Contribute to fused-effects/fused-effects development by creating an account on GitHub.</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#229615704" name="229615704"><div>2021-03-10 07:47:26</div></a></div><div class="text"><blockquote>
<p>For a library similar to eff that works well with current mainline GHC, see <a href="https://hackage.haskell.org/package/fused-effects">https://hackage.haskell.org/package/fused-effects</a>.</p>
</blockquote>
<p>I would say <code>polysemy</code> has closer interface, but you won't go wrong with <code>fused-effects</code> neither</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>