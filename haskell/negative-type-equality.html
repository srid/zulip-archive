<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="We can reify type equality using a thing like:
data Equals a b
  where
  Refl :: a ~ b =&gt; Equals a b
" name="description"><link href="https://funprog.srid.ca/haskell/negative-type-equality.html" rel="canonical"><meta property="og:title" content="Negative type equality - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2020-04-12T13:34:50Z"><meta property="og:article:published_time" content="2020-04-12T11:26:38Z"><title>Negative type equality - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">Negative type equality - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">Negative type equality</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#193709052" name="193709052"><div>2020-04-12 11:26:38</div></a></div><div class="text"><p>We can reify type equality using a thing like:</p>
<div class="codehilite"><pre><span></span>data Equals a b
  where
  Refl :: a ~ b =&gt; Equals a b
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#193709075" name="193709075"><div>2020-04-12 11:27:55</div></a></div><div class="text"><p>if we want to prove that two types are not equal, does it make any sense to reify it as:</p>
<div class="codehilite"><pre><span></span>data NotEquals a b
  where
  UnRefl :: (a ~ b =&gt; Void) -&gt; NotEquals a b
</pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/bd1c2dd9ab5e95cae3e7a38c2f373739e5a1acba?version=2"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#193709552" name="193709552"><div>2020-04-12 11:41:30</div></a></div><div class="text"><p>how do you want to use this?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#193710330" name="193710330"><div>2020-04-12 12:03:08</div></a></div><div class="text"><p><span class="user-mention" data-user-id="254032">@Georgi Lyubenov // googleson78</span> it's a long story. there is a function called <code>sameSymbol :: KnownSymbol s =&gt; Proxy s -&gt; Proxy s' -&gt; Maybe (s :~: s')</code>. but in the <code>Nothing</code> case, you're actually lacking some evidence. specifically you're lacking the evidence that <code>s</code> is <em>not</em> equal to <code>s'</code>, which can for example be used to demonstrate that e.g. a variant indexed by symbols is phantom in the type parameter corresponding to that symbol</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/bd1c2dd9ab5e95cae3e7a38c2f373739e5a1acba?version=2"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#193710548" name="193710548"><div>2020-04-12 12:09:57</div></a></div><div class="text"><p>hm, but then can you use <code>sameSymbol</code> somehow to produce <code>Either (NotEquals s s') (s :~: s')</code>?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#193710587" name="193710587"><div>2020-04-12 12:10:09</div></a></div><div class="text"><p>that's the intent, yes</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#193710589" name="193710589"><div>2020-04-12 12:10:27</div></a></div><div class="text"><p>i don't know that I can use <code>sameSymbol</code> specifically to achieve it, it might require a different class</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/bd1c2dd9ab5e95cae3e7a38c2f373739e5a1acba?version=2"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#193710991" name="193710991"><div>2020-04-12 12:24:48</div></a></div><div class="text"><p>I would choose some representation that is convenient in your case (either what you proposed or <code>UnRefl :: (s :~: s' -&gt; Void) -&gt; NotEquals s s'</code>) and then reach for <code>unsafeCoerce</code> in the <code>Nothing</code> case of <code>sameSymbol</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/bd1c2dd9ab5e95cae3e7a38c2f373739e5a1acba?version=2"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#193711005" name="193711005"><div>2020-04-12 12:25:33</div></a></div><div class="text"><p>because that's what they do to produce the proof of <code>s :~: s'</code> in the first place, i.e. there is probably no way to produce a proof "legally"</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/bd1c2dd9ab5e95cae3e7a38c2f373739e5a1acba?version=2"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#193711007" name="193711007"><div>2020-04-12 12:25:40</div></a></div><div class="text"><p>at least for the builtin <code>Symbol</code>s</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/bd1c2dd9ab5e95cae3e7a38c2f373739e5a1acba?version=2"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#193711053" name="193711053"><div>2020-04-12 12:26:55</div></a></div><div class="text"><p>another thing that springs to mind is ditching <code>(~)</code> and using <code>CmpSymbol</code> instead in your <code>Equals</code> and <code>NotEquals</code>, but then you lose the convenience that <code>(~)</code> provides and you probably need to <code>unsafeCoerce</code> to recover it</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/bd1c2dd9ab5e95cae3e7a38c2f373739e5a1acba?version=2"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#193711063" name="193711063"><div>2020-04-12 12:27:30</div></a></div><div class="text"><p>I don't have too much experience manipulating <code>Symbol</code>s though, so take my words with a grain of salt :)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#193711308" name="193711308"><div>2020-04-12 12:34:06</div></a></div><div class="text"><p>Yeah, I suppose that makes sense</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/520889f20a2c66a8f4bd5be6f37d2923"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#193711320" name="193711320"><div>2020-04-12 12:35:07</div></a></div><div class="text"><p>Ideally I want to avoid getting too symbol-specific, because I need to implement similar things for both nat and symbol indexed kind structures</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/bd1c2dd9ab5e95cae3e7a38c2f373739e5a1acba?version=2"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#193711668" name="193711668"><div>2020-04-12 12:45:10</div></a></div><div class="text"><p>I wish we could use something like the agda thing where you use a convenient representation for the type checker and proofs (peano naturals) and then it gets compiled using a more performant representation (<code>Integer</code>s) :/</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/bd1c2dd9ab5e95cae3e7a38c2f373739e5a1acba?version=2"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#193711673" name="193711673"><div>2020-04-12 12:45:35</div></a></div><div class="text"><p>in any case, if it's okay with you, do share what you ended up using, I'm interested</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#193713395" name="193713395"><div>2020-04-12 13:33:51</div></a></div><div class="text"><p><a href="https://www.stackage.org/haddock/lts-15.8/singletons-2.6/Data-Singletons-Decide.html#t:Decision" title="https://www.stackage.org/haddock/lts-15.8/singletons-2.6/Data-Singletons-Decide.html#t:Decision">https://www.stackage.org/haddock/lts-15.8/singletons-2.6/Data-Singletons-Decide.html#t:Decision</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#193713442" name="193713442"><div>2020-04-12 13:34:40</div></a></div><div class="text"><p>singletons gives you a <code>Decision (a :~: b)</code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3d24a4100b3eab34d8ce3059d789c543"></a><div class="content"><a class="author">Sandy Maguire</a><div class="metadata"><a href="#193713448" name="193713448"><div>2020-04-12 13:34:50</div></a></div><div class="text"><p>i've never really figured out how to use that evidence</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>