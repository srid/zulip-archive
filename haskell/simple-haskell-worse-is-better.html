<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="Thoughts? I&#39;ve been thinking this lately.
I find the &quot;simple haskell&quot; vs &quot;fancy haskell&quot; debate mirrors &quot;worse is better&quot; vs &quot;better is better&quot; As a result I&#39;ve recently been reading up on that debate.
If we revisit https://www.jwz.org/doc/worse-is-better.html then we see:

worse is better: Simplici" name="description"><link href="https://funprog.srid.ca/haskell/simple-haskell-worse-is-better.html" rel="canonical"><meta property="og:title" content="Simple Haskell == Worse is better? - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2020-10-28T15:10:30Z"><meta property="og:article:published_time" content="2020-10-12T22:48:00Z"><title>Simple Haskell == Worse is better? - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">Simple Haskell == Worse is better? - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">Simple Haskell == Worse is better?</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#213093705" name="213093705"><div>2020-10-12 22:48:00</div></a></div><div class="text"><p>Thoughts? I've been thinking this lately.</p>
<p>I find the "simple haskell" vs "fancy haskell" debate mirrors "worse is better" vs "better is better" As a result I've recently been reading up on that debate.</p>
<p>If we revisit <a href="https://www.jwz.org/doc/worse-is-better.html">https://www.jwz.org/doc/worse-is-better.html</a> then we see:</p>
<blockquote>
<p>worse is better: Simplicity-the design must be simple, both in implementation and interface. It is more important for the implementation to be simple than the interface. Simplicity is the most important consideration in a design.</p>
<p>better is better Simplicity-the design must be simple, both in implementation and interface. It is more important for the interface to be simple than the implementation.</p>
</blockquote>
<p>"Simple Haskell" advocates seem to advocate for things that result in simple implementations at the cost of the interface. </p>
<p>They might disagree with my characterization here, so one example is whether or not to use something like deriving-aeson[0] vs writing manual instances for aeson.</p>
<p>I think that simplicity of interface is ultimately what will make Haskell more approachable, but that requires sanding down all the rough edges of bad type errors.</p>
<p>Mainly here though, I'd like to focus on:</p>
<ul>
<li>parallels of "Simple Haskell" and worse is better</li>
<li>parallels of "Fancy Haskell" and better is better</li>
<li>contradictions of "Simple Haskell == Worse is better"</li>
<li>contradictions of "Fancy Haskell == Better is better"</li>
<li>Are there good arguments from the worse is better debates in favor of or against simple Haskell?</li>
<li>Are there good arguments from the worse is better debates in favor of or against fancy Haskell?</li>
</ul>
<p>0: <a href="https://hackage.haskell.org/package/deriving-aeson">https://hackage.haskell.org/package/deriving-aeson</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?x=x&amp;version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#213096050" name="213096050"><div>2020-10-12 23:28:59</div></a></div><div class="text"><p>is there any research that concludes that simplicity of interface and implementation is inherently inversely proportional?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?x=x&amp;version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#213121792" name="213121792"><div>2020-10-13 07:59:19</div></a></div><div class="text"><p>Maybe I'm misunderstanding, but I think of these two approaches based on what they create in composition - composing nice interfaces with bad implementations  on top of each other should yield nice (library) interface, while composing bad interfaces with nice implementations will yield, well, bad interface?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#213345052" name="213345052"><div>2020-10-14 20:19:22</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="225127">TheMatten</span> <a href="#narrow/stream/201385-Haskell/topic/Simple.20Haskell.20.3D.3D.20Worse.20is.20better.3F/near/213121792">said</a>:</p>
<blockquote>
<p>[...] while composing bad interfaces with nice implementations will yield, well, bad interface?</p>
</blockquote>
<p>I don't believe that is necessarily the case.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#213345174" name="213345174"><div>2020-10-14 20:20:20</div></a></div><div class="text"><p>I find it interesting to see this discussion framed in terms of "simple code vs. simple interface." Wouldn't the classical dilemma be between "simple code vs. performance"?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#213356321" name="213356321"><div>2020-10-14 22:07:19</div></a></div><div class="text"><p><span class="user-mention" data-user-id="260881">@Torsten Schmits</span> No, but I find it's usually the case in the area I'm trying to describe.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#213356983" name="213356983"><div>2020-10-14 22:16:11</div></a></div><div class="text"><blockquote>
<p>Maybe I'm misunderstanding, but I think of these two approaches based on what they create in composition - composing nice interfaces with bad implementations  on top of each other should yield nice (library) interface, while composing bad interfaces with nice implementations will yield, well, bad interface?</p>
</blockquote>
<p>Those can both be true. Simple Haskell like worse is better though follows:</p>
<blockquote>
<p>Simplicity is the most important consideration in a design</p>
</blockquote>
<p>In the 'simple Haskell' I've seen the interface and high level design is more of an afterthought.</p>
<p>Maybe that's just a seperate orthogonal problem though.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#213360942" name="213360942"><div>2020-10-14 23:00:38</div></a></div><div class="text"><p>I guess the thing I keep coming back to is "simplicity is the most important consideration even at the cost of a complex interface".</p>
<p>Interface here being the code we programmers use to wrangle complexity they simple Haskell sacrifices for simplicity of implementation.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?x=x&amp;version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#213361138" name="213361138"><div>2020-10-14 23:03:04</div></a></div><div class="text"><p>my general reluctance to engage with questions like these is that what constitutes simplicity is entirely dependent on the consumer, in my view – and how complex the thing is you want to build when using this interface</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?x=x&amp;version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#213361189" name="213361189"><div>2020-10-14 23:03:49</div></a></div><div class="text"><p>what's simplicity to one is just plain incompleteness to others</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?x=x&amp;version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#213361260" name="213361260"><div>2020-10-14 23:04:17</div></a></div><div class="text"><p>I guess "simple" might just be code for "common" or "familiar"</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#213363999" name="213363999"><div>2020-10-14 23:36:32</div></a></div><div class="text"><p>To clarify I'm only referring to "simple Haskell", that doesn't mean I think it's simpler. Same for "worse is better", some people think it's better.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?x=x&amp;version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#213364196" name="213364196"><div>2020-10-14 23:39:15</div></a></div><div class="text"><p>well, the person saying</p>
<blockquote>
<p>"simplicity is the most important consideration even at the cost of a complex interface".</p>
</blockquote>
<p>probably has that notion</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#213364475" name="213364475"><div>2020-10-14 23:43:32</div></a></div><div class="text"><p>I don't want to discuss whether simpler Haskell is simple or simpler in this thread.</p>
<p>I was hoping to see if others see a parallel between simple Haskell and worse is better in terms of developer interface to using and maintaining that code </p>
<p>If it seems there is a link, the question is what lessons can be learned from worse is better vs better is better discussion if anything.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?x=x&amp;version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#213364798" name="213364798"><div>2020-10-14 23:48:21</div></a></div><div class="text"><p>I think it is pretty apparent that there is a parallel. my point was only that the listed criteria are informal and may be subjective, making the question hard to analyze</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#213368344" name="213368344"><div>2020-10-15 00:46:46</div></a></div><div class="text"><blockquote>
<p>I think it is pretty apparent that there is a parallel. </p>
</blockquote>
<p>I thought there would be as well, but everyone I've talked to about it didn't think the parallel was obvious.</p>
<blockquote>
<p>my point was only that the listed criteria are informal and may be subjective, making the question hard to analyze</p>
</blockquote>
<p>Ultimately I'd like to be able to formalize the criteria and the disagreement to tap into relevant research to come to a more objective conclusion about the tradeoffs involved.</p>
<p>I'm not there yet though... The point of this is for me to discuss this idea with others and see how it stands up and hopefully the discussion will help lead me to that desired result <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?x=x&amp;version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#213368462" name="213368462"><div>2020-10-15 00:48:49</div></a></div><div class="text"><p>the story in the article sounds to me like a sort of vendor lock-in situation</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?x=x&amp;version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#213368514" name="213368514"><div>2020-10-15 00:49:47</div></a></div><div class="text"><p>so a very concrete mechanism as a trade-off for generality, abstraction or compositionality</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?x=x&amp;version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#213368569" name="213368569"><div>2020-10-15 00:50:09</div></a></div><div class="text"><p>with the benefit of higher performance</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?x=x&amp;version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#213368596" name="213368596"><div>2020-10-15 00:51:03</div></a></div><div class="text"><p>and I guess you can generalize "performance" to revenue or turnaround times</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?x=x&amp;version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#213415186" name="213415186"><div>2020-10-15 12:18:22</div></a></div><div class="text"><p>BTW, not to be nitpicky, but that example in article doesn't sound very compelling to me - wouldn't it be easy to handle repeated attempts to retrieve result of some fallible operation in interface that provides bindings?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#213437118" name="213437118"><div>2020-10-15 14:49:28</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="325194">codygman</span> <a href="#narrow/stream/201385-Haskell/topic/Simple.20Haskell.20.3D.3D.20Worse.20is.20better.3F/near/213093705">said</a>:</p>
<blockquote>
<p>If we revisit <a href="https://www.jwz.org/doc/worse-is-better.html">https://www.jwz.org/doc/worse-is-better.html</a> then we see:</p>
</blockquote>
<p>And revisit I did. The main point of the article seems to me not using the best solution available at the time. Points three and four of the "New Jersey approach" seem to be the bigger deal breaker (mainly point four):</p>
<blockquote>
<ul>
<li>
<p>Consistency-the design must not be overly inconsistent. Consistency can be sacrificed for simplicity in some cases, but it is better to drop those parts of the design that deal with less common circumstances than to introduce either implementational complexity or inconsistency.</p>
</li>
<li>
<p>Completeness-the design must cover as many important situations as is practical. All reasonably expected cases should be covered. Completeness can be sacrificed in favor of any other quality. In fact, completeness must sacrificed whenever implementation simplicity is jeopardized. Consistency can be sacrificed to achieve completeness if simplicity is retained; especially worthless is consistency of interface.</p>
</li>
</ul>
</blockquote></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#213437420" name="213437420"><div>2020-10-15 14:51:37</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="260881">Torsten Schmits</span> <a href="#narrow/stream/201385-Haskell/topic/Simple.20Haskell.20.3D.3D.20Worse.20is.20better.3F/near/213361138">said</a>:</p>
<blockquote>
<p>my general reluctance to engage with questions like these is that what constitutes simplicity is entirely dependent on the consumer, in my view – and how complex the thing is you want to build when using this interface</p>
</blockquote>
<p>I believe the "consumer view" may be contextualized a bit going by the article. The "consumer" in the case of Unix and C are OS users and other programmers. The example the article brings about a given OS callback seems to make "OS users" a bit more clear: programmers interfacing with the OS.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/33ed1f4a88793f2221d759610e2e8ddb"></a><div class="content"><a class="author">codygman</a><div class="metadata"><a href="#213437953" name="213437953"><div>2020-10-15 14:55:08</div></a></div><div class="text"><p>I read something related this morning that distills the two camps well. It also states the debate isn't about simplicity at all.</p>
<p>I think this point about evolution carries over to the simple Haskell vs fancy Haskell debate.</p>
<p>Worse is better:</p>
<blockquote>
<p>If evolution is in the center of your worldview, if you think about viability as more important than perfection in any area, then you'll tend to design in a Worse Is Better style.</p>
</blockquote>
<p>Better is better:</p>
<blockquote>
<p>If you think of evolutionary pressure as an obstacle, an ultimately unimportant, harmful distraction on the road to perfection, then you'll prefer designs in The Right Thing style.</p>
</blockquote>
<p><a href="http://yosefk.com/blog/what-worse-is-better-vs-the-right-thing-is-really-about.html">http://yosefk.com/blog/what-worse-is-better-vs-the-right-thing-is-really-about.html</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#213467920" name="213467920"><div>2020-10-15 18:28:11</div></a></div><div class="text"><p>Somebody used evolution as rationale? Just a reminder that evolution is all about survival (which can be grisly if history is anything to go by), and not a standard to live a good life by. The same should go with software.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4429aa8b689608f24a4ad712843ce29862e330d2?x=x&amp;version=2"></a><div class="content"><a class="author">Sridhar Ratnakumar</a><div class="metadata"><a href="#213468910" name="213468910"><div>2020-10-15 18:35:50</div></a></div><div class="text"><p><span class="user-mention" data-user-id="325194">@codygman</span> Interestingly, the same can be applied to somewhat conservative vs (classical) liberal thinking; not necessarily in political context, but specificaly in psychological context. ("I'll feel this way, because I'm human", "You can't change human nature", and such defeatist rationalizations).</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/7334dc60b6aef6a75cd9284126231f13c76926a5?x=x&amp;version=4"></a><div class="content"><a class="author">Torsten Schmits</a><div class="metadata"><a href="#213469623" name="213469623"><div>2020-10-15 18:41:35</div></a></div><div class="text"><p>yes, <em>worse is better</em> is liberalism <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#214333973" name="214333973"><div>2020-10-23 16:21:16</div></a></div><div class="text"><p>I think "worse is better" is an observation that "there are multiple ways to evaluate the 'goodness' of something", and ultimately something might be "good" in some way but bad in another, and these are (often) in tension.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#214334166" name="214334166"><div>2020-10-23 16:22:49</div></a></div><div class="text"><p>To me,  "simple haskell" is just saying "these are the values that tend to work out better in industry"</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#214334745" name="214334745"><div>2020-10-23 16:27:55</div></a></div><div class="text"><p>So for example if you think systems that are staically proven correct are always better than ones that are not, you will be willing to try to solve every desired property in the type system, regardless of how often it works out that you aren't able to actually do it effectively. This is an extreme case, but im just trying to illustrate</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/45175015b9eb3dd3f6c740b3fe920fed"></a><div class="content"><a class="author">Joel McCracken</a><div class="metadata"><a href="#214334837" name="214334837"><div>2020-10-23 16:28:25</div></a></div><div class="text"><p>similarly, if you value spending your evenigns with family and relaxing, the best programming language and techniques are the ones you already know</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#214849094" name="214849094"><div>2020-10-28 15:06:41</div></a></div><div class="text"><p>fwiw, I picked up Haskell while working a full-time, non-Haskell job and I have a small family with 2 kids that I spend a lot of time with. <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#214849785" name="214849785"><div>2020-10-28 15:10:30</div></a></div><div class="text"><p>I also value reliability and will often make the trade off for higher levels of complexity if it means fewer expensive errors in production and I like Haskell because it scales up to those kinds of challenges well.</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>