<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="(&lt;*&gt;) and pure for the (-&gt;) a monad are respectively the S and K combinators of SK calculus. (&gt;&gt;=) is remarkably similar to the S combinator:
(&lt;*&gt;) :: (a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
(&gt;&gt;=) :: (a -&gt; b) -&gt; (b -&gt; a -&gt; c) -&gt; b -&gt; c



It gets a lot clearer when one flips (&gt;&gt;=):
     (&lt;*&gt;) :: (a -&gt; b" name="description"><link href="https://funprog.srid.ca/haskell/arrow-monad-and-sk-calculus.html" rel="canonical"><meta property="og:title" content="Arrow monad and SK calculus - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2020-10-10T17:29:51Z"><meta property="og:article:published_time" content="2020-10-08T23:15:03Z"><meta property="og:image" content="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"><title>Arrow monad and SK calculus - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">Arrow monad and SK calculus - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">Arrow monad and SK calculus</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#212760852" name="212760852"><div>2020-10-08 23:15:03</div></a></div><div class="text"><p><code>(&lt;*&gt;)</code> and <code>pure</code> for the <code>(-&gt;) a</code> monad are respectively the S and K combinators of SK calculus. <code>(&gt;&gt;=)</code> is remarkably similar to the S combinator:</p>
<div class="codehilite"><pre><span></span><code>(&lt;*&gt;) :: (a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
(&gt;&gt;=) :: (a -&gt; b) -&gt; (b -&gt; a -&gt; c) -&gt; b -&gt; c
</code></pre></div>


<p>It gets a lot clearer when one flips <code>(&gt;&gt;=)</code>:</p>
<div class="codehilite"><pre><span></span><code>     (&lt;*&gt;) :: (a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
flip (&gt;&gt;=) :: (b -&gt; a -&gt; c) -&gt; (a -&gt; b) -&gt; b -&gt; c
</code></pre></div>


<p>My question is, can I implement <code>(&gt;&gt;=)</code> in terms of S and K? That is, in terms of <code>(&lt;*&gt;)</code> and <code>pure</code>?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#212760895" name="212760895"><div>2020-10-08 23:15:44</div></a></div><div class="text"><p>I believe it should be possible, as one can compile lambda calculus to SK, but it may not type check.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#212761021" name="212761021"><div>2020-10-08 23:17:17</div></a></div><div class="text"><p>If it does type check, this would mean that an applicative instance of <code>(-&gt;) a</code> implies a monad instance, that is, they would be interchangeable. Is that the case? Does this happen with other monads?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#212761034" name="212761034"><div>2020-10-08 23:17:30</div></a></div><div class="text"><div class="codehilite" data-code-language="Haskell"><pre><span></span><code><span class="cm">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="cm">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kr">module</span> <span class="nn">Arrow</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">(</span><span class="o">..</span><span class="p">),</span> <span class="kt">Applicative</span><span class="p">(</span><span class="o">..</span><span class="p">),</span> <span class="kt">Monad</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>

<span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="ow">=</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span>

<span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
  <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>

<span class="kr">instance</span> <span class="cm">{-# OVERLAPPING #-}</span> <span class="kt">Applicative</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="ow">=</span> <span class="n">const</span>
  <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">k</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">k</span> <span class="ow">=</span> <span class="n">pure</span>

<span class="nf">i</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">i</span> <span class="ow">=</span> <span class="n">k</span> <span class="o">&lt;*&gt;</span> <span class="n">k</span>

<span class="kr">class</span> <span class="kt">Functor</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
  <span class="c1">-- (x -&gt; a) -&gt; (x -&gt; a -&gt; b) -&gt; x -&gt; b</span>
  <span class="c1">-- (x -&gt; a) -&gt; (a -&gt; x -&gt; b) -&gt; x -&gt; b</span>
  <span class="c1">--</span>
  <span class="c1">-- (a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</span>
  <span class="c1">-- (a -&gt; b) -&gt; (b -&gt; a -&gt; c) -&gt; b -&gt; c</span>
  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">return</span> <span class="ow">=</span> <span class="n">const</span>
  <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">g</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="n">x</span>

<span class="nf">s</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">s</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">x</span>
  <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">y</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span>

<span class="nf">s'</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">s'</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">y</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span>

<span class="kr">instance</span> <span class="cm">{-# OVERLAPPABLE #-}</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="ow">=</span> <span class="n">return</span>
  <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">f</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#212762173" name="212762173"><div>2020-10-08 23:31:54</div></a></div><div class="text"><p>Using <a href="https://codegolf.stackexchange.com/questions/112115/convert-%CE%BB-expressions-to-sk-expressions">this lambda calculus to SK translator</a> <code>(&gt;&gt;=)</code> becomes the following expression:</p>
<div class="codehilite"><pre><span></span><code>λ&gt; f &quot;\\\\\\``[1]`[2][0][0]&quot;
&quot;``S``S`KS``S``S`KS``S`KK`KS``S``S`KS``S``S`KS``S`KK`KS``S``S`KS``S`KK`KK``S``S
`KS`KK`KK``S``S`KS``S``S`KS``S`KK`KS``S``S`KS``S`KK`KK``S`KK``SKK``S``S`KS``S``
S`KS``S`KK`KS``S`KK`KK``S`KK`KK``S``S`KS``S``S`KS``S`KK`KS``S`KK`KK``S`KK`KK&quot;
</code></pre></div>


<p>Using <a href="https://crypto.stanford.edu/~blynn/lambda/sk.html">this online lambda calculus to SK translator</a> it becomes:</p>
<div class="codehilite"><pre><span></span><code>input:
main = \f g x -&gt; g (f x) x
intermediate form:
s(k(s(k(s(k(ss(sk)))))(s(s(ks)k))))kuz
</code></pre></div>


<p><del>I would guess neither of these terms type check as variables probably get coupled together by unification somewhere.</del> I was wrong! It does type check:</p>
<div class="codehilite"><pre><span></span><code>λ&gt; :t s (k (s (k (s (k (s s (s k))))) (s (s (k s) k)))) k
s (k (s (k (s (k (s s (s k))))) (s (s (k s) k)))) k
  :: (b1 -&gt; b2) -&gt; (b2 -&gt; b1 -&gt; c) -&gt; b1 -&gt; c
</code></pre></div>


<div class="message_embed"><a class="message_embed_image" href="https://codegolf.stackexchange.com/questions/112115/convert-%CE%BB-expressions-to-sk-expressions" style="background-image: url(https://cdn.sstatic.net/Sites/codegolf/Img/apple-touch-icon@2.png?v=ed60a1645c65)"></a><div class="data-container"><div class="message_embed_title"><a href="https://codegolf.stackexchange.com/questions/112115/convert-%CE%BB-expressions-to-sk-expressions" title="Convert λ-expressions to SK-expressions">Convert λ-expressions to SK-expressions</a></div><div class="message_embed_description">The λ-calculus, or lambda calculus, is a logical system based on anonymous functions. For example, this a λ-expression:

λf.(λx.xx)(λx.f(xx))
However, for the purposes of this challenge, we'll sim...</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/943f136ec7427f6b625c6adfb39456aff9a88ee2?x=x&amp;version=2"></a><div class="content"><a class="author">Kim-Ee Yeoh</a><div class="metadata"><a href="#212772972" name="212772972"><div>2020-10-09 02:20:01</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="346868">Pedro Minicz</span> <a href="#narrow/stream/201385-Haskell/topic/Arrow.20monad.20and.20SK.20calculus/near/212760852">said</a>:</p>
<blockquote>
<p><code>(&lt;*&gt;)</code> and <code>pure</code> for the <code>(-&gt;) a</code> monad are respectively the S and K combinators of SK calculus. <code>(&gt;&gt;=)</code> is remarkably similar to the S combinator:</p>
<div class="codehilite"><pre><span></span><code>(&lt;*&gt;) :: (a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
(&gt;&gt;=) :: (a -&gt; b) -&gt; (b -&gt; a -&gt; c) -&gt; b -&gt; c
</code></pre></div>


</blockquote>
<p>Should be <code>(&gt;&gt;=) :: ... -&gt; a -&gt; c</code>if the effect is <code>(a-&gt;)</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#212781408" name="212781408"><div>2020-10-09 04:02:05</div></a></div><div class="text"><p>Answering the original question: yes, it is entirely possible to implement <code>(&gt;&gt;=)</code> in terms of <code>(&lt;*&gt;)</code> for the <code>(-&gt;) a</code> monad! Specifically: <code>f &gt;&gt;= g = flip g &lt;*&gt; f</code>. In fact, you can do this sort of thing for any <a href="https://hackage.haskell.org/package/adjunctions-4.4/docs/Data-Functor-Rep.html"><code>Representable</code></a> functor (i.e. functors which are isomorphic to <code>(-&gt;) a</code>), though it is of course impossible in general.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#212829774" name="212829774"><div>2020-10-09 14:04:15</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="346527">Kim-Ee Yeoh</span> <a href="#narrow/stream/201385-Haskell/topic/Arrow.20monad.20and.20SK.20calculus/near/212772972">said</a>:</p>
<blockquote>
<p>Should be <code>(&gt;&gt;=) :: ... -&gt; a -&gt; c</code>if the effect is <code>(a-&gt;)</code>.</p>
</blockquote>
<p>Indeed! Thank you for spotting that!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#212829847" name="212829847"><div>2020-10-09 14:04:52</div></a></div><div class="text"><p>I've written a <a href="https://pedrominicz.github.io/arrow">small piece</a> about this monad. Any and all feedback/criticisms are highly welcome!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#212831344" name="212831344"><div>2020-10-09 14:16:26</div></a></div><div class="text"><p><code>I didn’t manage to think of any useful examples of do notation for the (-&gt;) a monad. </code></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#212831347" name="212831347"><div>2020-10-09 14:16:28</div></a></div><div class="text"><p>job security!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eafc0f7c35b3424a69f878734f94ede4"></a><div class="content"><a class="author">bradrn</a><div class="metadata"><a href="#212897683" name="212897683"><div>2020-10-10 04:00:01</div></a></div><div class="text"><p>The <code>Applicative</code>/<code>Monad</code> instances for <code>(-&gt;) a</code> are in fact _very_ useful — I use them all the time! For instance, if I have two predicates, <code>pred1 :: a -&gt; Bool</code> and <code>pred2 -&gt; Bool</code>, I can combine them by doing <code>(||) &lt;$&gt; pred1 &lt;*&gt; pred2</code> or <code>(&amp;&amp;) &lt;$&gt; pred1 &lt;*&gt; pred2</code>. Or, if that’s too unreadable, you could use <code>do</code> notation:</p>
<div class="codehilite"><pre><span></span><code>do
    pred1Result &lt;- pred1
    pred2Result &lt;- pred2
    return $ pred1Result || pred2Result
</code></pre></div>


<p>That being said, I can’t think of any reason why I would prefer <code>do</code> notation to <code>(&lt;*&gt;)</code> — usually the former is more powerful, but as I already said, they’re of equal power when using <code>(-&gt;) a</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#212926212" name="212926212"><div>2020-10-10 17:27:08</div></a></div><div class="text"><p>The precedence of <code>(&lt;$&gt;)</code>/<code>(.)</code> and <code>&lt;*&gt;</code> seems to make things kind of annoying:</p>
<div class="codehilite"><pre><span></span><code>(&amp;&amp;) &lt;$&gt; p1 &lt;*&gt; p2 == (&amp;&amp;) &lt;&amp;&gt; (p1 &lt;*&gt; p2) -- This doesn&#39;t type check
(&amp;&amp;) . p1 &lt;*&gt; p2 -- Can&#39;t mix infix operators with same precedence
((&amp;&amp;) &lt;$&gt; p1) &lt;*&gt; p2 == ((&amp;&amp;) . p1) &lt;*&gt; p2 -- Works
</code></pre></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#212926284" name="212926284"><div>2020-10-10 17:29:51</div></a></div><div class="text"><p>I personally always use liftA2 when I want to lift two functions over the same argument instead of the operators</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>