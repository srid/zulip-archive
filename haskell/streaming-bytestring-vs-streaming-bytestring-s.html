<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="Is there a reason there is a separate streaming-bytestring library with this type:
data ByteString m r
  = Empty r
  | Chunk S.ByteString (ByteString m r)
  | Go (m (ByteString m r))



as opposed to just using the following types from the basic streaming package?
data Stream f m r
  = Return r
  | " name="description"><link href="https://funprog.srid.ca/haskell/streaming-bytestring-vs-streaming-bytestring-s.html" rel="canonical"><meta property="og:title" content="`streaming-bytestring` vs `streaming` `ByteString`s - Haskell"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Haskell"><meta property="og:article:modified_time" content="2020-06-08T20:29:34Z"><meta property="og:article:published_time" content="2020-06-05T17:44:53Z"><title>`streaming-bytestring` vs `streaming` `ByteString`s - Haskell</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">`streaming-bytestring` vs `streaming` `ByteString`s - Haskell</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/haskell/" class="section">#Haskell</a><i class="right angle icon divider"></i><div class="active section">`streaming-bytestring` vs `streaming` `ByteString`s</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#199910740" name="199910740"><div>2020-06-05 17:44:53</div></a></div><div class="text"><p>Is there a reason there is a separate <code>streaming-bytestring</code> library with this type:</p>
<div class="codehilite"><pre><span></span><code><span class="kr">data</span> <span class="kt">ByteString</span> <span class="n">m</span> <span class="n">r</span>
  <span class="ow">=</span> <span class="kt">Empty</span> <span class="n">r</span>
  <span class="o">|</span> <span class="kt">Chunk</span> <span class="kt">S</span><span class="o">.</span><span class="kt">ByteString</span> <span class="p">(</span><span class="kt">ByteString</span> <span class="n">m</span> <span class="n">r</span><span class="p">)</span>
  <span class="o">|</span> <span class="kt">Go</span> <span class="p">(</span><span class="n">m</span> <span class="p">(</span><span class="kt">ByteString</span> <span class="n">m</span> <span class="n">r</span><span class="p">))</span>
</code></pre></div>


<p>as opposed to just using the following types from the basic <code>streaming</code> package?</p>
<div class="codehilite"><pre><span></span><code><span class="kr">data</span> <span class="kt">Stream</span> <span class="n">f</span> <span class="n">m</span> <span class="n">r</span>
  <span class="ow">=</span> <span class="kt">Return</span> <span class="n">r</span>
  <span class="o">|</span> <span class="kt">Step</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="kt">Stream</span> <span class="n">f</span> <span class="n">m</span> <span class="n">r</span><span class="p">))</span>
  <span class="o">|</span> <span class="kt">Effect</span> <span class="p">(</span><span class="n">m</span> <span class="p">(</span><span class="kt">Stream</span> <span class="n">f</span> <span class="n">m</span> <span class="n">r</span><span class="p">))</span>

<span class="kr">data</span> <span class="kt">Of</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="kt">:&gt;</span> <span class="n">b</span>

<span class="kr">type</span> <span class="kt">ByteString</span> <span class="n">m</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Stream</span> <span class="p">(</span><span class="kt">Of</span> <span class="kt">S</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">)</span> <span class="n">m</span> <span class="n">r</span>
</code></pre></div></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#199911216" name="199911216"><div>2020-06-05 17:49:14</div></a></div><div class="text"><p>is there some performance optimization the specialized version can benefit from that the corresponding instantiation of the general <code>Stream</code> cannot?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Daniel Díaz Carrete</a><div class="metadata"><a href="#199912363" name="199912363"><div>2020-06-05 17:58:39</div></a></div><div class="text"><p>I'm not knowledgeable about Haskell performance optimization, but the <code>Stream</code> version has more memory indirections, because of the <code>Of</code> functor. Also, in the <code>ByteString</code> version, the inner bytestrings are unpacked, which I guess it can help. It would be nice if there were benchmarks comparing the performance of <code>ByteString</code> vs. vanilla <code>Stream (Of ByteString)</code>.</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#199912665" name="199912665"><div>2020-06-05 18:00:55</div></a></div><div class="text"><p>is there no equivalent <code>F</code> of <code>Of S.ByteString</code> that we can write such that <code>Stream F</code> performs identically to <code>ByteString</code> from <code>streaming-bytestring</code>?</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Daniel Díaz Carrete</a><div class="metadata"><a href="#199913194" name="199913194"><div>2020-06-05 18:05:12</div></a></div><div class="text"><p>Any pluggable <code>F</code> would incur in memory indirections like <code>Of</code>; I think it's inevitable (?) given how Haskell handles polymorphism in datatypes. But again, I'm not sure how much it impacts performance.</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Daniel Díaz Carrete</a><div class="metadata"><a href="#199913865" name="199913865"><div>2020-06-05 18:09:03</div></a></div><div class="text"><p>I've toyed with the idea of writing a streaming-chunked package very similar to streaming-bytestring, but where the "packed" inner type would be configurable by way of Backpack. conduit has useful -E suffixed versions of funtcions, like for example <code>lengthE</code> <a href="http://hackage.haskell.org/package/conduit-1.3.2/docs/Data-Conduit-Combinators.html#v:lengthE">http://hackage.haskell.org/package/conduit-1.3.2/docs/Data-Conduit-Combinators.html#v:lengthE</a> for working with chunked data. They abstract the chunked type using typeclasses, abstracting it using Backpack would be an interesting experiment. And it would let you maintain the "UNPACKED" in the implementation.</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#199914076" name="199914076"><div>2020-06-05 18:10:51</div></a></div><div class="text"><p>that's interesting. i wonder if there's just theoretical limitations that make things like memory layout inherently anticompositional or if it's just hard to implement</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#199914656" name="199914656"><div>2020-06-05 18:15:18</div></a></div><div class="text"><p>I don't know anything about performance or memory layout, so it isn't obvious to me why it has to be the case that this:</p>
<div class="codehilite"><pre><span></span><code>data ByteString m r
  = Empty r
  | Chunk {-#UNPACK #-} !S.ByteString (ByteString m r)
  | Go (m (ByteString m r))
</code></pre></div>


<p>is more efficient than this:</p>
<div class="codehilite"><pre><span></span><code>data BS r = BS {-# UNPACK #-} !S.ByteString r

data Stream f m r
  = Return r
  | Step !(f (Stream f m r))
  | Effect (m (Stream f m r))

type ByteString&#39; m r = Stream BS m r
</code></pre></div></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#199915602" name="199915602"><div>2020-06-05 18:20:15</div></a></div><div class="text"><p>Regarding your idea about typeclasses, do you mean something like the following?</p>
<div class="codehilite"><pre><span></span><code><span class="kr">class</span> <span class="kt">ChunkyStream</span> <span class="n">s</span> <span class="n">a</span> <span class="n">m</span> <span class="n">r</span> <span class="o">|</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">r</span>
  <span class="kr">where</span>
  <span class="n">empty</span> <span class="ow">::</span> <span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">s</span>
  <span class="n">chunk</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">s</span>
  <span class="n">effect</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">s</span>
  <span class="n">match</span> <span class="ow">::</span> <span class="p">(</span><span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">m</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">x</span>
</code></pre></div></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Asad Saeeduddin</a><div class="metadata"><a href="#199915793" name="199915793"><div>2020-06-05 18:21:35</div></a></div><div class="text"><p>Then like <code>instance ChunkyStream (Stream (Of a) m r) a m r</code> and <code>instance ChunkyStream (ByteString m r) S.ByteString m r</code> etc.</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Daniel Díaz Carrete</a><div class="metadata"><a href="#199915930" name="199915930"><div>2020-06-05 18:22:29</div></a></div><div class="text"><p>I meant typeclasses like <code>IsSequence</code> in conduit <a href="http://hackage.haskell.org/package/conduit-1.3.2/docs/Data-Conduit-Combinators.html#v:takeE">http://hackage.haskell.org/package/conduit-1.3.2/docs/Data-Conduit-Combinators.html#v:takeE</a> that define the operations a "packed" datatype like Text or ByteString might have. That way you can have a generic <code>takeE</code> function that works with any <code>IsSequence</code> instance.</p>
<p>About the <code>BS</code> datatype: that has one less indirection that <code>Stream (Of ByteString)</code>, but the one from the <code>Step</code> constructor to <code>BS</code> itself would remain. And you wouldn't be able to reuse any function which worked over <code>Stream (Of ByteString)</code>.</p></div></div></div><div class="comment"><a class="avatar"></a><div class="content"><a class="author">Daniel Díaz Carrete</a><div class="metadata"><a href="#200152000" name="200152000"><div>2020-06-08 20:29:34</div></a></div><div class="text"><p>Spurred by curiosity, I wrote a small criterion microbenchmark (my first ever use of criterion!) comparing  <code>Stream (Of ByteString)</code> with <code>Data.ByteString.Streaming.BytesString</code>. I didn't find much of a difference, but maybe my benchmark is too naive. <a href="https://github.com/danidiaz/streaming-benchmarks">https://github.com/danidiaz/streaming-benchmarks</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/danidiaz/streaming-benchmarks" style="background-image: url(https://avatars0.githubusercontent.com/u/1136927?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/danidiaz/streaming-benchmarks" title="danidiaz/streaming-benchmarks">danidiaz/streaming-benchmarks</a></div><div class="message_embed_description">comparing the performance of Streams from "streaming" and ByteStrings from "streaming-bytestring" - danidiaz/streaming-benchmarks</div></div></div></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>