<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="What does it mean to say that the untyped lambda calculus is inconsistent?
A bit of context: I&#39;ve been intrigued by the Metamath proof assistant for a while now. It is basically a &quot;substitution check&quot;, the user writes a series of substitution steps and Matamath makes sure they match. Basically the u" name="description"><link href="https://funprog.srid.ca/general/untyped-lambda-calculus-is-inconsistent.html" rel="canonical"><meta property="og:title" content="Untyped lambda calculus is inconsistent - General"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="General"><meta property="og:article:modified_time" content="2021-03-23T04:35:23Z"><meta property="og:article:published_time" content="2021-03-15T18:58:04Z"><meta property="og:image" content="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"><title>Untyped lambda calculus is inconsistent - General</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">Untyped lambda calculus is inconsistent - General</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/general/" class="section">#General</a><i class="right angle icon divider"></i><div class="active section">Untyped lambda calculus is inconsistent</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#230399989" name="230399989"><div>2021-03-15 18:58:04</div></a></div><div class="text"><p>What does it mean to say that the untyped lambda calculus is inconsistent?</p>
<p>A bit of context: I've been intrigued by the Metamath proof assistant for a while now. It is basically a "substitution check", the user writes a series of substitution steps and Matamath makes sure they match. Basically the user carries computations by hand, like if the user was writing a series of alpha/beta reductions steps and the computer was checking they are valid. This equivalence between logic and computation is fantastic, and weird.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#230400411" name="230400411"><div>2021-03-15 19:01:08</div></a></div><div class="text"><p>I suspect it has to do with terms that don't normalize, such as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>=</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>x</mi><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>x</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Omega = (\lambda x. x x) (\lambda x. x x)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal">x</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal">x</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>. If that is the case, what is there of inconsistent in non-terminating programs? (I can see why that would be inconsistent in a language where types encode propositions, because an infinite loop inhabits any type, but I don't see how this would make a language where <em>terms themselves encode propositions</em> which is how I assume logic would be encoded in untyped lambda calculus.)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#230400599" name="230400599"><div>2021-03-15 19:02:18</div></a></div><div class="text"><p>Also, suppose we have an oracle that can tell if a lambda term is normalizes (modulo some reduction strategy). Would the set of all normalizing untyped lambda terms be consistent?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950?d=identicon&amp;version=1"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#230421352" name="230421352"><div>2021-03-15 21:26:44</div></a></div><div class="text"><p><a href="https://en.wikipedia.org/wiki/Curry%27s_paradox#Lambda_calculus">https://en.wikipedia.org/wiki/Curry%27s_paradox#Lambda_calculus</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950?d=identicon&amp;version=1"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#230421383" name="230421383"><div>2021-03-15 21:26:54</div></a></div><div class="text"><p><a href="https://en.wikipedia.org/wiki/Kleene%E2%80%93Rosser_paradox">https://en.wikipedia.org/wiki/Kleene%E2%80%93Rosser_paradox</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950?d=identicon&amp;version=1"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#230421391" name="230421391"><div>2021-03-15 21:26:59</div></a></div><div class="text"><p>relevant resources I guess</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950?d=identicon&amp;version=1"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#230421445" name="230421445"><div>2021-03-15 21:27:45</div></a></div><div class="text"><p>I'm almost ready to bet this inconsistency is described in Barendregt's untyped lc book</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950?d=identicon&amp;version=1"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#230421459" name="230421459"><div>2021-03-15 21:27:58</div></a></div><div class="text"><p>"The Lambda Calculus: Its Syntax and Semantics"</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950?d=identicon&amp;version=1"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#230421607" name="230421607"><div>2021-03-15 21:29:08</div></a></div><div class="text"><p>in there, iirc, lambda calculus is defined as a formal system with some rules, like beta-reduction, alpha-reduction, etc, and then, using these rules, you can prove any term you like<br>
and I guess this is what is described in the wikipedia article I linked that's on Curry's paradox</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230578948" name="230578948"><div>2021-03-16 19:48:02</div></a></div><div class="text"><p>Who says untyped LC is inconsistent? Different people mean different things by consistency, apparently.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230578990" name="230578990"><div>2021-03-16 19:48:04</div></a></div><div class="text"><p><a href="https://plato.stanford.edu/entries/lambda-calculus/">https://plato.stanford.edu/entries/lambda-calculus/</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230579201" name="230579201"><div>2021-03-16 19:49:45</div></a></div><div class="text"><blockquote>
<p>Another early problem in the λ-calculus was whether it is consistent at all. In this context, inconsistency means that all terms are equal: one can reduce any λ-term M to any other λ-term N. That this is not the case is an early result of λ-calculus.</p>
</blockquote></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230579368" name="230579368"><div>2021-03-16 19:50:36</div></a></div><div class="text"><p><a href="/user_uploads/13896/idzwD_lparrAceNpkrcIcCXI/F74F453B-C292-4DE2-B5B7-CB239C1E52E0.jpg">F74F453B-C292-4DE2-B5B7-CB239C1E52E0.jpg</a></p>
<div class="message_inline_image"><a href="/user_uploads/13896/idzwD_lparrAceNpkrcIcCXI/F74F453B-C292-4DE2-B5B7-CB239C1E52E0.jpg" title="F74F453B-C292-4DE2-B5B7-CB239C1E52E0.jpg"><img src="/user_uploads/13896/idzwD_lparrAceNpkrcIcCXI/F74F453B-C292-4DE2-B5B7-CB239C1E52E0.jpg"></a></div></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230579374" name="230579374"><div>2021-03-16 19:50:39</div></a></div><div class="text"><p>etc</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230579539" name="230579539"><div>2021-03-16 19:51:39</div></a></div><div class="text"><blockquote>
<p>The Church-Rosser theorem gives us, among other things, that the plain λ-calculus—that is, the theory of equations between λ-terms—is consistent, in the sense that not all equations are derivable.</p>
</blockquote></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230579776" name="230579776"><div>2021-03-16 19:52:47</div></a></div><div class="text"><p>It sounds to me like untyped LC is consistent.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230580082" name="230580082"><div>2021-03-16 19:54:44</div></a></div><div class="text"><p><a href="https://en.m.wikipedia.org/wiki/Lambda_calculus">https://en.m.wikipedia.org/wiki/Lambda_calculus</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230580153" name="230580153"><div>2021-03-16 19:55:16</div></a></div><div class="text"><blockquote>
<p>The original system was shown to be logically inconsistent in 1935 when Stephen Kleene and J. B. Rosser developed the Kleene–Rosser paradox.[8][9]</p>
</blockquote>
<blockquote>
<p>Subsequently, in 1936 Church isolated and published just the portion relevant to computation, what is now called the untyped lambda calculus.[10] In 1940, he also introduced a computationally weaker, but logically consistent system, known as the simply typed lambda calculus.[11]</p>
</blockquote></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230580261" name="230580261"><div>2021-03-16 19:56:02</div></a></div><div class="text"><p>Hm. This is ambiguous wikipedia-speak, it is not clear whether STLC is consistent but ULC isn't, or whether both ULC and STLC are…</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230580549" name="230580549"><div>2021-03-16 19:58:02</div></a></div><div class="text"><p><a href="https://en.m.wikipedia.org/wiki/Curry%27s_paradox#Lambda_calculus">https://en.m.wikipedia.org/wiki/Curry%27s_paradox#Lambda_calculus</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230580622" name="230580622"><div>2021-03-16 19:58:21</div></a></div><div class="text"><p><a href="/user_uploads/13896/1JhRik3B8JEL2wpeWCgFEZ2K/579B549F-5C25-4AB0-A13A-208626810255.jpg">579B549F-5C25-4AB0-A13A-208626810255.jpg</a></p>
<div class="message_inline_image"><a href="/user_uploads/13896/1JhRik3B8JEL2wpeWCgFEZ2K/579B549F-5C25-4AB0-A13A-208626810255.jpg" title="579B549F-5C25-4AB0-A13A-208626810255.jpg"><img src="/user_uploads/13896/1JhRik3B8JEL2wpeWCgFEZ2K/579B549F-5C25-4AB0-A13A-208626810255.jpg"></a></div></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230580660" name="230580660"><div>2021-03-16 19:58:39</div></a></div><div class="text"><p>Hard to pin down from informal wikipedia entries…</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#230706754" name="230706754"><div>2021-03-17 15:15:06</div></a></div><div class="text"><p>I am pretty sure I've heard it many places, usually not explained at all, just "ULC is inconsistent" then proceeding to talk about STLC. I believe Barendregt's <a href="https://ttic.uchicago.edu/~dreyer/course/papers/barendregt.pdf">Lambda Calculi with Types</a> also makes such claim.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230929643" name="230929643"><div>2021-03-18 20:09:05</div></a></div><div class="text"><p>The intro to that paper says LC is consistent, and that it was only an earlier version of the system which dealt with more than functions which was inconsistent</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230929802" name="230929802"><div>2021-03-18 20:10:26</div></a></div><div class="text"><p><a href="/user_uploads/13896/u11jbuiFCHVgtU1V9JmhXSdW/87D2195C-A9B0-4D9E-8EEF-F645BDD5A4B3.jpg">87D2195C-A9B0-4D9E-8EEF-F645BDD5A4B3.jpg</a></p>
<div class="message_inline_image"><a href="/user_uploads/13896/u11jbuiFCHVgtU1V9JmhXSdW/87D2195C-A9B0-4D9E-8EEF-F645BDD5A4B3.jpg" title="87D2195C-A9B0-4D9E-8EEF-F645BDD5A4B3.jpg"><img src="/user_uploads/13896/u11jbuiFCHVgtU1V9JmhXSdW/87D2195C-A9B0-4D9E-8EEF-F645BDD5A4B3.jpg"></a></div></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230929854" name="230929854"><div>2021-03-18 20:10:52</div></a></div><div class="text"><p>Hm</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230929871" name="230929871"><div>2021-03-18 20:11:02</div></a></div><div class="text"><p>I guess it doesn't quite say that</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/100b92b164beba4d16133f515c463baf?d=identicon&amp;version=1"></a><div class="content"><a class="author">Gabriel Lebec</a><div class="metadata"><a href="#230929909" name="230929909"><div>2021-03-18 20:11:22</div></a></div><div class="text"><p>just that "the subsystem dealing with functions only became a successful model"</p></div></div></div><div class="comment"><a class="avatar"><img src="https://secure.gravatar.com/avatar/8ae3c3a98eb73541a0a410e92b025ebd?d=identicon&amp;version=1"></a><div class="content"><a class="author">Reed Mullanix</a><div class="metadata"><a href="#230936320" name="230936320"><div>2021-03-18 20:57:36</div></a></div><div class="text"><p>Consistency means a lot of different things to different people, sadly. It's like the term "normal"</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#230947136" name="230947136"><div>2021-03-18 22:27:23</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="251002">Gabriel Lebec</span> <a href="#narrow/stream/201383-General/topic/Untyped.20lambda.20calculus.20is.20inconsistent/near/230929802">said</a>:</p>
<blockquote>
<p><a href="/user_uploads/13896/u11jbuiFCHVgtU1V9JmhXSdW/87D2195C-A9B0-4D9E-8EEF-F645BDD5A4B3.jpg">87D2195C-A9B0-4D9E-8EEF-F645BDD5A4B3.jpg</a></p>
</blockquote>
<p>Indeed, "consistency" depends on the situation. I'd interpret LC as "consistent for modeling" computations (the definition of "consistency" could be "can compute anything Turing machines can") and "inconsistent for logic" as in "bad for trying to encode propositions and reason about them".</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#231219977" name="231219977"><div>2021-03-21 14:37:12</div></a></div><div class="text"><p>Just a thought I had, I'll leave it here in case it interests anyone. If LC is ("logically" or "ultimately") inconsistent, then Turing machines are inconsistent, then the concept of computation is inconsistent. If computation is inconsistent you so are proof assistants and the process of elaborating proofs on paper. Therefore, LC cannot be ultimately inconsistent, just very, very inconvenient to use for formal logic/all simple encodings fail (you could implement Coq or Agda or any proof assistant on LC and do your proofs using it).</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/2f4316c80f59f157d26cb515ed98026308998f44?x=x&amp;version=2"></a><div class="content"><a class="author">Nick Scheel</a><div class="metadata"><a href="#231420809" name="231420809"><div>2021-03-23 04:33:54</div></a></div><div class="text"><p>You’re mixing up usages of inconsistency. Lambda calculus and turing machines are both perfectly fine models of computation, there’s no dispute there. They both allow for potentially nonterminating computations, which is desirable for some applications. But untyped lambda calculus is horrible as a language for math/logic in two ways:</p>
<p>At the level of propositions (think: types), lambda calculus cannot be used as a language for expressing propositions, because every proposition would then be derivable (inconsistency). Note that this is shown via adding logical symbols (like implication, conjunction, etc.) to the lambda calculus to represent logical propositions, and then using standard deductive inference rules to derive the inconsistency. (This is Curry’s Paradox.)</p>
<p>At the level of proofs of propositions (think: terms of types), untyped lambda calculus is still inconsistent. In particular, if you try to assign types to terms in naïve ways that still let in fixpoint operators, you quickly find that you can produce a proof of any proposition (a term of any type). This is the kind of inconsistency that is usually meant when talking about this kind of thing. (Haskell is logically inconsistent for the same reason: every type has an inhabitant.) There are probably deeper/stronger results lying around about the relationship of nontermination computations leading to trivial proof systems (that don’t involve fixpoint operators), but I don’t know them off the top of my head.</p>
<p>(Note that in dependent type theories, lambda calculus is used to represent both types and terms, propositions and proofs. So it’s doubly bad if the types aren’t strong enough to prevent these inconsistencies.)</p>
<p>Anyways. The cause of both of these issues is the unlimited recursion allowed by naïve fixpoint operations. The problem thus becomes how to allow certain fixpoints while remaining consistent, in the senses outlined above. And it turns out to require computational termination of the fixpoints, so there is a single unique solution.</p>
<p>I hope this Wikipedia article will clear up further confusion you may have: <a href="https://en.wikipedia.org/wiki/Deductive_lambda_calculus">https://en.wikipedia.org/wiki/Deductive_lambda_calculus</a></p>
<p>Logic as a field is full of disappointing results and many limitations, but it is also very rewarding once you understand more of the big picture of how things fit together.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/2f4316c80f59f157d26cb515ed98026308998f44?x=x&amp;version=2"></a><div class="content"><a class="author">Nick Scheel</a><div class="metadata"><a href="#231420980" name="231420980"><div>2021-03-23 04:35:23</div></a></div><div class="text"><p>P.S. We don’t actually know that ZFC set theory is consistent. We suspect it is, and we know many (type) theories that are equiconsistent with it, but we cannot prove that ZFC is consistent from it’s own axioms (this is Gödel’s theorem)</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>