<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="What is the simplest theorem prover/verifier/checker you know? This question is two fold: simplest implementation and simplest meta-theory.
Here are the ones I know:
Simplest implementation:

Victor Maia&#39;s implementation of Cedille Core: Based on the Aaron Stump&#39;s Calculus of Dependent Lambda Elimin" name="description"><link href="https://funprog.srid.ca/general/simplest-theorem-prover.html" rel="canonical"><meta property="og:title" content="Simplest theorem prover - General"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="General"><meta property="og:article:modified_time" content="2020-09-29T22:56:56Z"><meta property="og:article:published_time" content="2020-09-28T01:00:42Z"><meta property="og:image" content="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"><title>Simplest theorem prover - General</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">Simplest theorem prover - General</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/general/" class="section">#General</a><i class="right angle icon divider"></i><div class="active section">Simplest theorem prover</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#211443285" name="211443285"><div>2020-09-28 01:00:42</div></a></div><div class="text"><p>What is the simplest theorem prover/verifier/checker you know? This question is two fold: simplest implementation and simplest meta-theory.</p>
<p>Here are the ones I know:</p>
<p>Simplest implementation:</p>
<ul>
<li><a href="https://github.com/MaiaVictor/Cedille-Core/blob/master/old_haskell_implementation/Core.hs">Victor Maia's implementation of Cedille Core</a>: Based on the Aaron Stump's <em>Calculus of Dependent Lambda Eliminations</em> (CDLE). I believe this ties for the simplest implementation of a theorem prover with the next item on this list. Note that I mean simplest <em>implementation</em>, you gotta understand CDLE or it will seem like a quite weird extension of the Calculus of Constructions (CC).</li>
<li><a href="http://us.metamath.org/downloads/mmverify.py">Raph Levien's Metamath implementation in Python</a>: ties for simplest implementation with the above.</li>
<li><a href="https://formal.iti.kit.edu/beckert/pub/LeanTAP.pdf">Beckert and Posegga's leanTAP</a>: its simple due to its size, but its written in quite compact Prolog which makes it harder to read. An interesting extension called <a href="http://webyrd.net/alphaleantap/alphatap.pdf">alpha leanTAP</a> exists, which is written in Scheme (using miniKanren, if I remember correctly). You can read more about it <a href="https://formal.iti.kit.edu/beckert/leantap/">here</a>.</li>
</ul>
<p>Simplest theory:</p>
<ul>
<li>Any implementation of Simply Typed Lambda Calculus. However, you can't prove many interesting things in it.</li>
<li>Metamath's formal grammar: Metamath is weird. I don't really understand its theoretical basis, it seems like it comes from the study of formal grammars. Mario Carneiro's paper <a href="https://arxiv.org/abs/1601.07699">Models for Metamath</a> seems like a great resource, which unfortunately haven't had the time to read yet.</li>
<li>The Calculus of Constructions: many implementations of which exists, a few which come to mind are <a href="https://hackage.haskell.org/package/morte">Morte</a> and <a href="https://gist.github.com/pedrominicz/b1a9ab5a9ff67d3d7df57817510163be">my own tiny (and hopefully correct) implementation</a>.</li>
<li>The Calculus of Dependent Lambda Eliminations: its a very elegant (once you understand) extension of CC that derives induction.</li>
</ul></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#211443353" name="211443353"><div>2020-09-28 01:02:54</div></a></div><div class="text"><p>Hopefully, others can contribute for these lists. It is really hard to find truly <em>small</em> theorem provers (ones which you can hopefully read the entire source code in one sitting, from the ones above, only Morte doesn't fit this criteria). Also, if someone could please explain to me what exactly is going on with Metamath's meta-theory it would be much appreciated. <span aria-label="grinning face with smiling eyes" class="emoji emoji-1f601" role="img" title="grinning face with smiling eyes">:grinning_face_with_smiling_eyes:</span></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/060188f013042ed3fa39f3b5aa602be2"></a><div class="content"><a class="author">Daniel Bramucci</a><div class="metadata"><a href="#211454210" name="211454210"><div>2020-09-28 05:53:57</div></a></div><div class="text"><p>I believe <a href="https://github.com/moonad/formality">Formality</a> is one of the simpler proof-languages implementation wise. But I haven't looked to closely at it.</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/moonad/formality" style="background-image: url(https://repository-images.githubusercontent.com/140790634/461ea380-80c0-11e9-9e70-ec177a6659fd)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/moonad/formality" title="moonad/Formality">moonad/Formality</a></div><div class="message_embed_description">An efficient proof language. Contribute to moonad/Formality development by creating an account on GitHub.</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#211489409" name="211489409"><div>2020-09-28 13:06:48</div></a></div><div class="text"><p>Indeed. Formality is pretty cool. However, I don't believe its consistent. It has been a while since I've last checked it out, but back then, their goal had moved away from begin logically consistent to being nicer to program with.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#211489601" name="211489601"><div>2020-09-28 13:08:26</div></a></div><div class="text"><p>I would be great news if what they are doing with self types/insanely dependent types (I don't know what they call, but it is kind of mix of both of these concepts) actually happens to be consistent, i.e., not allow one to inhabit <code>false</code>.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#211512069" name="211512069"><div>2020-09-28 16:00:29</div></a></div><div class="text"><p>I've managed to get math-phobic and recreational people hooked on <a href="http://incredible.pm/">http://incredible.pm/</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eec8691200732875d9d0a619ea1be7ca"></a><div class="content"><a class="author">Albert ten Napel</a><div class="metadata"><a href="#211530685" name="211530685"><div>2020-09-28 18:28:59</div></a></div><div class="text"><p>A system based on "Gentle art of levitation" would be pretty simple to implement (except for cumulative universe which I haven't figured out yet). You start with dependent functions and pairs, add finite types (unit + bool for example) and then you add descriptions and fixpoints on them. Using the descriptions you can define inductive datatypes (or indexed types and even recursive-inductive and inductive-inductive types based on what descriptions you use) and define a induction principle for them. I think this gives you a lot of expressivity in a small package. I also I found elaboration easier to implement than CDLE or self-types.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#211550053" name="211550053"><div>2020-09-28 21:02:57</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="250729">James King</span> <a href="#narrow/stream/201383-General/topic/Simplest.20theorem.20prover/near/211512069">said</a>:</p>
<blockquote>
<p>I've managed to get math-phobic and recreational people hooked on <a href="http://incredible.pm/">http://incredible.pm/</a></p>
</blockquote>
<p>Oh, very interesting, looks pretty cool. It remembered be of <a href="http://logitext.mit.edu/tutorial">this interactive sequent calculus tutorial</a> (spoiler: its pretty good).</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#211551034" name="211551034"><div>2020-09-28 21:10:45</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="345009">Albert ten Napel</span> <a href="#narrow/stream/201383-General/topic/Simplest.20theorem.20prover/near/211530685">said</a>:</p>
<blockquote>
<p>A system based on "Gentle art of levitation" would be pretty simple to implement [...]</p>
</blockquote>
<p>I remember stumbling upon this paper about a year ago. It looked a bit convoluted, but I was way less familiar with this stuff back then. Is there an implementation of it's type theory around somewhere?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#211551328" name="211551328"><div>2020-09-28 21:13:28</div></a></div><div class="text"><p>About (non-comulative) universes, Andrej Bauer implements them in his series <a href="http://math.andrej.com/2012/11/08/how-to-implement-dependent-type-theory-i/">How to Implement a Dependent Type Theory</a>. I wonder how much more difficult comulative universes really are.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/3fd04473065250c8eec3f222ba3a974b28940e8a?x=x&amp;version=2"></a><div class="content"><a class="author">Pedro Minicz</a><div class="metadata"><a href="#211551362" name="211551362"><div>2020-09-28 21:13:57</div></a></div><div class="text"><p><del>I personally haven't implement them</del> (actually, <a href="https://gist.github.com/pedrominicz/f7bb617145940b8b048e4bf7d89a06c3">I have</a>), but they look simpler than positivity checking, W-types, etc.</p>
<div class="message_embed"><a class="message_embed_image" href="https://gist.github.com/pedrominicz/f7bb617145940b8b048e4bf7d89a06c3" style="background-image: url(https://github.githubassets.com/images/modules/gists/gist-og-image.png)"></a><div class="data-container"><div class="message_embed_title"><a href="https://gist.github.com/pedrominicz/f7bb617145940b8b048e4bf7d89a06c3" title="Minimal Type Theory with Universes and Pi Types.">Minimal Type Theory with Universes and Pi Types.</a></div><div class="message_embed_description">Minimal Type Theory with Universes and Pi Types. GitHub Gist: instantly share code, notes, and snippets.</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eec8691200732875d9d0a619ea1be7ca"></a><div class="content"><a class="author">Albert ten Napel</a><div class="metadata"><a href="#211588039" name="211588039"><div>2020-09-29 07:23:22</div></a></div><div class="text"><p>When I first looked at "Gentle art of levitation" I also found it convoluted, but after making some implementations of dependent type theories the implementation of datatypes using descriptions is actually much easier than native top-level datatype definitions. It's worth to give another look. Unfortunately I am unable to find any implementation of it, Epigram and Foveran (<a href="https://github.com/bobatkey/foveran">https://github.com/bobatkey/foveran</a>) and Spire use them, but they are basically abandoned.</p>
<p>About universes, yes I've seen the implementation of Andrej Bauer but the difficulty I'm talking about is being able to lift definitions to different universes. You don't want to write the same definition multiple times just to use it in a higher level. This lifting operator is a bit tricky to implement from what I read, but I still need to spend more time on it.</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bobatkey/foveran" style="background-image: url(https://avatars1.githubusercontent.com/u/496697?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bobatkey/foveran" title="bobatkey/foveran">bobatkey/foveran</a></div><div class="message_embed_description">A Dependently Typed Programming Language. Contribute to bobatkey/foveran development by creating an account on GitHub.</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eec8691200732875d9d0a619ea1be7ca"></a><div class="content"><a class="author">Albert ten Napel</a><div class="metadata"><a href="#211588531" name="211588531"><div>2020-09-29 07:30:34</div></a></div><div class="text"><p>Spire blog: <a href="http://spire-lang.org/blog/2014/01/15/modeling-elimination-of-described-types/">http://spire-lang.org/blog/2014/01/15/modeling-elimination-of-described-types/</a><br>
Another blog post about descriptions: <a href="http://effectfully.blogspot.com/2016/04/descriptions.html">http://effectfully.blogspot.com/2016/04/descriptions.html</a></p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eec8691200732875d9d0a619ea1be7ca"></a><div class="content"><a class="author">Albert ten Napel</a><div class="metadata"><a href="#211588835" name="211588835"><div>2020-09-29 07:34:51</div></a></div><div class="text"><p>And yeah, with descriptions you do not need to do any positivity checking, the description setup will ensure the datatypes are strictly-positive. The downside is that you are also more limited in which datatypes you can get.<br>
I read that W-types are not good at all in an intensional setting, Conor McBride had a blog post on it that I am now unable to find.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/0c593127d2fd91b066d2240ca4a50130"></a><div class="content"><a class="author">Joey Eremondi</a><div class="metadata"><a href="#211662242" name="211662242"><div>2020-09-29 18:18:05</div></a></div><div class="text"><p>I'd add Cur to this list. It's basic idea is "provide a minimal type theory, and then use macros to build things on top of this". It also has the advantage of being built using Turnstile, so its implementation looks a lot like type rules: <a href="https://github.com/wilbowma/cur">https://github.com/wilbowma/cur</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/wilbowma/cur" style="background-image: url(https://avatars2.githubusercontent.com/u/1133598?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/wilbowma/cur" title="wilbowma/cur">wilbowma/cur</a></div><div class="message_embed_description">A less devious proof assistant. Contribute to wilbowma/cur development by creating an account on GitHub.</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/eec8691200732875d9d0a619ea1be7ca"></a><div class="content"><a class="author">Albert ten Napel</a><div class="metadata"><a href="#211664612" name="211664612"><div>2020-09-29 18:34:10</div></a></div><div class="text"><p>Ah that's very cool! Looks like Cur's core language is similar to the Calculus of Inductive Constructions. I will also link Dedukti/LambdaPi: <a href="https://github.com/Deducteam/lambdapi">https://github.com/Deducteam/lambdapi</a> which is a type theory with rewrite rules. The core language is very simply, basically the Calculus of Constructions but I think the rewrite rules allow you to define more complicated theories inside of the language. I do wonder how consistency/canonicity is ensured though, if it is.</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/Deducteam/lambdapi" style="background-image: url(https://avatars0.githubusercontent.com/u/32068788?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/Deducteam/lambdapi" title="Deducteam/lambdapi">Deducteam/lambdapi</a></div><div class="message_embed_description">Proof assistant based on the λΠ-calculus modulo rewriting - Deducteam/lambdapi</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/b85093f49df5843556c464d319fd8939"></a><div class="content"><a class="author">Mario Carneiro</a><div class="metadata"><a href="#211694455" name="211694455"><div>2020-09-29 22:45:54</div></a></div><div class="text"><p><span class="user-mention" data-user-id="346868">@Pedro Minicz</span> I would also add to the list of simplest implementations the amazing turing machine written in an optimizing compiler called Not Quite Laconic (NQL) which was used to give a bound on the <a href="https://www.scottaaronson.com/blog/?p=2725">smallest undecidable busy beaver number</a>. It was essentially a metamath kernel that enumerated proofs in ZFC looking for a contradiction</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/b85093f49df5843556c464d319fd8939"></a><div class="content"><a class="author">Mario Carneiro</a><div class="metadata"><a href="#211694547" name="211694547"><div>2020-09-29 22:46:53</div></a></div><div class="text"><p>it was something around a 1500 state TM whose termination could not be proved in ZFC (EDIT: <a href="https://github.com/sorear/metamath-turing-machines">here it is, 1919 states</a>)</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/sorear/metamath-turing-machines" style="background-image: url(https://avatars3.githubusercontent.com/u/92735?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/sorear/metamath-turing-machines" title="sorear/metamath-turing-machines">sorear/metamath-turing-machines</a></div><div class="message_embed_description">metamath proof enumerators and other things. Contribute to sorear/metamath-turing-machines development by creating an account on GitHub.</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/b85093f49df5843556c464d319fd8939"></a><div class="content"><a class="author">Mario Carneiro</a><div class="metadata"><a href="#211695301" name="211695301"><div>2020-09-29 22:56:56</div></a></div><div class="text"><p>Also HOL light definitely deserves to be in the running for simplest kernel; IIRC John Harrison has the implementation written on a T-shirt. I'm not sure if the actual kernel in the hol light distribution is as small as it could be, but <a href="https://github.com/jrh13/hol-light/blob/master/fusion.ml">here it is</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/jrh13/hol-light/blob/master/fusion.ml" style="background-image: url(https://avatars2.githubusercontent.com/u/15177806?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/jrh13/hol-light/blob/master/fusion.ml" title="jrh13/hol-light">jrh13/hol-light</a></div><div class="message_embed_description">The HOL Light theorem prover. Contribute to jrh13/hol-light development by creating an account on GitHub.</div></div></div></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>