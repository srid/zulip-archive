<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="Which one improves ones FP ability more?" name="description"><link href="https://funprog.srid.ca/general/category-theory-or-lambda-calculus.html" rel="canonical"><meta property="og:title" content="category theory or lambda calculus - General"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="General"><meta property="og:article:modified_time" content="2020-10-09T08:10:04Z"><meta property="og:article:published_time" content="2020-10-08T16:13:06Z"><title>category theory or lambda calculus - General</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">category theory or lambda calculus - General</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/general/" class="section">#General</a><i class="right angle icon divider"></i><div class="active section">category theory or lambda calculus</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3cea5dd94abba9982d34d28eef71efc0"></a><div class="content"><a class="author">Mason Mackaman</a><div class="metadata"><a href="#212713649" name="212713649"><div>2020-10-08 16:13:06</div></a></div><div class="text"><p>Which one improves ones FP ability more?</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?x=x&amp;version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#212716513" name="212716513"><div>2020-10-08 16:34:33</div></a></div><div class="text"><p>LC is to FP languages what Turing machine is to imperative languages - it's minimal model through which languages can be built and studied<br>
CT is branch of mathematics interested in composition - that's something close to principles of FP upon which many patterns are built, but it's not directly related to LC (except that as with many other constructs, it provides it's <a href="https://en.wikipedia.org/wiki/Cartesian_closed_category">generalization</a>)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4d7e5bf37281d41829f7b8a95d15292ff274c327?x=x&amp;version=2"></a><div class="content"><a class="author">Vladimir Ciobanu</a><div class="metadata"><a href="#212720748" name="212720748"><div>2020-10-08 17:06:02</div></a></div><div class="text"><p>My experience has been that LC can bring some pretty immediate gains (i.e., you can read an article, or a book, and you get quite a bit out of it, especially if you're interested in type systems, languages, etc.). CT feels like a longer term thing. The gains aren't as immediate, you need to put in a lot more effort. BUT, it seems like you also tend to get a lot in return, later. Also, it seems like a bottomless pit that keeps on taking time but giving back cool abstractions.</p>
<p>I would say, have a look at LC. It's fun and doesn't take nearly as much to get a hang on than CT. Then, if you like CS, abstract thinking, etc., take the plunge into CT.</p>
<p>Again, this is definitely an opinion and none of the above are facts.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/4ba4faf2fc5818d37c0aed6acb5b69a2"></a><div class="content"><a class="author">James King</a><div class="metadata"><a href="#212725732" name="212725732"><div>2020-10-08 17:46:25</div></a></div><div class="text"><p>I agree, in my experience LC is much easier to learn and is, "well understood," in that there isn't a huge amount of active research in the area. CT is still growing and is a large subject already and has taken me much longer to get into.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/3cea5dd94abba9982d34d28eef71efc0"></a><div class="content"><a class="author">Mason Mackaman</a><div class="metadata"><a href="#212734036" name="212734036"><div>2020-10-08 18:52:44</div></a></div><div class="text"><p>interesting, thanks for the insight. I've already started down the CT road myself. But I hadn't really considered the benefits I could get from studying LC. I think I'll switch it up for a bit and give it a look.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/50acdbb06815de011cba7d2133e76b2b756bd3bc?x=x&amp;version=2"></a><div class="content"><a class="author">Sandro Pollastrini</a><div class="metadata"><a href="#212785929" name="212785929"><div>2020-10-09 05:54:45</div></a></div><div class="text"><p>CT is vast. The risk is to loose one self. However this <em>does not mean</em> that it is worthless, but it is similar to approach the theme <em>algebra</em> with the aim of learning linear algebra: if you take a classical algebra book (say <em>Lang</em>'s), you will loose your self pretty soon and will not find any linear algebra. But if you start from the right book, you'll gain what you want.</p>
<p><strong>Which book about CT <em>and</em> FP?</strong> Definitely: Bartosz Milewski's <strong>Category Theory for Programmers</strong> (<a href="https://github.com/hmemcpy/milewski-ctfp-pdf">free pdf on GitHub</a>): it contains examples in Haskell and in C++ (there is also a Scala version of the book); you don't actually need to read it all: you read something, you apply something; you read another bit, you apply the new bit; ...</p>
<p>The same argument is true even for LC. LC is vast (not as CT), because it encompass the various versions of it (from the untyped to the type versions).<br>
I personally found usefull understand the principles, considering that they underlying all FP, both the untyped and the typed versions. But you'll risk to loose a lot of time (e.g., Barendregt's <em>The Lambda Calculus - Its Syntax and Semantics</em> is beautiful, but it too deep and it is not clear what you'll gain from it if your aim is to be better at FP).</p>
<p><strong>Which book about LC <em>and</em> FP?</strong> Simon Thompson's Type Theory and Functional Programming (<a href="https://www.cs.kent.ac.uk/people/staff/sjt/TTFP/">free pdf</a>): it gives you both untyped and typed versions, showing you even type theory, which one of the point of conjunction with CT. And it is short!</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/hmemcpy/milewski-ctfp-pdf" style="background-image: url(https://avatars2.githubusercontent.com/u/601206?s=400&amp;v=4)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/hmemcpy/milewski-ctfp-pdf" title="hmemcpy/milewski-ctfp-pdf">hmemcpy/milewski-ctfp-pdf</a></div><div class="message_embed_description">Bartosz Milewski's 'Category Theory for Programmers' unofficial PDF and LaTeX source - hmemcpy/milewski-ctfp-pdf</div></div></div></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4d7e5bf37281d41829f7b8a95d15292ff274c327?x=x&amp;version=2"></a><div class="content"><a class="author">Vladimir Ciobanu</a><div class="metadata"><a href="#212787538" name="212787538"><div>2020-10-09 06:30:46</div></a></div><div class="text"><p>I love Bartosz, but I am not able to learn CT from his book. It feels too loose in terminology / theory. It has great explanations for early stuff though.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://www.gravatar.com/avatar/1114fd8de67671f83d3a3ef7594b1950"></a><div class="content"><a class="author">Georgi Lyubenov // googleson78</a><div class="metadata"><a href="#212787575" name="212787575"><div>2020-10-09 06:31:29</div></a></div><div class="text"><p>for lc I can recommend Pierce's Types and Programming Languages, because it is somewhat "programming/implementation oriented" (e.g. it discusses aspects of LC that you need for implementing it, and it also has an ocaml (iirc) implementation of the discussed topic at the end  of some chapters)</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4d7e5bf37281d41829f7b8a95d15292ff274c327?x=x&amp;version=2"></a><div class="content"><a class="author">Vladimir Ciobanu</a><div class="metadata"><a href="#212787671" name="212787671"><div>2020-10-09 06:32:51</div></a></div><div class="text"><p>I can second that. I also found Type Theory and Formal Proof to be excellent, especially if you want a more logical/formal approach than Pierce's CS/practical approach (<a href="https://www.amazon.com/Type-Theory-Formal-Proof-Introduction/dp/110703650X">https://www.amazon.com/Type-Theory-Formal-Proof-Introduction/dp/110703650X</a>).</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/50acdbb06815de011cba7d2133e76b2b756bd3bc?x=x&amp;version=2"></a><div class="content"><a class="author">Sandro Pollastrini</a><div class="metadata"><a href="#212788685" name="212788685"><div>2020-10-09 06:51:23</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="250750">Vladimir Ciobanu</span> <a href="#narrow/stream/201383-General/topic/category.20theory.20or.20lambda.20calculus/near/212787538">said</a>:</p>
<blockquote>
<p>I love Bartosz, but I am not able to learn CT from his book. It feels too loose in terminology / theory. It has great explanations for early stuff though.</p>
</blockquote>
<p>Yes, I can see your point. But it is exactly the point of the book: to give you the most intuitive way of thinking to the FP stuff through the CT intellectual machinery. This could be a good entry point (which is what probably Mason asked about) to give basic concepts (already useful in FP context, expecially Haskell/Scala) and terminology.</p>
<p>Furthermore, the book goes way beyond the basics.</p>
<p>You can always help the reading with other books more specifically CT oriented, as Pierce's <a href="https://mitpress.mit.edu/books/basic-category-theory-computer-scientists">Category Theory for Computer Scientists</a> (even if my favourite  is Awodey's <a href="https://global.oup.com/ukhe/product/category-theory-9780199237180?cc=it&amp;lang=en&amp;">Category Theory</a>, which is for me the right level of difficulty).</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/4d7e5bf37281d41829f7b8a95d15292ff274c327?x=x&amp;version=2"></a><div class="content"><a class="author">Vladimir Ciobanu</a><div class="metadata"><a href="#212789112" name="212789112"><div>2020-10-09 06:58:35</div></a></div><div class="text"><p>I would say Bartosz' book (and video series) are quite good up until limits. It seems to get a bit hairy after that, at least IME. OTOH, I guess part of the idea is to do a ton of exercises and exploring on one's own, which I have not done.</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/50acdbb06815de011cba7d2133e76b2b756bd3bc?x=x&amp;version=2"></a><div class="content"><a class="author">Sandro Pollastrini</a><div class="metadata"><a href="#212789383" name="212789383"><div>2020-10-09 07:02:05</div></a></div><div class="text"><p>You got me thinking to the exercises, and in fact I think that Bartosz's book would benefit from an expansions: some good exercize (with solutions!) would have been great!</p></div></div></div><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/50acdbb06815de011cba7d2133e76b2b756bd3bc?x=x&amp;version=2"></a><div class="content"><a class="author">Sandro Pollastrini</a><div class="metadata"><a href="#212794650" name="212794650"><div>2020-10-09 08:10:04</div></a></div><div class="text"><p><span class="user-mention silent" data-user-id="250750">Vladimir Ciobanu</span> <a href="#narrow/stream/201383-General/topic/category.20theory.20or.20lambda.20calculus/near/212787671">said</a>:</p>
<blockquote>
<p>I can second that. I also found Type Theory and Formal Proof to be excellent, especially if you want a more logical/formal approach than Pierce's CS/practical approach (<a href="https://www.amazon.com/Type-Theory-Formal-Proof-Introduction/dp/110703650X">https://www.amazon.com/Type-Theory-Formal-Proof-Introduction/dp/110703650X</a>).</p>
</blockquote>
<p>Didn't know about this book of Nederpelt and Geuvers! Cool!</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>