<html lang="en"><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1" name="viewport"><meta content="This idea keeps floating in my mind and I would like to know if it&#39;s already described somewhere or if it at least could work:
Let&#39;s say we typecheck language with this constraint-solving mechanism that GHC uses - create unification variables for values, run through syntax tree inferring some constr" name="description"><link href="https://funprog.srid.ca/type-theory/parallel-types.html" rel="canonical"><meta property="og:title" content="&quot;Parallel&quot; types - Type Theory"><meta property="og:site_name" content="Functional Programming Zulip Archive"><meta property="og:type" content="article"><meta property="og:article:section" content="Type Theory"><meta property="og:article:modified_time" content="2020-05-14T19:40:48Z"><meta property="og:article:published_time" content="2020-05-14T19:40:48Z"><meta property="og:image" content="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?x=x&amp;version=2"><title>&quot;Parallel&quot; types - Type Theory</title><style type="text/css">
div#thesite
{
  font-family   : "Open Sans", sans-serif;
  font-size     : 1em !important;
  margin-top    : 1em;
  margin-bottom : 1em;
}

div#thesite h1
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h2
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h3
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h4
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h5
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite h6
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .ui.breadcrumb.rib .section
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite .as-header
{
  font-family : "Roboto", sans-serif;
  line-height : 1.19999em;
}

div#thesite code, pre, tt
{
  font-family : "SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace;
}

div#thesite .ui.breadcrumb.rib
{
  margin-bottom : 1em;
}



div#thesite .ui.comments.messages .comment .metadata a
{
  color : #808080;
}

div#thesite .ui.comments.messages .comment a.avatar img
{
  height : auto;
}

div#thesite .subtle
{
  color : #808080;
}


div#thesite .messages pre
{
  font-size : 85%;
  overflow  : auto;
  max-width : 100%;
}

div#thesite .messages .message_embed
{
  border-left  : solid 3px #808080;
  padding-left : 0.69999em;
}

div#thesite .messages .message_inline_image img
{
  max-width     : 100%;
  margin-bottom : 1em;
}


/* Generated with Clay, http://fvisser.nl/clay */</style><link href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css" rel="stylesheet"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Open+Sans|Oswald&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto|Open+Sans&amp;display=swap" rel="stylesheet"></head><body><div id="thesite" class="ui text container"><div class="ui violet inverted top attached center aligned segment"><h1 class="ui huge header">&quot;Parallel&quot; types - Type Theory</h1></div><div class="ui attached segment"><div class="ui message"><p>Welcome to the Functional Programming Zulip Chat Archive. You can join the chat <a href="https://funprog.zulipchat.com">here</a>.</p></div><div class="ui breadcrumb rib"><a href="/" class="section">Home</a><i class="right angle icon divider"></i><a href="/type-theory/" class="section">#Type Theory</a><i class="right angle icon divider"></i><div class="active section">&quot;Parallel&quot; types</div></div><div class="ui comments messages"><div class="comment"><a class="avatar"><img src="https://zulip-avatars.s3.amazonaws.com/13896/20a04d823b7c3891d78ca5f6a188ccd0e4fc5e3d?x=x&amp;version=2"></a><div class="content"><a class="author">TheMatten</a><div class="metadata"><a href="#197607395" name="197607395"><div>2020-05-14 19:40:48</div></a></div><div class="text"><p>This idea keeps floating in my mind and I would like to know if it's already described somewhere or if it at least could work:</p>
<p>Let's say we typecheck language with this constraint-solving mechanism that GHC uses - create unification variables for values, run through syntax tree inferring some constraints, solve constraints, fill in solved types in place of variables. Now, what if one value had more of these - what if it had <em>multiple types</em>, in different, <em>parallel universes</em>? What I mean by this is that there would be multiple unification variables for same value in different universes, with separate inference pass and unification mechanism which could be part of compiler or maybe a plugin - they would share the same typechecker "framework" with normal <code>Type</code> universe and could have "runtime proofs" (similar to coercions or dictionaries), but they could check different properties about code, parallel to normal types. For example, I could have universe of multiplicities, where these custom extension would check whether number of uses of some value corresponds to it's inferred/assigned multiplicity. Or maybe universe of subtyping relations - imagine we created universe <code>data Optic = Getter Type Type | Setter Type Type Type | Lens Type Type Type Type | ...</code> where unification would respect subtyping relations between optics and emit conversions between representations as runtime proofs - similarly to <code>Type</code> signatures, we could have <code>Optic</code> signatures, e.g. telling that <code>view</code> expects optic of type <code>Getter</code> (<code>Type</code> type could be something monomorphic and opaque to not get into way).</p>
<p>Motivation for this is some sort of extensibility in type system - currently, when you want to introduce additional property to types, you usually do so by indexing all relevant types over it, which is backwards-incompatible solution that doesn't scale indefinitely - with sort of parallel model, I could define additional properties for values I care about and infer some dummy types for other values in backwards-compatible way.</p></div></div></div></div></div><div class="ui vertical footer segment"><a href="https://github.com/srid/zulip-archive">Powered by Haskell</a> | Questions? Contact <a href="https://www.srid.ca">srid</a></div></div></body></html>